=== Getting Started with the Compiler

At this point, you are surely very bored with the constant theoretical explanations
about the language itself and will want to write and execute some code. The goal of
this section is to provide a little practical introduction to the _ClojureScript_
compiler.

The _ClojureScript_ compiler takes the source code that has been split over numerous
directories and namespaces and compiles it down to JavaScript. Today, JavaScript has
a great number of different environments where it can be executed - each with its own
peculiarities.

This chapter intends to explain how to use _ClojureScript_ without any additional
tooling. This will help you understand how the compiler works and how you can use it
when other tooling is not available (such as link:http://leiningen.org/[leiningen] +
link:https://github.com/emezeske/lein-cljsbuild[cljsbuild] or
link:http://boot-clj.com/[boot]).


==== Execution environments

What is an execution environment? An execution environment is an engine where
JavaScript can be executed. For example, the most popular execution environment is a
browser (Chrome, Firefox, ...) followed by the second most popular -
link:https://nodejs.org/[nodejs].

There are others, such as Rhino (JDK 6+), Nashorn (JDK 8+), QtQuick (QT),... but
none of them have significant differences from the first two. So,
_ClojureScript_ at the moment may compile code to run in the browser or in
nodejs-like environments out of the box.


==== Download the compiler

The fastest way to obtain all the tooling needed for ClojureScript compilaition is
installing the Clojure CLI Tools:

[source, bash]
----
curl -O https://download.clojure.org/install/linux-install-1.10.1.462.sh
chmod +x linux-install-1.10.1.462.sh
sudo ./linux-install-1.10.1.462.sh
----

If you are using other operating system other than linux, refer to
https://clojure.org/guides/getting_started page.

Although the _ClojureScript_ is self hosted, in this book we will use
the JVM implementation, with in turn requires JDK8 or JDK11
installed. You can obtain it using your distribution default package
manager or download it from
link:https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html[Oracle]
or link:https://www.azul.com/downloads/zulu-community/[Azul]

.Example installing it using a apt in a debian-like distribution
[source, bash]
----
sudo apt-get install openjdk-8-jdk rlwrap
----

==== Compile for Node.js

Let’s start with a practical example compiling code that will target *Node.js*
(hereafter simply "nodejs"). For this example, you should have nodejs installed.

There are different ways to install nodejs, but the recommended way is using nvm
("Node.js Version Manager"). You can read the instructions on how to install and use
nvm on its link:https://github.com/creationix/nvm[home page].

When you have installed nvm, follow installing the latest version of nodejs:

[source, shell]
----
nvm install v10.16.0
nvm alias default v10.16.0
----

You can test if *nodejs* is installed in your system with this command:

[source, shell]
----
$ node --version
v10.16.0
----


===== Create the example application

For the first step of our practical example, we will create our application directory
structure and populate it with example code.

Start by creating the directory tree structure for our “hello world” application:

[source, bash]
----
mkdir -p myapp/src/myapp
touch myapp/src/myapp/core.cljs
----

Resulting in this directory tree:

[source, text]
----
myapp
└── src
    └── myapp
        └── core.cljs
----


Second, write the example code into the previously created
`myapp/src/myapp/core.cljs` file:

[source, clojure]
----
(ns myapp.core
  (:require [cljs.nodejs :as nodejs]))

(nodejs/enable-util-print!)

(defn -main
  [& args]
  (println "Hello world!"))

(set! *main-cli-fn* -main)
----

NOTE: It is very important that the declared namespace in the file exactly matches
the directory structure. This is the way _ClojureScript_ structures its source code.

And finally, lets create the `myapp/deps.edn` declaring the clojure
and clojurescript versions:

[source, clojure]
----
{:deps {org.clojure/clojurescript {:mvn/version "1.10.520"}
        org.clojure/clojure {:mvn/version "1.10.1"}}
 :paths ["src"]}
----


===== Compile the example application

In order to compile that source code, we need a simple build script that tells the
_ClojureScript_ compiler the source directory and the output file. _ClojureScript_
has a lot of other options, but at this moment we can ignore that.

Let’s create the `myapp/build.clj` file with the following content:

[source, clojure]
----
(require '[cljs.build.api :as b])

(b/build "src" {:main 'myapp.core
                :output-to "main.js"
                :output-dir "out"
                :target :nodejs
                :verbose true})
----

This is a brief explanation of the compiler options used in this example:

* The `:output-to` parameter indicates to the compiler the destination of the compiled
  code, in this case to the "main.js" file.
* The `:main` property indicates to the compiler the namespace that will act as the entry
  point of your application when it's executed.
* The `:target` property indicates the platform where you want to execute the compiled
  code. In this case, we are going to use *nodejs*. If you omit this
  parameter, the source will be compiled to run in the browser environment.

To run the compilation, just execute the following command:

[source, bash]
----
cd myapp
clojure build.clj
----

And when it finishes, execute the compiled file using *node*:

[source, shell]
----
$ node main.js
Hello world!
----


==== Compile for the Browser

In this section we are going to create an application similar to the "hello world"
example from the previous section to run in the browser environment. The minimal
requirement for this application is just a browser that can execute JavaScript.

The process is almost the same, and the directory structure is the same. The only
things that changes is the entry point of the application and the build script. So,
start re-creating the directory tree from previous example in a different directory.

[source, bash]
----
mkdir -p mywebapp/src/mywebapp
touch mywebapp/src/mywebapp/core.cljs
----

Resulting in this directory tree:

[source, text]
----
mywebapp
└── src
    └── mywebapp
        └── core.cljs
----

Then, write new content to the `mywebapp/src/mywebapp/core.cljs` file:

[source, clojure]
----
(ns mywebapp.core)

(enable-console-print!)

(println "Hello world!")
----

In the browser environment we do not need a specific entry point for the application,
so the entry point is the entire namespace.


===== Compile the example application

In order to compile the source code to run properly in a browser, overwrite the
`mywebapp/build.clj` file with the following content:

[source, clojure]
----
(require '[cljs.build.api :as b])

(b/build "src" {:output-to "main.js"
                :source-map true
                :output-dir "out/"
                :main 'mywebapp.core
                :verbose true
                :optimizations :none})
----

This is a brief explanation of the compiler options we're using:

* The `:output-to` parameter indicates to the compiler the destination of the
  compiled code, in this case the "main.js" file.
* The `:main` property indicates to the compiler the namespace that will act as
  the  entry point of your application when it's executed.
* `:source-map` indicates the destination of the source map. (The source map
  connects the ClojureScript source to the generated JavaScript so that error
  messages can point you back to the original source.)
* `:output-dir` indicates the destination directory for all file sources used in a
  compilation. It is just for making source maps work properly with the rest of the
  code, not only your source.
* `:optimizations` indicates the compilation optimization. There are different
  values for this option, but that will be covered in subsequent sections in
  more detail.

To run the compilation, just execute the following command:

[source, bash]
----
cd mywebapp;
clojure build.clj
----

This process can take some time, so do not worry; wait a little bit. The JVM
bootstrap with the Clojure compiler is slightly slow. In the following sections, we
will explain how to start a watch process to avoid constantly starting and stopping
this slow process.

While waiting for the compilation, let's create a dummy HTML file to make it easy to
execute our example app in the browser. Create the _index.html_ file with the
following content; it goes in the main _mywebapp_ directory.

[source, html]
----
<!DOCTYPE html>
<html>
  <header>
    <meta charset="utf-8" />
    <title>Hello World from ClojureScript</title>
  </header>
  <body>
    <script src="main.js"></script>
  </body>
</html>
----

Now, when the compilation finishes and you have the basic HTML file you can just open
it with your favorite browser and take a look in the development tools console. The
"Hello world!" message should appear there.


==== Watch process

You may have already noticed the slow startup time of the _ClojureScript_
compiler. To solve this, the _ClojureScript_ standalone compiler comes with a
tool to watch for changes in your source code, and re-compile modified files as
soon as they are written to disk.

Let's start converting our build.clj script to something that can accept
arguments and execute different tasks. Let's create a `tools.clj` script file
with the following content:

[source, clojure]
----
(require '[cljs.build.api :as b])

(defmulti task first)

(defmethod task :default
  [args]
  (let [all-tasks  (-> task methods (dissoc :default) keys sort)
        interposed (->> all-tasks (interpose ", ") (apply str))]
    (println "Unknown or missing task. Choose one of:" interposed)
    (System/exit 1)))

(def build-opts
  {:output-to "main.js"
   :source-map true
   :output-dir "out/"
   :main 'mywebapp.core
   :verbose true
   :optimizations :none})

(defmethod task "build"
  [args]
  (b/build "src" build-opts))

(defmethod task "watch"
  [args]
  (b/watch"src" build-opts))

(task *command-line-args*)
----

Now you can start the watch process with the following command:

[source, bash]
----
clojure tools.clj watch
----

Go back to the `mywebapp.core` namespace, and change the print text to `"Hello World,
Again!"`.  You'll see that the file `src/mywebapp/core.cljs` the file is immediately
recompiled, and if you reload `index.html` in your browser the new text is displayed
in the developer console.

You also can start the simple build with:

[source, bash]
----
clojure tools.clj build
----

And finally, if you execute the `build.clj` script with no params, a help message
with available "tasks" will be printed:

[source, bash]
----
$ clojure tools.clj
Unknown or missing task. Choose one of: build, watch
----


==== Optimization levels

The _ClojureScript_ compiler has different levels of optimization. Behind the scenes,
those compilation levels are coming from the Google Closure Compiler.

A simplified overview of the compilation process is:

1. The reader reads the code and does some analysis. This compiler may raise some
   warnings during this phase.
2. Then, the _ClojureScript_ compiler emits JavaScript code. The result is one
   JavaScript output file for each ClojureScript input file.
3. The generated JavaScript files are passed through the Google Closure Compiler
   which, depending on the optimization level and other options (sourcemaps, output
   dir output to, ...), generates the final output file(s).

The final output format depends on the optimization level chosen:


===== none

This optimization level causes the generated JavaScript to be written into separate
output files for each namespace, without any additional transformations to the code.


===== whitespace

This optimization level causes the generated JavaScript files to be concatenated into
a single output file, in dependency order.  Line breaks and other whitespace are
removed.

This reduces compilation speed somewhat, resulting in a slower compilations. However,
it is not terribly slow and it is quite usable for small-to-medium sized
applications.

===== simple

The simple compilation level builds on the work from the `whitespace` optimization
level, and additionally performs optimizations within expressions and functions, such
as renaming local variables and function parameters to have shorter names.

Compilation with the `:simple` optimization always preserves the functionality of
syntactically valid JavaScript, so it does not interfere with the interaction between
the compiled _ClojureScript_ and other JavaScript.


===== advanced

The advanced compilation level builds on the `simple` optimization level, and
additionally performs more aggressive optimizations and dead code elimination. This
results in a significantly smaller output file.

The `:advanced` optimizations only work for a strict subset of JavaScript which
follows the Google Closure Compiler rules.  _ClojureScript_ generates valid
JavaScript within this strict subset, but if you are interacting with third party
JavaScript code, some additional work is required to make everything work as
expected.

This interaction with third party javascript libraries will be explained in later
sections.


=== Working with the REPL

////
TODO: maybe it would be interesting to take some ideas from
http://www.alexeberts.com/exploring-the-clojurescript-repl/
////


==== Introduction

Although you can create a source file and compile it every time you want to try
something out in ClojureScript, it's easier to use the REPL. REPL stands for:

* Read - get input from the keyboard
* Evaluate the input
* Print the result
* Loop back for more input

In other words, the REPL lets you try out ClojureScript concepts and get immediate
feedback.

_ClojureScript_ comes with support for executing the REPL in different execution
environments, each of which has its own advantages and disadvantages. For example,
you can run a REPL in nodejs but in that environment you don't have any access to the
DOM.  Which REPL environment is best for you depends on your specific needs and
requirements.


==== Nashorn REPL

The Nashorn REPL is the easiest and perhaps most painless REPL environment because it
does not require any special stuff.

Let’s start creating a new script file for our repl playground called
`tools.clj` in a new directory (in our case `repl_playground/tools.clj`):

[source, clojure]
----
(require '[cljs.repl :as repl])
(require '[cljs.repl.nashorn :as nashorn])

(defmulti task first)

(defmethod task :default
  [args]
  (let [all-tasks  (-> task methods (dissoc :default) keys sort)
        interposed (->> all-tasks (interpose ", ") (apply str))]
    (println "Unknown or missing task. Choose one of:" interposed)
    (System/exit 1)))

(defmethod task "repl:nashorn"
  [args]
  (repl/repl (nashorn/repl-env)
             :output-dir "out/nashorn"
             :cache-analysis true))

(task *command-line-args*)
----

Create the `repl_playground/deps.edn` file with the following content (identical
from previous examples):

[source, clojure]
----
{:deps {org.clojure/clojurescript {:mvn/version "1.10.520"}
        org.clojure/clojure {:mvn/version "1.10.1"}
        org.bodil/cljs-nashorn {:mvn/version "0.1.2"}}
 :paths ["src"]}
----

And now, we can execute the REPL:

[source, bash]
----
$ clj tools.clj repl:nashorn
ClojureScript 1.10.520
cljs.user=> (prn "Hello world")
"Hello world"
nil
----

You may have noticed that in this example we have used `clj` command instead of
`clojure`. That two commands are practically identical, the main difference is
that `clj` executes `clojure` command wrapped in `rlwrap`. The `rlwrap` tool
gives the "readline" capabilities which enables history, code navigation, and
other shell-like features that will make your REPL experience much more
pleasant.

If you don't have installed it previously, you can install it with `sudo apt
install -y rlwrap`.

NOTE: This is a basic repl, in the following chapters we will explain how to
have a more advanced repl experience with code-highlighting, code-completion and
multiline edition.


==== Node.js REPL

You must, of course, have nodejs installed on your system to use this REPL.

You may be wondering why we might want a nodejs REPL, when we already have the
nashorn REPL available which doesn't have any external dependencies. The answer is
very simple: nodejs is the most used JavaScript execution environment on the backend,
and it has a great number of community packages built around it.

The good news is that starting a nodejs REPL is very easy once you have it installed
in your system. Start adding the following content into `tools.clj` script:

[source, clojure]
----
(require '[cljs.repl.node :as node])

(defmethod task "repl:node"
  [args]
  (repl/repl (node/repl-env)
             :output-dir "out/nodejs"
             :cache-analysis true))
----

And start the REPL:

[source,bash]
----
$ clj tools.clj repl:node
ClojureScript 1.10.520
cljs.user=> (prn "Hello world")
"Hello world"
nil
----


==== Browser REPL

This REPL is the most laborious to get up and running. This is because it uses a
browser for its execution environment and it has additional requirements.

Let’s start by adding the following content to the `tools.clj` script file:

[source, clojure]
----
(require '[cljs.build.api :as b])
(require '[cljs.repl.browser :as browser])

(defmethod task "repl:browser"
  [args]
  (println "Building...")
  (b/build "src"
           {:output-to "out/browser/main.js"
            :output-dir "out/browser"
            :source-map true
            :main 'myapp.core
            :optimizations :none})

  (println "Launching REPL...")
  (repl/repl (browser/repl-env :port 9001)
             :output-dir "out/browser"))
----

The main difference with the previous examples, is that browser REPL requires
that some code be execution in the browser before the REPL gets working. To do
that, just re-create the application structure very similar to the one that we
have used in previous sections:

[source, bash]
----
mkdir -p src/myapp
touch src/myapp/core.cljs
----

Then, write new content to the `src/myapp/core.cljs` file:

[source, clojure]
----
(ns myapp.core
 (:require [clojure.browser.repl :as repl]))

(defonce conn
  (repl/connect "http://localhost:9001/repl"))

(enable-console-print!)

(println "Hello, world!")
----

And finally, create the missing _index.html_ file that is going to be used as
the entry point for running the browser side code of the REPL:

[source, html]
----
<!DOCTYPE html>
<html>
  <header>
    <meta charset="utf-8" />
    <title>Hello World from ClojureScript</title>
  </header>
  <body>
    <script src="out/browser/main.js"></script>
  </body>
</html>
----

Well, that was a lot of setup! But trust us, it’s all worth it when you see it in
action. To do that, just execute the `tools.clj` in the same way that we have done
it in previous examples:

[source, bash]
----
$ clj tools.clj repl:browser
Building...
Launching REPL...
ClojureScript 1.10.520
cljs.user=>
----

And finally, open your favourite browser and go to http://localhost:9001/. Once the
page is loaded (the page will be blank), switch back to the console where you have
run the REPL and you will see that it is up and running:

[source, bash]
----
[...]
To quit, type: :cljs/quit
cljs.user=> (+ 14 28)
42
----

One of the big advantages of the browser REPL is that you have access to everything
in the browser environment. For example, type `(js/alert "hello world")` in the
REPL. This will cause the browser to display an alert box. Nice!

NOTE: This is just a preview of how to use the builtin REPL capabilities of the
ClojureScript compiler. There are better and more user/developer friendly repl
environments with code-highlighting, code-completion and multiline edition (and
in case of web development, also with code hot reloading) that will be explained
in the following chapters.


==== Rebel Readline (REPL library)

This is a library that adds more advanced features to the Clojure(Script)
builtin REPL and enables code-highlighting, code-completion and multiline
edition.

Let's start adding rebel dependency into `deps.edn` file:

[source, clojure]
----
{:deps {org.clojure/clojurescript {:mvn/version "1.10.520"}
        org.clojure/clojure {:mvn/version "1.10.1"}
        com.bhauman/rebel-readline-cljs {:mvn/version "0.1.4"}
        com.bhauman/rebel-readline {:mvn/version "0.1.4"}}
 :paths ["src"]}
----

And adding the followin code to the `tools.clj` script file:

[source, clojure]
----
(require '[rebel-readline.core]
         '[rebel-readline.clojure.main]
         '[rebel-readline.clojure.line-reader]
         '[rebel-readline.cljs.service.local]
         '[rebel-readline.cljs.repl])

(defmethod task "repl:rebel:node"
  [args]
  (rebel-readline.core/with-line-reader
    (rebel-readline.clojure.line-reader/create
     (rebel-readline.cljs.service.local/create))
    (repl/repl (node/repl-env)
               :prompt (fn [])
               :read (rebel-readline.cljs.repl/create-repl-read)
               :output-dir "out/nodejs"
               :cache-analysis true)))
----

And start the REPL:

[source, bash]
----
$ clojure tools.clj repl:rebel:node
ClojureScript 1.10.520
cljs.user=> (println
cljs.core/println: ([& objs])
----

You can find that while you writing in the repl, it automatically suggest and
shows se function signature that you want to execute.

You can find more information about all rebel-readline capabilities on
https://github.com/bhauman/rebel-readline



=== The Closure Library

The Google Closure Library is a javascript library developed by Google. It has a
modular architecture, and provides cross-browser functions for DOM manipulations and
events, ajax and JSON, and other features.

The Google Closure Library is written specifically to take advantage of the Closure
Compiler (which is used internally by the _ClojureScript_ compiler).

_ClojureScript_ is built on the Google Closure Compiler and Closure Library. In fact,
_ClojureScript_ namespaces are Closure modules. This means that you can interact with
the Closure Library very easily:

[source, clojure]
----
(ns yourapp.core
  (:require [goog.dom :as dom]))

(def element (dom/getElement "body"))
----

This code snippet shows how you can import the *dom* module of the Closure library
and use a function declared in that module.

Additionally, the closure library exposes "special" modules that behave like a class
or object. To use these features, you must use the `:import` directive in the `(ns
...)` form:

[source, clojure]
----
(ns yourapp.core
  (:import goog.History))

(def instance (History.))
----

In a _Clojure_ program, the `:import` directive is used for host (Java) interop to
import Java classes.  If, however, you define types (classes) in _ClojureScript_, you
should use the standard `:require` directive and not the `:import` directive.

You can found the reference to all namespaces in the closure library here:
http://google.github.io/closure-library/api/


=== Dependency management

Until now, we have used the builtin _Clojure(Script)_ toolchain to compile our
source files to JavaScript. Now this is a time to understand how manage external
and/or third party dependencies.


==== First project

The best way to show how a tool works is by creating a toy project with it. In
this case, we will create a small application that determines if a year is a
leap year or not.

Let's start creating the project layout:

[source, bash]
----
mkdir -p leapyears/src/leapyears
mkdir -p leapyears/target/public
touch leapyears/target/public/index.html
touch leapyears/src/leapyears/core.cljs
touch leapyears/tools.cljs
touch leapyears/deps.edn
----

The project has the following structure:

----
leapyears
├── deps.edn
├── src
│   └── leapyears
│       └── core.cljs
├── target
│   └── public
│       └── index.html
└── tools.clj
----

The `deps.edn` file contains information about all the *packaged* dependencies
needed to build or execute the application. Packaged dependencies are libraries
packaged as jar files and uploaded to clojars/maven repository.

[NOTE]
====
But ClojureScript can consume external code in many different ways:

- google closure library module
- global export module
- es6/commonjs module (experimental)

This will be explained in the following sections.
====

Let's start with a simple `deps.edn` file:

[source, clojure]
----
{:deps {org.clojure/clojurescript {:mvn/version "1.10.520"}
        org.clojure/clojure {:mvn/version "1.10.1"}
        com.bhauman/rebel-readline-cljs {:mvn/version "0.1.4"}
        com.bhauman/rebel-readline {:mvn/version "0.1.4"}}
 :paths ["src" "target"]}
----

And simple build script (`tools.clj` file):

[source, clojure]
----
(require '[cljs.build.api :as b])
(require '[cljs.repl :as repl])
(require '[cljs.repl.node :as node])

(defmulti task first)

(defmethod task :default
  [args]
  (let [all-tasks  (-> task methods (dissoc :default) keys sort)
        interposed (->> all-tasks (interpose ", ") (apply str))]
    (println "Unknown or missing task. Choose one of:" interposed)
    (System/exit 1)))

(def build-opts
  {:output-to "target/public/js/leapyears.js"
   :source-map true
   :output-dir "target/public/js/leapyears"
   :main 'leapyears.core
   :verbose true
   :optimizations :none})

(defmethod task "repl"
  [args]
  (repl/repl (node/repl-env)
             :output-dir "target/nodejs"
             :cache-analysis true))

(defmethod task "build"
  [args]
  (b/build "src" build-opts))

(defmethod task "watch"
  [args]
  (b/watch "src" build-opts))

(task *command-line-args*)
----

Then, write the following content into `target/public/index.html` file:

[source, html]
----
<!DOCTYPE html>
<html>
  <head>
    <title>leapyears</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  </head>
  <body>
    <section class="viewport">
      <div id="result">
        ----
      </div>

      <form action="" method="">
        <label for="year">Input a year</label>
        <input id="year" name="year" />
      </form>
    </section>

    <script src="./js/leapyears.js" type="text/javascript"></script>
  </body>
</html>
----

The next step consist in add some code to make the form interactive. Put the
following code into the `src/leapyears/core.cljs`:

[source, clojure]
----
(ns leapyears.core
  (:require [goog.dom :as dom]
            [goog.events :as events]
            [cljs.reader :refer (read-string)]))

(enable-console-print!)

(def input (dom/getElement "year"))
(def result (dom/getElement "result"))

(defn leap?
  [year]
  (or (zero? (js-mod year 400))
      (and (pos? (js-mod year 100))
           (zero? (js-mod year 4)))))

(defn on-change
  [event]
  (let [target (.-target event)
        value (read-string (.-value target))]
    (if (leap? value)
      (set! (.-innerHTML result) "YES")
      (set! (.-innerHTML result) "NO"))))

(events/listen input "keyup" on-change)
----

Now, we can compile the project with:

[source, bash]
----
clojure tools.clj watch
----

Finally, open the `target/public/index.html` file in a browser. Typing a year in the textbox
should display an indication of its leap year status.


==== Adding native dependencies

Until now we have used only the batteries included in the ClojureScript runtime,
let improve our project including a native dependency. In this example we will
use the link:https://github.com/funcool/cuerdas[Cuerdas] (a string manipulation
library build especifically for Clojure(Script)).

Add `funcool/cuerdas {:mvn/version "2.2.0"}` into the `:deps` section inside the
`deps.edn` file. And add the corresponding modifications to the
`leapyears/core.cljs` file:

[source, clojure]
----
(ns leapyears.core
  (:require [goog.dom :as dom]
            [goog.events :as events]
            [cuerdas.core :as str]
            [cljs.reader :refer (read-string)]))

;; [...]

(defn on-change
  [event]
  (let [target (.-target event)
        value (read-string (.-value target))]

    (if (str/blank? value)
      (set! (.-innerHTML result) "---")
      (if (leap? value)
        (set! (.-innerHTML result) "YES")
        (set! (.-innerHTML result) "NO")))))
----

Now, if you run the build or watch command, the new declared dependency will be
downloaded and the application will be compiled with this dependency included.

Clojure packages are often published on link:http://clojars.org[Clojars]. You can
also find many third party libraries on the
link:https://github.com/clojure/clojurescript/wiki#libraries[ClojureScript Wiki].


==== External dependencies

In some circumstances you may found yourself that you need some library but that
does not exists in _ClojureScript_ but it is already implemented in javascript
and you want to use it on your project.

There are many ways that you can do it mainly depending on the library that you
want to include. Many of that libraries are packaged and uploaded to clojars, so
you can declare them in the `deps.edn` in the same way as native dependencies
(with some peculirities in usage, see below).


==== Closure compatible module

If you have a library that is written to be compatible with google closure
module system and you want to include it on your project: put the source into
the classpath (inside `src` or `vendor` directory in leapyears project) and
access it like any other clojure namespace.

This is the most simplest case, because google closure modules are directly
compatible and you can mix your clojure code with javascript code written using
google closure module system without any additional steps.

Reusing the leapyears project, lets implement the `leap?` function in
a javascript using google closure module format. Start creating the
directory structure:

[source, bash]
----
touch src/leapyears/util.js
----

And add the implementation using closure module format:

.src/leapyears/util.js
[source, js]
----
goog.provide("leapyears.util");

goog.scope(function() {
  var module = leapyears.util;

  module.isLeap = function(val) {
    return (0 === (val % 400)) || (((val % 100) > 0) && (0 === (val % 4)));
  };
});
----

Now, if you open the repl, you can import the namespace and use the `isLeap`
function

[source, clojure]
----
(require '[leapyears.util :as util])

(util/isLeap 2112)
;; => true

(util/isLeap 211)
;; => false
----

NOTE: you can open the nodejs repl just executing `clj tools.clj repl` in the
root of the project.

NOTE: this is the approach used by many projects to implement some performance
sensitive logic directly in javascript and export it in an easy way to
ClojureScript


==== Global Export

This is the most extended and the most reliable way to consume external
javascript libraries from ClojureScript and it has many facilities.

Let's play with that. Start creating a simple file using commonjs module format
(pretty analogous to the previous example using google closure modules):

The fastest way to include a javascript library is looking if it is available in
link:http://cljsjs.github.io/[CLJSJS]. If it is available, just include the
dependency in the `deps.edn` file and use it.

That libraries has two ways of use it, let's see some examples.

Start adding `moment` dependency to `deps.edn` file:

[source, clojure]
----
cljsjs/moment {:mvn/version "2.24.0-0"}
----

Then, open the repl and try the following:

.using the `js/` special namespace
[source, clojure]
----
(require '[cljsjs.moment]) ;; just require, no alias

(.format (js/moment) "LLLL")
;; => "Monday, July 15, 2019 5:32 PM"
----

.using the alias
[source, clojure]
----
(require '[moment :as m])

(.format (m) "LLLL")
;; => "Monday, July 15, 2019 5:33 PM"
----

Behind the scenes that packages uses the ClojureScript compiler facilities
link:https://clojurescript.org/reference/compiler-options#foreign-libs[descibed
here] for provide the compiler with enough information about the files and
global exports to use.

So, if don't find a library in cljsjs, we can include it using the same
facilities. Let's assume that moment is not available on cljsjs and we need it
on our project.

For include an foreign dependency we need to pass `:foreign-libs` and `:externs`
params to the ClojureScript compiler, and we have two ways:

- passing them to the `build` or `repl` functions.
- inside the `deps.cljs` file located on the root of the classpath.

The `deps.cljs` approach requires that files should be localted on the local
directories, but the first approach allows specify directly external urls. We
will use the first approach on our example.

This is how looks the `deps.edn` file with the changes applied:

[source, clojure]
----
;; [...]

(def foreign-libs
  [{:file "https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.js"
    :file-min "https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js"
    :provides ["vendor.moment"]}])


(def build-opts
  {:output-to "target/public/js/leapyears.js"
   :source-map true
   :output-dir "target/public/js/leapyears"
   :main 'leapyears.core
   :verbose true
   :optimizations :none
   :foreign-libs foreign-libs})

(defmethod task "repl"
  [args]
  (repl/repl (node/repl-env)
             :foreign-libs foreign-libs
             :output-dir "target/node"
             :cache-analysis true))

;; [...]
----

Now, if you excute the repl, you will be able to import `vendor.moment` in the same way
if you are using the cljsjs package.

Finally, there are the `:externs` option, that will be needed only for the
production build, and the externs file consists in plain javascript files that
declares the public API of the included foreign libraries and make them
understandable to the google closure compiler.

The moment externs are available
link:https://github.com/cljsjs/packages/blob/master/moment/resources/cljsjs/common/moment.ext.js[here]
and if you include some library that you want to use, and then want to compile
your app with advanced optimizations you will need to include a file similar to
the moment.ext.js on the project and referenciate it with `:externs` option to
the ClojureScript compiler.

More info link:https://clojurescript.org/reference/compiler-options#externs[on clojurescript.org].


==== ES6/CommonJS modules

Google Closure Compiler has an advanced feature that allows convert from
different module types (commonjs and ES) into google closure module
type. Although this feature is still experimental. With simple modules it works,
but with more complex modules (many submodules and directories) still doest
not complies correctly.

In any way I invite you to experiment with it. You can found more documentation
on
link:https://clojurescript.org/reference/javascript-module-support[clojurescript.org].

The best way to use ES6 and/or CommonJS module is combining a javascript bundler
like _rollup_ or _webpack_ to generate a single build with external dependencies
and thn use the *global exports* method to use it in ClojureScript. An example
of this is explained link:https://clojurescript.org/guides/webpack[on clojurescript.org].


=== Interactive development with Figwheel

And finally we will introduce *figwheel*, that enables fully interactive,
REPL-based and hot reloading enabled development environment.

We will reuse the leapyears project structure for the following examples.

NOTE: Although we use figwheel here for web application, it works in the same
way on the application that targets nodejs as execution environment.

As first step, we need to add *figwheel* dependency to the `deps.edn` file:

[source, clojure]
----
com.bhauman/figwheel-main {:mvn/version "0.2.1"}
----

Then, add new task to the `tools.clj` script:

[source, clojure]
----
(def figwheel-opts
  {:open-url false
   :load-warninged-code true
   :auto-testing false
   :ring-server-options {:port 3448 :host "0.0.0.0"}
   :watch-dirs ["src"]})

(defmethod task "figwheel"
  [args]
  (figwheel/start figwheel-opts {:id "main" :options build-opts}))
----


And then, run `clojure tools.clj fighweel`. This will start the figwheel process
that automatically will launch a http server that will serve the
`target/public/` directory and index to `index.html` file.

If you update the code, that code will be automatically loaded to the browser,
*without page reload*.

For more info: link:https://figwheel.org/[figwheel.org].


=== Unit testing

As you might expect, testing in _ClojureScript_ consists of the same concepts widely
used by other language such as Clojure, Java, Python, JavaScript, etc.

Regardless of the language, the main objective of unit testing is to run some test
cases, verifying that the code under test behaves as expected and returns without
raising unexpected exceptions.

The immutablity of _ClojureScript_ data structures helps to make programs less error
prone, and facilitates testing a little bit. Another advantage of _ClojureScript_ is
that it tends to use plain data instead of complex objects. Building "mock" objects
for testing is thus greatly simplified.


==== First steps

The "official" _ClojureScript_ testing framework is in the "cljs.test" namespace. It
is a very simple library, but it should be more than enough for our purposes.

There are other libraries that offer additional features or directly different
approaches to testing, such as
link:https://github.com/clojure/test.check[test.check]. However, we will not cover
them here.

We will reuse the `leapyears` project structure and we will add testing to it. Let's create
the test related files and directories:

[source, bash]
----
mkdir -p test/leapyears/test
touch test/leapyears/test/main.cljs
----

Also we will need to create new tasks on our `tools.clj` file for build, watch and run
tests:

[source, clojure]
----
(require '[clojure.java.shell :as shell])

;; [...]

(defmethod task "build:tests"
  [args]
  (b/build (b/inputs "src" "vendor" "test")
           (assoc build-opts
                  :main 'leapyears.test.main
                  :output-to "out/tests.js"
                  :output-dir "out/tests"
                  :target :nodejs)))

(defmethod task "watch:test"
  [args]
  (letfn [(run-tests []
            (let [{:keys [out err]} (shell/sh "node" "out/tests.js")]
              (println out err)))]
    (println "Start watch loop...")
    (try
      (b/watch (b/inputs "src", "test")
               (assoc build-opts
                      :main 'leapyears.test.main
                      :watch-fn run-tests
                      :output-to "out/tests.js"
                      :output-dir "out/tests"
                      :target :nodejs))

      (catch Exception e
        (println "Error on running tests:" e)
        ;; (Thread/sleep 2000)
        (task args)))))
----

Next, put some test code in the `test/leapyears/test/main.cljs` file:

[source, clojure]
----
(ns leapyears.test.main
  (:require [cljs.test :as t]))

(enable-console-print!)

(t/deftest my-first-test
  (t/is (= 1 2)))

(set! *main-cli-fn* #(t/run-tests))

;; This extension is required for correctly set the return code
;; depending if the test passes or not.
(defmethod t/report [:cljs.test/default :end-run-tests]
  [m]
  (if (t/successful? m)
    (set! (.-exitCode js/process) 0)
    (set! (.-exitCode js/process) 1)))
----

The relevant part of that code snippet is:

[source, clojure]
----
(t/deftest my-first-test
  (t/is (= 1 2)))
----

The `deftest` macro is a basic primitive for defining our tests. It takes a name as
its first parameter, followed by one or multiple assertions using the `is` macro. In
this example, we try to assert that `(= 1 2)` is true.

Let's try to run this:

[source,bash]
----
$ clojure tools build:tests
$ node out/tests.js
Testing mytestingapp.core-tests

FAIL in (my-first-test) (cljs/test.js:374:14)
expected: (= 1 2)
  actual: (not (= 1 2))

Ran 1 tests containing 1 assertions.
1 failures, 0 errors.
----

You can see that the expected assert failure is successfully printed in the
console. To fix the test, just change the `=` with `not=` and run the file again:

[source, bash]
----
$ clojure tools build:tests
$ node out/mytestingapp.js

Testing mytestingapp.core-tests

Ran 1 tests containing 1 assertions.
0 failures, 0 errors.
----

It is fine to test these kinds of assertions, but they are not very
useful. Let's go to test some application code. For this, we will use a function
to check if a year is a leap year or not:

[source, clojure]
----
(ns leapyears.test.main
  (:require [cljs.test :as t]
            [leapyears.vendor.util-closure :as util]))

;; [...]

(t/deftest my-second-test
  (t/is (util/isLeap 1980))
  (t/is (not (util/isLeap 1981))))

;; [...]
----

Run the compiled file again to see that there are now two tests running.  The
first test passes as before, and our two new leap year tests pass as well.


==== Async Testing

One of the peculiarities of _ClojureScript_ is that it runs in an asynchronous,
single-threaded execution environment, which has its challenges.

In an async execution environment, we should be able to test asynchronous functions.
To this end, the _ClojureScript_ testing library offers the `async` macro, allowing
you to create tests that play well with asynchronous code.

First, we need to write a function that works in an asynchronous way. For this
purpose, we will create the `async-leap?` predicate that will do the same operation
but asychronously return a result using a callback:

[source, clojure]
----
(defn async-leap?
  [year callback]
  (js/setImmediate #(callback (util/isLeap year))))
----

The JavaScript function `setImmediate` is used to emulate an asynchronous task, and
the callback is executed with the result of that predicate.

To test it, we should write a test case using the previously mentioned `async` macro:

[source, clojure]
----
(t/deftest my-async-test
  (t/async done
    (async-leap? 1980 (fn [result]
                        (t/is (true? result))
                              (done)))))
----

The `done` function exposed by the `async` macro should be called after the
asynchronous operation is finished and all assertions have run.

It is very important to execute the `done` function only once. Omitting it or
executing it twice may cause strange behavior and should be avoided.
