<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta charset="UTF-8"/>
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"/><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="generator" content="Asciidoctor 1.5.3"/>
<meta name="author" content="Andrey Antukh, Alejandro Gómez"/>
<title>ClojureScript Unraveled</title>
<style>
/*! normalize.css v2.1.2 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video { display: inline-block; }

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) { display: none; height: 0; }

/** Address `[hidden]` styling not present in IE 8/9. Hide the `template` element in IE, Safari, and Firefox < 22. */
[hidden], template { display: none; }

script { display: none !important; }

/* ========================================================================== Base ========================================================================== */
/** 1. Set default font family to sans-serif. 2. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html { font-family: sans-serif; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ }

/** Remove default margin. */
body { margin: 0; }

/* ========================================================================== Links ========================================================================== */
/** Remove the gray background color from active links in IE 10. */
a { background: transparent; }

/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus { outline: thin dotted; }

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover { outline: 0; }

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 { font-size: 2em; margin: 0.67em 0; }

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] { border-bottom: 1px dotted; }

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong { font-weight: bold; }

/** Address styling not present in Safari 5 and Chrome. */
dfn { font-style: italic; }

/** Address differences between Firefox and other browsers. */
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }

/** Address styling not present in IE 8/9. */
mark { background: #ff0; color: #000; }

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }

/** Improve readability of pre-formatted text in all browsers. */
pre { white-space: pre-wrap; }

/** Set consistent quote types. */
q { quotes: "\201C" "\201D" "\2018" "\2019"; }

/** Address inconsistent and variable font size in all browsers. */
small { font-size: 80%; }

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }

sup { top: -0.5em; }

sub { bottom: -0.25em; }

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img { border: 0; }

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) { overflow: hidden; }

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure { margin: 0; }

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend { border: 0; /* 1 */ padding: 0; /* 2 */ }

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 2 */ margin: 0; /* 3 */ }

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input { line-height: normal; }

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select { text-transform: none; }

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; /* 2 */ cursor: pointer; /* 3 */ }

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] { cursor: default; }

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ }

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] { -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box; }

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea { overflow: auto; /* 1 */ vertical-align: top; /* 2 */ }

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table { border-collapse: collapse; border-spacing: 0; }

meta.foundation-mq-small { font-family: "only screen and (min-width: 768px)"; width: 768px; }

meta.foundation-mq-medium { font-family: "only screen and (min-width:1280px)"; width: 1280px; }

meta.foundation-mq-large { font-family: "only screen and (min-width:1440px)"; width: 1440px; }

*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }

html, body { font-size: 100%; }

body { background: white;
       color: rgba(0, 0, 0, 0.8);
       padding: 0;
       margin: 0;
       font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica,Arial,sans-serif;
       font-weight: normal;
       font-style: normal;
       line-height: 1;
       position: relative;
       cursor: auto; }

a:hover { cursor: pointer; }

img, object, embed { max-width: 100%; height: auto; }

object, embed { height: 100%; }

img { -ms-interpolation-mode: bicubic; }

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }

.left { float: left !important; }

.right { float: right !important; }

.text-left { text-align: left !important; }

.text-right { text-align: right !important; }

.text-center { text-align: center !important; }

.text-justify { text-align: justify !important; }

.hide { display: none; }

.antialiased, body { -webkit-font-smoothing: antialiased; }

img { display: inline-block; vertical-align: middle; }

textarea { height: auto; min-height: 50px; }

select { width: 100%; }

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }

.subheader, .admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { line-height: 1.45; color: #7a2518; font-weight: normal; margin-top: 0; margin-bottom: 0.25em; }

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }

/* Default Link Styles */
a { color: #2156a5; text-decoration: none; line-height: inherit; }
a:hover, a:focus { color: #1d4b8f; }
a img { border: none; }

/* Default paragraph styles */
p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 {
    font-weight: 300;
    font-style: normal;

    font-family: "Roboto Slab", "ff-tisa-web-pro","Georgia",Arial,sans-serif;
    color: #3E4349;

    text-rendering: optimizeLegibility;
    margin-top: 1em;
    margin-bottom: 0.5em;
    line-height: 1.0125em;
}
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small {
    font-size: 60%;
    color: #527bbd;
    line-height: 0;
}

h1 { font-size: 2.125em; }

h2 { font-size: 1.6875em; }

h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }

h4 { font-size: 1.125em; }

h5 { font-size: 1.125em; }

h6 { font-size: 1em; }

hr { border: solid #ddddd8; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }

/* Helpful Typography Defaults */
em, i { font-style: italic; line-height: inherit; }

strong, b { font-weight: bold; line-height: inherit; }

small { font-size: 60%; line-height: inherit; }

code {
    font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace;
    font-family: "Liberation Mono",Menlo,Courier,monospace;
    font-weight: normal; color: rgba(0, 0, 0, 0.9);
}

/* Lists */
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }

ul, ol { margin-left: 1.5em; }
ul.no-bullet, ol.no-bullet { margin-left: 1.5em; }

/* Unordered Lists */
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; /* Override nested font-size change */ }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }

/* Ordered Lists */
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }

/* Definition Lists */
dl dt { margin-bottom: 0.3125em; font-weight: bold; }
dl dd { margin-bottom: 1.25em; }

/* Abbreviations */
abbr, acronym { text-transform: uppercase; font-size: 90%; color: rgba(0, 0, 0, 0.8); border-bottom: 1px dotted #dddddd; cursor: help; }

abbr { text-transform: none; }

/* Blockquotes */
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: 0.9375em; color: rgba(0, 0, 0, 0.6); }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: rgba(0, 0, 0, 0.6); }

blockquote, blockquote p { line-height: 1.6; color: rgba(0, 0, 0, 0.85); }

/* Microformats */
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }

.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }

@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.2; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
/* Tables */
table { background: white; margin-bottom: 1.25em; border: solid 1px #dedede; }
table thead, table tfoot { background: #f7f8f7; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: rgba(0, 0, 0, 0.8); text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: rgba(0, 0, 0, 0.8); }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f8f8f7; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.6; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.2; word-spacing: -0.05em; }
h1 strong, h2 strong, h3 strong, #toctitle strong, .sidebarblock > .content > .title strong, h4 strong, h5 strong, h6 strong { font-weight: 400; }

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }

*:not(pre) > code { font-size: 0.9375em; font-style: normal !important; letter-spacing: 0; padding: 0.1em 0.5ex; word-spacing: -0.15em; background-color: #f7f7f8; -webkit-border-radius: 4px; border-radius: 4px; line-height: 1.45; text-rendering: optimizeSpeed; }

pre, pre > code {
    line-height: 1.45;
    color: rgba(0, 0, 0, 0.9);
    font-family: "Droid Sans Mono", "DejaVu Sans Mono", "Monospace", monospace;
    font-family: "Liberation Mono",Menlo,Courier,monospace;
    font-weight: normal;
    text-rendering: optimizeSpeed; }

.keyseq { color: rgba(51, 51, 51, 0.8); }

kbd { display: inline-block; color: rgba(0, 0, 0, 0.8); font-size: 0.75em; line-height: 1.4; background-color: #f7f7f7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; margin: -0.15em 0.15em 0 0.15em; padding: 0.2em 0.6em 0.2em 0.5em; vertical-align: middle; white-space: nowrap; }

.keyseq kbd:first-child { margin-left: 0; }

.keyseq kbd:last-child { margin-right: 0; }

.menuseq, .menu { color: rgba(0, 0, 0, 0.8); }

b.button:before, b.button:after { position: relative; top: -1px; font-weight: normal; }

b.button:before { content: "["; padding: 0 3px 0 2px; }

b.button:after { content: "]"; padding: 0 2px 0 3px; }

p a > code:hover { color: rgba(0, 0, 0, 0.9); }

#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }

#content { margin-top: 1.25em; }

#content:before { content: none; }

#header > h1:first-child { color: rgba(0, 0, 0, 0.85); margin-top: 2.25rem; margin-bottom: 0; }
#header > h1:first-child + #toc { margin-top: 8px; border-top: 1px solid #ddddd8; }
#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) { border-bottom: 1px solid #ddddd8; padding-bottom: 8px; }
#header .details { border-bottom: 1px solid #ddddd8; line-height: 1.45; padding-top: 0.25em; padding-bottom: 0.25em; padding-left: 0.25em; color: rgba(0, 0, 0, 0.6); display: -ms-flexbox; display: -webkit-flex; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; }
#header .details span:first-child { margin-left: -0.125em; }
#header .details span.email a { color: rgba(0, 0, 0, 0.85); }
#header .details br { display: none; }
#header .details br + span:before { content: "\00a0\2013\00a0"; }
#header .details br + span.author:before { content: "\00a0\22c5\00a0"; color: rgba(0, 0, 0, 0.85); }
#header .details br + span#revremark:before { content: "\00a0|\00a0"; }
#header #revnumber { text-transform: capitalize; }
#header #revnumber:after { content: "\00a0"; }

#content > h1:first-child:not([class]) { color: rgba(0, 0, 0, 0.85); border-bottom: 1px solid #ddddd8; padding-bottom: 8px; margin-top: 0; padding-top: 1rem; margin-bottom: 1.25rem; }

#toc { border-bottom: 1px solid #efefed; padding-bottom: 0.5em; }
#toc > ul { margin-left: 0.125em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin: 0.5em 0; }
#toc ul { font-family: "Open Sans", "DejaVu Sans", sans-serif; list-style-type: none; }
#toc a { text-decoration: none;
         color: #3E4349;
       }
#toc a:active { text-decoration: underline; }

#toctitle { font-size: 1.2em; font-weight: 700; }

@media only screen and (min-width: 768px) { #toctitle { font-size: 1.375em; }
  body.toc2 { padding-left: 15em; padding-right: 0; }
  #toc.toc2 { margin-top: 0 !important; background-color: #f8f8f7; position: fixed; width: 15em; left: 0; top: 0; border-right: 1px solid #efefed; border-top-width: 0 !important; border-bottom-width: 0 !important; z-index: 1000; padding: 1.25em 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; font-size: 1.2em; }
  #toc.toc2 > ul { font-size: 0.9em; margin-bottom: 0; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 15em; }
  body.toc2.toc-right #toc.toc2 { border-right-width: 0; border-left: 1px solid #efefed; left: auto; right: 0; } }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 25em; padding-right: 0; }
  #toc.toc2 { width: 25em; font-size: 16px; }
  #toc.toc2 #toctitle { font-size: 1.375em; }
  #toc.toc2 > ul { font-size: 0.95em; }
  #toc.toc2 ul ul { padding-left: 1.25em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #e0e0dc; margin-bottom: 1.25em; padding: 1.25em; background: #f8f8f7; -webkit-border-radius: 4px; border-radius: 4px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }

#footer { max-width: 100%; background-color: rgba(0, 0, 0, 0.8); padding: 1.25em; }

#footer-text { color: rgba(255, 255, 255, 0.8); line-height: 1.44; }

.sect1 { padding-bottom: 0.625em; }

@media only screen and (min-width: 768px) { .sect1 { padding-bottom: 1.25em; } }
.sect1 + .sect1 { border-top: 1px solid #efefed; }

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; z-index: 1001; width: 1.5ex; margin-left: -1.5ex; display: block; text-decoration: none !important; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: "\00A7"; font-size: 0.85em; display: block; padding-top: 0.1em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }

#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link {
    text-decoration: none;
    color: #3E4349;
    font-weight: 700;
}

#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #3E4349; }

.audioblock, .imageblock, .literalblock, .listingblock, .stemblock, .videoblock { margin-bottom: 1.25em; }

.admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-rendering: optimizeLegibility; text-align: left; font-family: "Noto Serif", "DejaVu Serif", serif; font-size: 1rem; font-style: italic; }

table.tableblock > caption.title { white-space: nowrap; overflow: visible; max-width: 0; }

.paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { color: rgba(0, 0, 0, 0.85); }

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }

.admonitionblock > table { border-collapse: separate; border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; font-family: "Open Sans", "DejaVu Sans", sans-serif; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #ddddd8; color: rgba(0, 0, 0, 0.6); }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }

.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 4px; border-radius: 4px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }

.sidebarblock { border-style: solid; border-width: 1px; border-color: #e0e0dc; margin-bottom: 1.25em; padding: 1.25em; background: #f8f8f7; -webkit-border-radius: 4px; border-radius: 4px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock > .content > .title { color: #7a2518; margin-top: 0; text-align: center; }

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }

.literalblock pre, .listingblock pre:not(.highlight), .listingblock pre[class="highlight"], .listingblock pre[class^="highlight "], .listingblock pre.CodeRay, .listingblock pre.prettyprint { background: #f7f7f8; }
.sidebarblock .literalblock pre, .sidebarblock .listingblock pre:not(.highlight), .sidebarblock .listingblock pre[class="highlight"], .sidebarblock .listingblock pre[class^="highlight "], .sidebarblock .listingblock pre.CodeRay, .sidebarblock .listingblock pre.prettyprint { background: #f2f1f1; }

.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { -webkit-border-radius: 4px; border-radius: 4px; word-wrap: break-word; padding: 1em; font-size: 0.8125em; }
.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
@media only screen and (min-width: 768px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.90625em; } }
@media only screen and (min-width: 1280px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 1em; } }

.literalblock.output pre { color: #f7f7f8; background-color: rgba(0, 0, 0, 0.9); }

.listingblock pre.highlightjs { padding: 0; }
.listingblock pre.highlightjs > code { padding: 1em; -webkit-border-radius: 4px; border-radius: 4px; }

.listingblock pre.prettyprint { border-width: 0; }

.listingblock > .content { position: relative; }

.listingblock code[data-lang]:before { display: none; content: attr(data-lang); position: absolute; font-size: 0.75em; top: 0.425rem; right: 0.5rem; line-height: 1; text-transform: uppercase; color: #999; }

.listingblock:hover code[data-lang]:before { display: block; }

.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }

.listingblock.terminal pre .command:not([data-prompt]):before { content: "$"; }

table.pyhltable { border-collapse: separate; border: 0; margin-bottom: 0; background: none; }

table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; }

table.pyhltable td.code { padding-left: .75em; padding-right: 0; }

pre.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #ddddd8; }

pre.pygments .lineno { display: inline-block; margin-right: .25em; }

table.pyhltable .linenodiv { background: none !important; padding-right: 0 !important; }

.quoteblock { margin: 0 1em 1.25em 1.5em; display: table; }
.quoteblock > .title { margin-left: -1.5em; margin-bottom: 0.75em; }
.quoteblock blockquote, .quoteblock blockquote p { color: rgba(0, 0, 0, 0.85); font-size: 1.15rem; line-height: 1.75; word-spacing: 0.1em; letter-spacing: 0; font-style: italic; text-align: justify; }
.quoteblock blockquote { margin: 0; padding: 0; border: 0; }
.quoteblock blockquote:before { content: "\201c"; float: left; font-size: 2.75em; font-weight: bold; line-height: 0.6em; margin-left: -0.6em; color: #7a2518; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: 0.5em; margin-right: 0.5ex; text-align: right; }
.quoteblock .quoteblock { margin-left: 0; margin-right: 0; padding: 0.5em 0; border-left: 3px solid rgba(0, 0, 0, 0.6); }
.quoteblock .quoteblock blockquote { padding: 0 0 0 0.75em; }
.quoteblock .quoteblock blockquote:before { display: none; }

.verseblock { margin: 0 1em 1.25em 1em; }
.verseblock pre { font-family: "Open Sans", "DejaVu Sans", sans; font-size: 1.15rem; color: rgba(0, 0, 0, 0.85); font-weight: 300; text-rendering: optimizeLegibility; }
.verseblock pre strong { font-weight: 400; }
.verseblock .attribution { margin-top: 1.25rem; margin-left: 0.5ex; }

.quoteblock .attribution, .verseblock .attribution { font-size: 0.9375em; line-height: 1.45; font-style: italic; }
.quoteblock .attribution br, .verseblock .attribution br { display: none; }
.quoteblock .attribution cite, .verseblock .attribution cite { display: block; letter-spacing: -0.05em; color: rgba(0, 0, 0, 0.6); }

.quoteblock.abstract { margin: 0 0 1.25em 0; display: block; }
.quoteblock.abstract blockquote, .quoteblock.abstract blockquote p { text-align: left; word-spacing: 0; }
.quoteblock.abstract blockquote:before, .quoteblock.abstract blockquote p:first-of-type:before { display: none; }

table.tableblock { max-width: 100%; border-collapse: separate; }
table.tableblock td > .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child { margin-bottom: 0; }

table.spread { width: 100%; }

table.tableblock, th.tableblock, td.tableblock { border: 0 solid #dedede; }

table.grid-all th.tableblock, table.grid-all td.tableblock { border-width: 0 1px 1px 0; }

table.grid-all tfoot > tr > th.tableblock, table.grid-all tfoot > tr > td.tableblock { border-width: 1px 1px 0 0; }

table.grid-cols th.tableblock, table.grid-cols td.tableblock { border-width: 0 1px 0 0; }

table.grid-all * > tr > .tableblock:last-child, table.grid-cols * > tr > .tableblock:last-child { border-right-width: 0; }

table.grid-rows th.tableblock, table.grid-rows td.tableblock { border-width: 0 0 1px 0; }

table.grid-all tbody > tr:last-child > th.tableblock, table.grid-all tbody > tr:last-child > td.tableblock, table.grid-all thead:last-child > tr > th.tableblock, table.grid-rows tbody > tr:last-child > th.tableblock, table.grid-rows tbody > tr:last-child > td.tableblock, table.grid-rows thead:last-child > tr > th.tableblock { border-bottom-width: 0; }

table.grid-rows tfoot > tr > th.tableblock, table.grid-rows tfoot > tr > td.tableblock { border-width: 1px 0 0 0; }

table.frame-all { border-width: 1px; }

table.frame-sides { border-width: 0 1px; }

table.frame-topbot { border-width: 1px 0; }

th.halign-left, td.halign-left { text-align: left; }

th.halign-right, td.halign-right { text-align: right; }

th.halign-center, td.halign-center { text-align: center; }

th.valign-top, td.valign-top { vertical-align: top; }

th.valign-bottom, td.valign-bottom { vertical-align: bottom; }

th.valign-middle, td.valign-middle { vertical-align: middle; }

table thead th, table tfoot th { font-weight: bold; }

tbody tr th { display: table-cell; line-height: 1.6; background: #f7f8f7; }

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: rgba(0, 0, 0, 0.8); font-weight: bold; }

p.tableblock > code:only-child { background: none; padding: 0; }

p.tableblock { font-size: 1em; }

td > div.verse { white-space: pre; }

ol { margin-left: 1.75em; }

ul li ol { margin-left: 1.5em; }

dl dd { margin-left: 1.125em; }

dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }

ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }

ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }

ul.checklist li > p:first-child > .fa-square-o:first-child, ul.checklist li > p:first-child > .fa-check-square-o:first-child { width: 1em; font-size: 0.85em; }

ul.checklist li > p:first-child > input[type="checkbox"]:first-child { width: 1em; position: relative; top: 1px; }

ul.inline { margin: 0 auto 0.625em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }

.unstyled dl dt { font-weight: normal; font-style: normal; }

ol.arabic { list-style-type: decimal; }

ol.decimal { list-style-type: decimal-leading-zero; }

ol.loweralpha { list-style-type: lower-alpha; }

ol.upperalpha { list-style-type: upper-alpha; }

ol.lowerroman { list-style-type: lower-roman; }

ol.upperroman { list-style-type: upper-roman; }

ol.lowergreek { list-style-type: lower-greek; }

.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }

td.hdlist1 { padding-right: .75em; font-weight: bold; }

td.hdlist1, td.hdlist2 { vertical-align: top; }

.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }

.colist > table tr > td:first-of-type { padding: 0 0.75em; line-height: 1; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }

.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }

.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }

.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }

a.image { text-decoration: none; }

span.footnote, span.footnoteref { vertical-align: super; font-size: 0.875em; }
span.footnote a, span.footnoteref a { text-decoration: none; }
span.footnote a:active, span.footnoteref a:active { text-decoration: underline; }

#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -.25em 0 .75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em; line-height: 1.3; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.2em; margin-bottom: .2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }

#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }

.gist .file-data > table { border: 0; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }

div.unbreakable { page-break-inside: avoid; }

.big { font-size: larger; }

.small { font-size: smaller; }

.underline { text-decoration: underline; }

.overline { text-decoration: overline; }

.line-through { text-decoration: line-through; }

.aqua { color: #00bfbf; }

.aqua-background { background-color: #00fafa; }

.black { color: black; }

.black-background { background-color: black; }

.blue { color: #0000bf; }

.blue-background { background-color: #0000fa; }

.fuchsia { color: #bf00bf; }

.fuchsia-background { background-color: #fa00fa; }

.gray { color: #606060; }

.gray-background { background-color: #7d7d7d; }

.green { color: #006000; }

.green-background { background-color: #007d00; }

.lime { color: #00bf00; }

.lime-background { background-color: #00fa00; }

.maroon { color: #600000; }

.maroon-background { background-color: #7d0000; }

.navy { color: #000060; }

.navy-background { background-color: #00007d; }

.olive { color: #606000; }

.olive-background { background-color: #7d7d00; }

.purple { color: #600060; }

.purple-background { background-color: #7d007d; }

.red { color: #bf0000; }

.red-background { background-color: #fa0000; }

.silver { color: #909090; }

.silver-background { background-color: #bcbcbc; }

.teal { color: #006060; }

.teal-background { background-color: #007d7d; }

.white { color: #bfbfbf; }

.white-background { background-color: #fafafa; }

.yellow { color: #bfbf00; }

.yellow-background { background-color: #fafa00; }

span.icon > .fa { cursor: default; }

.admonitionblock td.icon [class^="fa icon-"] { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #19407c; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }

.conum[data-value] { display: inline-block; color: #fff !important; background-color: rgba(0, 0, 0, 0.8); -webkit-border-radius: 100px; border-radius: 100px; text-align: center; font-size: 0.75em; width: 1.67em; height: 1.67em; line-height: 1.67em; font-family: "Open Sans", "DejaVu Sans", sans-serif; font-style: normal; font-weight: bold; }
.conum[data-value] * { color: #fff !important; }
.conum[data-value] + b { display: none; }
.conum[data-value]:after { content: attr(data-value); }
pre .conum[data-value] { position: relative; top: -0.125em; }

b.conum * { color: inherit !important; }

.conum:not([data-value]):empty { display: none; }

h1, h2 { letter-spacing: -0.01em; }

dt, th.tableblock, td.content { text-rendering: optimizeLegibility; }

p, td.content { letter-spacing: -0.01em; }
p strong, td.content strong { letter-spacing: -0.005em; }

p, blockquote, dt, td.content { font-size: 1.0625rem; }

p { margin-bottom: 1.25rem; }

.sidebarblock p, .sidebarblock dt, .sidebarblock td.content, p.tableblock { font-size: 1em; }

.exampleblock > .content { background-color: #fffef7; border-color: #e0e0dc; -webkit-box-shadow: 0 1px 4px #e0e0dc; box-shadow: 0 1px 4px #e0e0dc; }

.print-only { display: none !important; }

@media print { @page { margin: 1.25cm 0.75cm; }
  * { -webkit-box-shadow: none !important; box-shadow: none !important; text-shadow: none !important; }
  a { color: inherit !important; text-decoration: underline !important; }
  a.bare, a[href^="#"], a[href^="mailto:"] { text-decoration: none !important; }
  a[href^="http:"]:not(.bare):after, a[href^="https:"]:not(.bare):after { content: "(" attr(href) ")"; display: inline-block; font-size: 0.875em; padding-left: 0.25em; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  pre, blockquote, tr, img { page-break-inside: avoid; }
  thead { display: table-header-group; }
  img { max-width: 100% !important; }
  p, blockquote, dt, td.content { font-size: 1em; orphans: 3; widows: 3; }
  h2, h3, #toctitle, .sidebarblock > .content > .title, #toctitle, .sidebarblock > .content > .title { page-break-after: avoid; }
  #toc, .sidebarblock, .exampleblock > .content { background: none !important; }
  #toc { border-bottom: 1px solid #ddddd8 !important; padding-bottom: 0 !important; }
  .sect1 { padding-bottom: 0 !important; }
  .sect1 + .sect1 { border: 0 !important; }
  #header > h1:first-child { margin-top: 1.25rem; }
  body.book #header { text-align: center; }
  body.book #header > h1:first-child { border: 0 !important; margin: 2.5em 0 1em 0; }
  body.book #header .details { border: 0 !important; display: block; padding: 0 !important; }
  body.book #header .details span:first-child { margin-left: 0 !important; }
  body.book #header .details br { display: block; }
  body.book #header .details br + span:before { content: none !important; }
  body.book #toc { border: 0 !important; text-align: left !important; padding: 0 !important; margin: 0 !important; }
  body.book #toc, body.book #preamble, body.book h1.sect0, body.book .sect1 > h2 { page-break-before: always; }
  .listingblock code[data-lang]:before { display: block; }
  #footer { background: none !important; padding: 0 0.9375em; }
  #footer-text { color: rgba(0, 0, 0, 0.6) !important; font-size: 0.9em; }
  .hide-on-print { display: none !important; }
  .print-only { display: block !important; }
  .hide-for-print { display: none !important; }
  .show-for-print { display: inherit !important; } }

</style>
<style>
.listingblock .pygments .hll { background-color: #ffffcc }
.listingblock .pygments  { background: #f0f0f0; }
.listingblock .pygments .tok-c { color: #60a0b0; font-style: italic } /* Comment */
.listingblock .pygments .tok-err { border: 1px solid #FF0000 } /* Error */
.listingblock .pygments .tok-k { color: #007020; font-weight: bold } /* Keyword */
.listingblock .pygments .tok-o { color: #666666 } /* Operator */
.listingblock .pygments .tok-cm { color: #60a0b0; font-style: italic } /* Comment.Multiline */
.listingblock .pygments .tok-cp { color: #007020 } /* Comment.Preproc */
.listingblock .pygments .tok-c1 { color: #60a0b0; font-style: italic } /* Comment.Single */
.listingblock .pygments .tok-cs { color: #60a0b0; background-color: #fff0f0 } /* Comment.Special */
.listingblock .pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
.listingblock .pygments .tok-ge { font-style: italic } /* Generic.Emph */
.listingblock .pygments .tok-gr { color: #FF0000 } /* Generic.Error */
.listingblock .pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
.listingblock .pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
.listingblock .pygments .tok-go { color: #888888 } /* Generic.Output */
.listingblock .pygments .tok-gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.listingblock .pygments .tok-gs { font-weight: bold } /* Generic.Strong */
.listingblock .pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.listingblock .pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
.listingblock .pygments .tok-kc { color: #007020; font-weight: bold } /* Keyword.Constant */
.listingblock .pygments .tok-kd { color: #007020; font-weight: bold } /* Keyword.Declaration */
.listingblock .pygments .tok-kn { color: #007020; font-weight: bold } /* Keyword.Namespace */
.listingblock .pygments .tok-kp { color: #007020 } /* Keyword.Pseudo */
.listingblock .pygments .tok-kr { color: #007020; font-weight: bold } /* Keyword.Reserved */
.listingblock .pygments .tok-kt { color: #902000 } /* Keyword.Type */
.listingblock .pygments .tok-m { color: #40a070 } /* Literal.Number */
.listingblock .pygments .tok-s { color: #4070a0 } /* Literal.String */
.listingblock .pygments .tok-na { color: #4070a0 } /* Name.Attribute */
.listingblock .pygments .tok-nb { color: #007020 } /* Name.Builtin */
.listingblock .pygments .tok-nc { color: #0e84b5; font-weight: bold } /* Name.Class */
.listingblock .pygments .tok-no { color: #60add5 } /* Name.Constant */
.listingblock .pygments .tok-nd { color: #555555; font-weight: bold } /* Name.Decorator */
.listingblock .pygments .tok-ni { color: #d55537; font-weight: bold } /* Name.Entity */
.listingblock .pygments .tok-ne { color: #007020 } /* Name.Exception */
.listingblock .pygments .tok-nf { color: #06287e } /* Name.Function */
.listingblock .pygments .tok-nl { color: #002070; font-weight: bold } /* Name.Label */
.listingblock .pygments .tok-nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.listingblock .pygments .tok-nt { color: #062873; font-weight: bold } /* Name.Tag */
.listingblock .pygments .tok-nv { color: #bb60d5 } /* Name.Variable */
.listingblock .pygments .tok-ow { color: #007020; font-weight: bold } /* Operator.Word */
.listingblock .pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
.listingblock .pygments .tok-mb { color: #40a070 } /* Literal.Number.Bin */
.listingblock .pygments .tok-mf { color: #40a070 } /* Literal.Number.Float */
.listingblock .pygments .tok-mh { color: #40a070 } /* Literal.Number.Hex */
.listingblock .pygments .tok-mi { color: #40a070 } /* Literal.Number.Integer */
.listingblock .pygments .tok-mo { color: #40a070 } /* Literal.Number.Oct */
.listingblock .pygments .tok-sb { color: #4070a0 } /* Literal.String.Backtick */
.listingblock .pygments .tok-sc { color: #4070a0 } /* Literal.String.Char */
.listingblock .pygments .tok-sd { color: #4070a0; font-style: italic } /* Literal.String.Doc */
.listingblock .pygments .tok-s2 { color: #4070a0 } /* Literal.String.Double */
.listingblock .pygments .tok-se { color: #4070a0; font-weight: bold } /* Literal.String.Escape */
.listingblock .pygments .tok-sh { color: #4070a0 } /* Literal.String.Heredoc */
.listingblock .pygments .tok-si { color: #70a0d0; font-style: italic } /* Literal.String.Interpol */
.listingblock .pygments .tok-sx { color: #c65d09 } /* Literal.String.Other */
.listingblock .pygments .tok-sr { color: #235388 } /* Literal.String.Regex */
.listingblock .pygments .tok-s1 { color: #4070a0 } /* Literal.String.Single */
.listingblock .pygments .tok-ss { color: #517918 } /* Literal.String.Symbol */
.listingblock .pygments .tok-bp { color: #007020 } /* Name.Builtin.Pseudo */
.listingblock .pygments .tok-vc { color: #bb60d5 } /* Name.Variable.Class */
.listingblock .pygments .tok-vg { color: #bb60d5 } /* Name.Variable.Global */
.listingblock .pygments .tok-vi { color: #bb60d5 } /* Name.Variable.Instance */
.listingblock .pygments .tok-il { color: #40a070 } /* Literal.Number.Integer.Long */
</style>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic|Liberation+Mono:400|Roboto+Slab:400,700"/>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>ClojureScript Unraveled</h1>
<div class="details">
<span id="author" class="author">Andrey Antukh</span><br/>
<span id="email" class="email"><a href="mailto:niwi@niwi.nz">niwi@niwi.nz</a></span><br/>
<span id="author2" class="author">Alejandro Gómez</span><br/>
<span id="email2" class="email"><a href="mailto:alejandro@dialelo.com">alejandro@dialelo.com</a></span><br/>
<span id="revnumber">version 5,</span>
<span id="revdate">2015-11-06</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#about-this-book">1. About this book</a></li>
<li><a href="#introduction">2. Introduction</a></li>
<li><a href="#language-the-basics">3. Language (the basics)</a>
<ul class="sectlevel2">
<li><a href="#first-steps-with-lisp-syntax">3.1. First steps with Lisp syntax</a></li>
<li><a href="#the-base-data-types">3.2. The base data types</a></li>
<li><a href="#vars">3.3. Vars</a></li>
<li><a href="#function-section">3.4. Functions</a></li>
<li><a href="#flow-control">3.5. Flow control</a></li>
<li><a href="#locals-blocks-and-loops">3.6. Locals, Blocks, and Loops</a></li>
<li><a href="#collection-types">3.7. Collection types</a></li>
<li><a href="#destructuring-section">3.8. Destructuring</a></li>
<li><a href="#namespace-section">3.9. Namespaces</a></li>
<li><a href="#abstractions-and-polymorphism">3.10. Abstractions and Polymorphism</a></li>
<li><a href="#data-types">3.11. Data types</a></li>
<li><a href="#host-interoperability">3.12. Host interoperability</a></li>
<li><a href="#truthiness-section">3.13. Truthiness</a></li>
<li><a href="#state-management">3.14. State management</a></li>
</ul>
</li>
<li><a href="#tooling-compiler">4. Tooling &amp; Compiler</a>
<ul class="sectlevel2">
<li><a href="#getting-started-with-the-compiler">4.1. Getting Started with the Compiler</a></li>
<li><a href="#working-with-the-repl">4.2. Working with the REPL</a></li>
<li><a href="#the-closure-library">4.3. The Closure Library</a></li>
<li><a href="#dependency-management">4.4. Dependency management</a></li>
<li><a href="#using-javascript-libraries">4.5. Using javascript libraries</a></li>
<li><a href="#unit-testing">4.6. Unit testing</a></li>
</ul>
</li>
<li><a href="#language-advanced-topics">5. Language (advanced topics)</a>
<ul class="sectlevel2">
<li><a href="#transducers">5.1. Transducers</a></li>
<li><a href="#transients">5.2. Transients</a></li>
<li><a href="#metadata-section">5.3. Metadata</a></li>
<li><a href="#core-protocols-section">5.4. Core protocols</a></li>
<li><a href="#the-reader">5.5. The Reader</a></li>
<li><a href="#macros-section">5.6. Macros</a></li>
</ul>
</li>
<li><a href="#appendix">6. Appendix</a>
<ul class="sectlevel2">
<li><a href="#appendix-a-interactive-development-with-figwheel">6.1. Appendix A: Interactive development with Figwheel</a></li>
<li><a href="#appendix-b-csp-and-core-async">6.2. Appendix B: CSP and core.async</a></li>
<li><a href="#appendix-c-setting-up-a-clojurescript-development-environment">6.3. Appendix C: Setting up a ClojureScript development environment</a></li>
</ul>
</li>
<li><a href="#acknowledgments">7. Acknowledgments</a></li>
<li><a href="#further-reading">8. Further Reading</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="about-this-book"><a class="link" href="#about-this-book">1. About this book</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This book covers the ClojureScript programming language, serves as a detailed guide of its
tooling for development, and presents a series of articles about topics that are
applicable to day-to-day programming in ClojureScript.</p>
</div>
<div class="paragraph">
<p>It is not an introductory book to programming in that it assumes the reader has experience
programming in at least one language. However, it doesn&#8217;t assume experience with
<em>ClojureScript</em> or functional programming. We&#8217;ll try to include links to reference
material when talking about the theoretical underpinnings of ClojureScript that may not
be familiar to everyone.</p>
</div>
<div class="paragraph">
<p>Since the ClojureScript documentation is good but sparse, we wanted to write a compendium
of reference information and extensive examples to serve as a ClojureScript primer as
well as a series of practical how-to&#8217;s. This document will evolve with the ClojureScript
language, both as a reference of the language features and as a sort of cookbook with
practical programming recipes.</p>
</div>
<div class="paragraph">
<p>You&#8217;ll get the most out of this book if you:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>are curious about ClojureScript or functional programming and have some programming
experience;</p>
</li>
<li>
<p>write JavaScript or any other language that compiles to it and want to know what
ClojureScript has to offer;</p>
</li>
<li>
<p>already know some Clojure and want to learn how ClojureScript differs from it, plus
practical topics like how to target both languages with the same code base.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Don&#8217;t be turned off if you don&#8217;t see yourself in any of the above groups. We encourage
you to give this book a try and to give us feedback on how we can make it more accessible.
Our goal is to make ClojureScript more friendly to newcomers and spread the ideas about
programming that Clojure has helped popularize, as we see a lot of value in them.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction"><a class="link" href="#introduction">2. Introduction</a></h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
Why are we doing this? Because Clojure <em>rocks</em>, and JavaScript <em>reaches</em>.
</blockquote>
<div class="attribution">
&#8212; Rich Hickey
</div>
</div>
<div class="paragraph">
<p><em>ClojureScript</em> is an implementation of the Clojure programming language that
targets JavaScript. Because of this, it can run in many different execution
environments including web browsers, Node.js, io.js and Nashorn.</p>
</div>
<div class="paragraph">
<p>Unlike other languages that intend to <em>compile</em> to JavaScript (like TypeScript,
FunScript, or CoffeeScript), ClojureScript is designed to use JavaScript like bytecode.
It embraces functional programming and has very safe and consistent defaults. Its
semantics differ significantly from those of JavaScript.</p>
</div>
<div class="paragraph">
<p>Another big difference (and in our opinion an advantage) over other languages is that
Clojure is designed to be a guest. It is a language without its own virtual machine that
can be easily adapted to the nuances of its execution environment. This has the
benefit that Clojure (and hence ClojureScript) has access to all the existing
libraries written for the host language.</p>
</div>
<div class="paragraph">
<p>Before we jump in, let us summarize some of the core ideas that ClojureScript brings
to the table. Don&#8217;t worry if you don&#8217;t understand all of them right now, they&#8217;ll become
clear throughout the book.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ClojureScript enforces the functional programming paradigm with its design decisions
and idioms. Although being strongly opinionated about functional programming it&#8217;s a
pragmatic language rather than pursuing theoretical purity.</p>
</li>
<li>
<p>Encourages programming with immutable data, offering highly performant and state of the
art immutable collection implementations.</p>
</li>
<li>
<p>It makes a clear distinction of identity and its state, with explicit constructs
for managing change as a series of immutable values over time.</p>
</li>
<li>
<p>It has type-based and value-based polymorphism, elegantly solving the expression
problem.</p>
</li>
<li>
<p>It is a Lisp dialect so programs are written in the programming language&#8217;s own data
structures, a property known as <em>homoiconicity</em> that makes metaprogramming (programs
that write programs) as simple as it can be.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These ideas together have a great influence in the way you design and implement software,
even if you are not using Clojure. Functional programming, decoupling of data (which is
immutable) from the operations to transform it, explicit idioms for managing change
over time and polymorphic constructs for programming to abstractions greatly simplify the
systems we write.</p>
</div>
<div class="quoteblock">
<blockquote>
We can make the same exact software we are making today with dramatically simpler stuff
— dramatically simpler languages, tools, techniques, approaches.
</blockquote>
<div class="attribution">
&#8212; Rich Hickey
</div>
</div>
<div class="paragraph">
<p>We hope you enjoy the book and ClojureScript brings the same joy and inspiration that has
brought to us.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="language-the-basics"><a class="link" href="#language-the-basics">3. Language (the basics)</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter will be a little introduction to ClojureScript without assumptions about
previous knowledge of the Clojure language, providing a quick tour over all the things
you will need to know about clojurescript and understand the rest of this book.</p>
</div>
<div class="sect2">
<h3 id="first-steps-with-lisp-syntax"><a class="link" href="#first-steps-with-lisp-syntax">3.1. First steps with Lisp syntax</a></h3>
<div class="paragraph">
<p>Invented by John McCarthy in 1958, Lisp is one of the oldest programming languages that is still
around. It has evolved into many derivatives called dialects, ClojureScript being one of them. It
is a programming language written in its own data structures — originally lists enclosed in
parentheses — but Clojure(Script) has evolved the Lisp syntax with more data structures, making
it more pleasant to write and read.</p>
</div>
<div class="paragraph">
<p>A list with a function in the first position is used for calling a function in ClojureScript. In the
example below, we apply the addition function to three arguments. Note that unlike in other languages,
<code>+</code> is not an operator but a function. Lisp has no operators; it only has functions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, we&#8217;re applying the addition function <code>+</code> to the arguments <code>1</code>, <code>2</code> and <code>3</code>. ClojureScript
allows many unusual characters like <code>?</code> or <code>-</code> in symbol names, which makes it easier to read:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">zero? </span><span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To distinguish function calls from lists of data items, we can quote lists to keep them from being evaluated.
The quoted lists will be treated as data instead of as a function call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (+ 1 2 3)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>ClojureScript uses more than lists for its syntax. The full details will be covered later, but here is an
example of the usage of a vector (enclosed in brackets) for defining local bindings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-mi">1</span>
      <span class="tok-nv">y</span> <span class="tok-mi">2</span>
      <span class="tok-nv">z</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span> <span class="tok-nv">z</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; 6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is practically all the syntax we need to know for using not only ClojureScript, but any Lisp. Being
written in its own data structures (often referred to as <em>homoiconicity</em>) is a great property since the
syntax is uniform and simple; also, code generation via <a href="#macros-section">macros</a> is easier than in any other language, giving
us plenty of power to extend the language to suit our needs.</p>
</div>
</div>
<div class="sect2">
<h3 id="the-base-data-types"><a class="link" href="#the-base-data-types">3.2. The base data types</a></h3>
<div class="paragraph">
<p>The ClojureScript language has a rich set of data types like most programming languages. It provides
scalar data types that will be very familiar to you, such as numbers, strings, and floats. Beyond these, it also
provides a great number of others that might be less familiar, such as symbols, keywords, regexes (regular expressions),
vars, atoms, and volatiles.</p>
</div>
<div class="paragraph">
<p><em>ClojureScript</em> embraces the host language, and where possible, uses the host&#8217;s provided types. For example:
numbers and strings are used as is and behave in the same way as in JavaScript.</p>
</div>
<div class="sect3">
<h4 id="numbers"><a class="link" href="#numbers">3.2.1. Numbers</a></h4>
<div class="paragraph">
<p>In <em>ClojureScript</em>, numbers include both integers and floating points. Keeping in mind that
<em>ClojureScript</em> is a guest language that compiles to JavaScript, integers are actually JavaScript&#8217;s native
floating points under the hood.</p>
</div>
<div class="paragraph">
<p>As in any other language, numbers in <em>ClojureScript</em> are represented in the following ways:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-mi">23</span>
<span class="tok-nv">+23</span>
<span class="tok-mi">-100</span>
<span class="tok-mf">1.7</span>
<span class="tok-mi">-2</span>
<span class="tok-mi">33</span><span class="tok-nv">e8</span>
<span class="tok-mi">12</span><span class="tok-nv">e-14</span>
<span class="tok-mf">3.2</span><span class="tok-nv">e-4</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="keywords"><a class="link" href="#keywords">3.2.2. Keywords</a></h4>
<div class="paragraph">
<p>Keywords in <em>ClojureScript</em> are objects that always evaluate to themselves. They are usually
used in <a href="#maps-section">map data structures</a> to efficiently represent the keys.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-ss">:foobar</span>
<span class="tok-ss">:2</span>
<span class="tok-ss">:?</span>
<span class="tok-ss">:foo/bar</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the keywords are all prefixed with <code>:</code>, but this character is only part
of the literal syntax and is not part of the name of the object.</p>
</div>
<div class="paragraph">
<p>You can also create a keyword by calling the <code>keyword</code> function. Don&#8217;t worry if you don&#8217;t understand
or are unclear about anything in the following example; <a href="#function-section">functions</a> are discussed in a later section.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">keyword </span><span class="tok-s">&quot;foo&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; :foo</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="symbols"><a class="link" href="#symbols">3.2.3. Symbols</a></h4>
<div class="paragraph">
<p>Symbols in <em>ClojureScript</em> are very, very similar to <strong>keywords</strong> (which you now know about). But
instead of evaluating to themselves, symbols are evaluated to something that they refer to, which
can be functions, variables, etc.</p>
</div>
<div class="paragraph">
<p>Symbols start with a non numeric character and can contain alphanumeric characters as well as *, +, !, -, _, ', and ? such as :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-nv">sample-symbol</span>
<span class="tok-nv">othersymbol</span>
<span class="tok-nv">f1</span>
<span class="tok-nv">my-special-swap!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Don&#8217;t worry if you don&#8217;t understand right away; symbols are used in almost
all of our examples, which will give you the opportunity to learn more as we go on.</p>
</div>
</div>
<div class="sect3">
<h4 id="strings"><a class="link" href="#strings">3.2.4. Strings</a></h4>
<div class="paragraph">
<p>There is almost nothing new we can explain about strings that you don&#8217;t already know. In <em>ClojureScript</em>, they
work the same as in any other language. One point of interest, however, is that they are immutable.</p>
</div>
<div class="paragraph">
<p>In this case they are the same as in JavaScript:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-s">&quot;An example of a string&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>One peculiar aspect of strings in <em>ClojureScript</em> is due to the language&#8217;s Lisp syntax: single and multiline strings
have the same syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-s">&quot;This is a multiline</span>
<span class="tok-s">      string in ClojureScript.&quot;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="characters"><a class="link" href="#characters">3.2.5. Characters</a></h4>
<div class="paragraph">
<p><em>ClojureScript</em> also lets you write single characters using Clojure&#8217;s character literal syntax.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-sc">\a</span>        <span class="tok-c1">; The lowercase a character</span>
<span class="tok-sc">\n</span><span class="tok-nv">ewline</span>  <span class="tok-c1">; The newline character</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the host language doesn&#8217;t contain character literals, <em>ClojureScript</em> characters are transformed
behind the scenes into single character JavaScript strings.</p>
</div>
</div>
<div class="sect3">
<h4 id="collections"><a class="link" href="#collections">3.2.6. Collections</a></h4>
<div class="paragraph">
<p>Another big step in explaining a language is to explain its collections and collection
abstractions. <em>ClojureScript</em> is not an exception to this rule.</p>
</div>
<div class="paragraph">
<p><em>ClojureScript</em> comes with many types of collections. The main difference between <em>ClojureScript</em>
collections and collections in other languages is that they are persistent and immutable.</p>
</div>
<div class="paragraph">
<p>Before moving on to these (possibly) unknown concepts, we&#8217;ll present a high-level overview
of existing collection types in <em>ClojureScript</em>.</p>
</div>
<div class="sect4">
<h5 id="lists"><a class="link" href="#lists">Lists</a></h5>
<div class="paragraph">
<p>This is a classic collection type in languages based on Lisp. Lists are the
simplest type of collection in <em>ClojureScript</em>. Lists can contain items of any type, including
other collections.</p>
</div>
<div class="paragraph">
<p>Lists in <em>ClojureScript</em> are represented by items enclosed between parentheses:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">)</span>
<span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span> <span class="tok-mi">2</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, all list examples are prefixed with the <code>'</code> char. This is because lists in Lisp-like
languages are often used to express things like function or macro calls. In that case,
the first item should be a symbol that will evaluate to something callable, and the rest of the list
elements will be function arguments. However, in the preceding examples, we don&#8217;t want the first item as a symbol;
we just want a list of items.  The following example shows the difference between a list without and with the preceding
single quote mark:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>

<span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (inc 1)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, if you evaluate <code>(inc 1)</code> without prefixing it with <code>'</code>, it will resolve
the <code>inc</code> symbol to the <strong>inc</strong> function and will execute it with <code>1</code> as the first argument, returning the value <code>2</code>.</p>
</div>
<div class="paragraph">
<p>You can also explicitly create a list with the <code>list</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (1 2 3 4 5)</span>

<span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (:foo :bar 2)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Lists have the peculiarity that they are very efficient if you access them sequentially or
access their first elements, but a list is not a very good option if you need random (index) access to its
elements.</p>
</div>
</div>
<div class="sect4">
<h5 id="vectors"><a class="link" href="#vectors">Vectors</a></h5>
<div class="paragraph">
<p>Like lists, <strong>vectors</strong> store a series of values, but in this case, with very efficient index access
to their elements, as opposed to lists, which are evaluated in order. Don&#8217;t worry; in
the following sections we&#8217;ll go in depth with details, but at this moment, this simple explanation is
more than enough.</p>
</div>
<div class="paragraph">
<p>Vectors use square brackets for the literal syntax; let&#8217;s see some examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">[</span><span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span><span class="tok-p">]</span>
<span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span> <span class="tok-nv">nil</span><span class="tok-p">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Like lists, vectors can contain objects of any type, as you can observe in the preceding example.</p>
</div>
<div class="paragraph">
<p>You can also explicitly create a vector with the <code>vector</code> function, but this is not commonly used in ClojureScript programs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">vector </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [1 2 3]</span>

<span class="tok-p">(</span><span class="tok-nb">vector </span><span class="tok-s">&quot;blah&quot;</span> <span class="tok-mf">3.5</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [&quot;blah&quot; 3.5 nil]</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="maps-section"><a class="link" href="#maps-section">Maps</a></h5>
<div class="paragraph">
<p>Maps are a collection abstraction that allow you to store key/value pairs. In other
languages, this type of structure is commonly known as a hash-map or dict (dictionary). Map literals
in <em>ClojureScript</em> are written with the pairs between curly braces.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">{</span><span class="tok-ss">:foo</span> <span class="tok-s">&quot;bar&quot;</span>, <span class="tok-ss">:baz</span> <span class="tok-mi">2</span><span class="tok-p">}</span>
<span class="tok-p">{</span><span class="tok-ss">:alphabet</span> <span class="tok-p">[</span><span class="tok-ss">:a</span> <span class="tok-ss">:b</span> <span class="tok-ss">:c</span><span class="tok-p">]}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Commas are frequently used to separate a key-value pair, but they are completely optional. In
<em>ClojureScript</em> syntax, commas are treated like spaces.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Like vectors, every item in a map literal is evaluated before the result is stored in a map, but
the order of evaluation is not guaranteed.</p>
</div>
</div>
<div class="sect4">
<h5 id="sets"><a class="link" href="#sets">Sets</a></h5>
<div class="paragraph">
<p>And finally, <strong>sets</strong>.</p>
</div>
<div class="paragraph">
<p>Sets store zero or more unique items of any type and are unordered. Like maps,
they use curly braces for their literal syntax, with the difference being that they use a <code>#</code> as
the leading character. You can also use the <code>set</code> function to convert a collection to a set:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span><span class="tok-p">}</span>
<span class="tok-c1">;; =&gt; #{1 :bar 3 :foo 2}</span>
<span class="tok-p">(</span><span class="tok-nb">set </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">1</span> <span class="tok-mi">3</span> <span class="tok-mi">1</span> <span class="tok-mi">4</span> <span class="tok-mi">1</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; #{1 2 3 4 5}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In subsequent sections, we&#8217;ll go in depth about sets and the other collection types you&#8217;ve seen in this
section.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="vars"><a class="link" href="#vars">3.3. Vars</a></h3>
<div class="paragraph">
<p><em>ClojureScript</em> is a mostly functional language that focuses on immutability. Because of that, it does
not have the concept of variables as you know them in most other programming languages. The closest analogy to
variables are the variables you define in algebra; when you say <code>x = 6</code> in mathematics, you are saying that you
want the symbol <code>x</code> to stand for the number six.</p>
</div>
<div class="paragraph">
<p>In <em>ClojureScript</em>, vars are represented by symbols and store a single value together with metadata.</p>
</div>
<div class="paragraph">
<p>You can define a var using the <code>def</code> special form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">x</span> <span class="tok-mi">22</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">y</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Vars are always top level in the namespace (<a href="#namespace-section">which we will explain later</a>). If you use <code>def</code> in a function call,
the var will be defined at the namespace level, but we do not recommend this - instead, you should use <code>let</code>
to define variables within a function.</p>
</div>
</div>
<div class="sect2">
<h3 id="function-section"><a class="link" href="#function-section">3.4. Functions</a></h3>
<div class="sect3">
<h4 id="the-first-contact"><a class="link" href="#the-first-contact">3.4.1. The first contact</a></h4>
<div class="paragraph">
<p>It&#8217;s time to make things happen. <em>ClojureScript</em> has what are known as first class functions. They behave
like any other type; you can pass them as parameters and you can return them as values, always respecting
the lexical scope. <em>ClojureScript</em> also has some features of dynamic scoping, but this will be discussed
in another section.</p>
</div>
<div class="paragraph">
<p>If you want to know more about scopes, this <a href="http://en.wikipedia.org/wiki/Scope_(computer_science)">Wikipedia article</a>
is very extensive and explains different types of scoping.</p>
</div>
<div class="paragraph">
<p>As <em>ClojureScript</em> is a Lisp dialect, it uses the prefix notation for calling a function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, <code>inc</code> is a function and is part of the <em>ClojureScript</em> runtime, and <code>1</code> is the first
argument for the <code>inc</code> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>+</code> symbol represents an <code>add</code> function. It allows multiple parameters, whereas in ALGOL-type languages,
<code>+</code> is an operator and only allows two parameters.</p>
</div>
<div class="paragraph">
<p>The prefix notation has huge advantages, some of them not always obvious. <em>ClojureScript</em> does not
make a distinction between a function and an operator; everything is a function. The immediate advantage
is that the prefix notation allows an arbitrary number of arguments per "operator". It also completely
eliminates the problem of operator precedence.</p>
</div>
</div>
<div class="sect3">
<h4 id="defining-your-own-functions"><a class="link" href="#defining-your-own-functions">3.4.2. Defining your own functions</a></h4>
<div class="paragraph">
<p>You can define an unnamed (anonymous) function with the <code>fn</code> special form. This is one type of function definition;
in the following example, the function takes two parameters and returns their average.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">param1</span> <span class="tok-nv">param2</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">/ </span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">param1</span> <span class="tok-nv">param2</span><span class="tok-p">)</span> <span class="tok-mf">2.0</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can define a function and call it at the same time (in a single expression):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">((</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">x</span> <span class="tok-nv">x</span><span class="tok-p">))</span> <span class="tok-mi">5</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 25</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s start creating named functions. But what does a <em>named function</em> really mean? It is very simple;
in <em>ClojureScript</em>, functions are first-class and behave like any other value, so naming a function
is done by simply binding the function to a symbol:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">square</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">x</span> <span class="tok-nv">x</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">square</span> <span class="tok-mi">12</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 144</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>ClojureScript</em> also offers the <code>defn</code> macro as a little syntactic sugar for making function definition
more idiomatic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">square</span>
  <span class="tok-s">&quot;Return the square of a given number.&quot;</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">x</span> <span class="tok-nv">x</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The string that comes between the function name and the parameter vector is called a
<em>docstring</em> (documentation string); programs that automatically create web documentation
from your source files will use these docstrings.</p>
</div>
</div>
<div class="sect3">
<h4 id="functions-with-multiple-arities"><a class="link" href="#functions-with-multiple-arities">3.4.3. Functions with multiple arities</a></h4>
<div class="paragraph">
<p><em>ClojureScript</em> also comes with the ability to define functions with an arbitrary number of
arguments. (The term <em>arity</em> means the number of arguments that a function takes.) The
syntax is almost the same as for defining an ordinary function, with the difference that
it has more than one body.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see an example, which will explain it better:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">myinc</span>
  <span class="tok-s">&quot;Self defined version of parameterized `inc`.&quot;</span>
  <span class="tok-p">([</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">myinc</span> <span class="tok-nv">x</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
  <span class="tok-p">([</span><span class="tok-nv">x</span> <span class="tok-nv">increment</span><span class="tok-p">]</span>
   <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">increment</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This line: <code>([x] (myinc x 1))</code> says that if there is only one argument, call the function
<code>myinc</code> with that argument and the number <code>1</code> as the second argument. The other function body
<code>([x increment] (+ x increment))</code> says that if there are two arguments, return the result of
adding them.</p>
</div>
<div class="paragraph">
<p>Here are some examples using the previously defined multi-arity function. Observe that
if you call a function with the wrong number of arguments, the compiler will emit an error message.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">myinc</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>

<span class="tok-p">(</span><span class="tok-nf">myinc</span> <span class="tok-mi">1</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 4</span>

<span class="tok-p">(</span><span class="tok-nf">myinc</span> <span class="tok-mi">1</span> <span class="tok-mi">3</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; Compiler error</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Explaining the concept of "arity" is out of the scope of this book, however you can read about that in this
<a href="http://en.wikipedia.org/wiki/Arity">Wikipedia article</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="variadic-functions"><a class="link" href="#variadic-functions">3.4.4. Variadic functions</a></h4>
<div class="paragraph">
<p>Another way to accept multiple parameters is defining variadic functions. Variadic functions
are functions that accept an arbitrary number of arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-variadic-set</span>
  <span class="tok-p">[</span><span class="tok-o">&amp;</span> <span class="tok-nv">params</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">set </span><span class="tok-nv">params</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">my-variadic-set</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{1 2 3}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The way to denote a variadic function is using the <code>&amp;</code> symbol prefix on its arguments vector.</p>
</div>
</div>
<div class="sect3">
<h4 id="short-syntax-for-anonymous-functions"><a class="link" href="#short-syntax-for-anonymous-functions">3.4.5. Short syntax for anonymous functions</a></h4>
<div class="paragraph">
<p><em>ClojureScript</em> provides a shorter syntax for defining anonymous functions using
the <code>#()</code> reader macro (usually leads to one-liners). Reader macros are "special" expressions that will be
transformed to the appropriate language form at compile time; in this case, to some expression
that uses the <code>fn</code> special form.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">average</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">/ </span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">%1</span> <span class="tok-nv">%2</span><span class="tok-p">)</span> <span class="tok-mi">2</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">average</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 3.5</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding definition is shorthand for:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">average-longer</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-nv">b</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">/ </span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">a</span> <span class="tok-nv">b</span><span class="tok-p">)</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">average-longer</span> <span class="tok-mi">7</span> <span class="tok-mi">8</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 7.5</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>%1</code>, <code>%2</code>&#8230;&#8203; <code>%N</code> are simple markers for parameter positions that are implicitly declared when
the reader macro will be interpreted and converted to a <code>fn</code> expression.</p>
</div>
<div class="paragraph">
<p>If a function only accepts one argument, you can omit the number after the <code>%</code> symbol, e.g., a
function that squares a number: <code>#(* %1 %1))</code> can be written <code>#(* % %))</code>.</p>
</div>
<div class="paragraph">
<p>Additionally, this syntax also supports the variadic form with the <code>%&amp;</code> symbol:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">my-variadic-set</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">set </span><span class="tok-nv">%</span><span class="tok-o">&amp;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">my-variadic-set</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{1 2}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="flow-control"><a class="link" href="#flow-control">3.5. Flow control</a></h3>
<div class="paragraph">
<p><em>ClojureScript</em> has a very different approach to flow control than languages like JavaScript, C, etc.</p>
</div>
<div class="sect3">
<h4 id="branching-with-code-if-code"><a class="link" href="#branching-with-code-if-code">3.5.1. Branching with <code>if</code></a></h4>
<div class="paragraph">
<p>Let&#8217;s start with a basic one: <code>if</code>. In <em>ClojureScript</em>, the <code>if</code> is an expression and not a
statement, and it has three parameters: the first one is the condition expression, the second one
is an expression that will be evaluated if the condition expression evaluates to logical true,
and the third expression will be evaluated otherwise.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">discount</span>
  <span class="tok-s">&quot;You get 5% discount for ordering 100 or more items&quot;</span>
  <span class="tok-p">[</span><span class="tok-nv">quantity</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">&gt;= </span><span class="tok-nv">quantity</span> <span class="tok-mi">100</span><span class="tok-p">)</span>
    <span class="tok-mf">0.05</span>
    <span class="tok-mi">0</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">discount</span> <span class="tok-mi">30</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0</span>

<span class="tok-p">(</span><span class="tok-nf">discount</span> <span class="tok-mi">130</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0.05</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The block expression <code>do</code> can be used to have multiple expressions in an <code>if</code> branch.
<a href="#block-section"><code>do</code> is explained in the next section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="branching-with-code-cond-code"><a class="link" href="#branching-with-code-cond-code">3.5.2. Branching with <code>cond</code></a></h4>
<div class="paragraph">
<p>Sometimes, the <code>if</code> expression can be slightly limiting because it does not have the "else if" part
to add more than one condition. The <code>cond</code> macro comes to the rescue.</p>
</div>
<div class="paragraph">
<p>With the <code>cond</code> expression, you can define multiple conditions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">mypos?</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">cond</span>
    <span class="tok-p">(</span><span class="tok-nb">&gt; </span><span class="tok-nv">x</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-s">&quot;positive&quot;</span>
    <span class="tok-p">(</span><span class="tok-nb">&lt; </span><span class="tok-nv">x</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-s">&quot;negative&quot;</span>
    <span class="tok-ss">:else</span> <span class="tok-s">&quot;zero&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">mypos?</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;zero&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">mypos?</span> <span class="tok-mi">-2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;negative&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, <code>cond</code> has another form, called <code>condp</code>, that works very similarly to the simple <code>cond</code>
but looks cleaner when the condition (also called a predicate) is the same for all conditions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">translate-lang-code</span>
  <span class="tok-p">[</span><span class="tok-nv">code</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">condp</span> <span class="tok-nb">= </span><span class="tok-p">(</span><span class="tok-nb">keyword </span><span class="tok-nv">code</span><span class="tok-p">)</span>
    <span class="tok-ss">:es</span> <span class="tok-s">&quot;Spanish&quot;</span>
    <span class="tok-ss">:en</span> <span class="tok-s">&quot;English&quot;</span>
    <span class="tok-s">&quot;Unknown&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">translate-lang-code</span> <span class="tok-s">&quot;en&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;English&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">translate-lang-code</span> <span class="tok-s">&quot;fr&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Unknown&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The line <code>condp = (keyword code)</code> means that, in each of the following lines, <em>ClojureScript</em>
will apply the <code>=</code> function to the result of evaluating <code>(keyword code)</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="branching-with-code-case-code"><a class="link" href="#branching-with-code-case-code">3.5.3. Branching with <code>case</code></a></h4>
<div class="paragraph">
<p>The <code>case</code> branching expression has a similar use as our previous example with
<code>condp</code>. The main differences are that <code>case</code> always uses the <code>=</code> predicate/function and its
branching values are evaluated at compile time. This results in a more performant form
than <code>cond</code> or <code>condp</code> but has the disadvantage that the condition value must be static.</p>
</div>
<div class="paragraph">
<p>Here is the previous example rewritten to use <code>case</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">translate-lang-code</span>
  <span class="tok-p">[</span><span class="tok-nv">code</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">case</span> <span class="tok-nv">code</span>
    <span class="tok-s">&quot;es&quot;</span> <span class="tok-s">&quot;Spanish&quot;</span>
    <span class="tok-s">&quot;en&quot;</span> <span class="tok-s">&quot;English&quot;</span>
    <span class="tok-s">&quot;Unknown&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">translate-lang-code</span> <span class="tok-s">&quot;en&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;English&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">translate-lang-code</span> <span class="tok-s">&quot;fr&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Unknown&quot;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="locals-blocks-and-loops"><a class="link" href="#locals-blocks-and-loops">3.6. Locals, Blocks, and Loops</a></h3>
<div class="sect3">
<h4 id="locals"><a class="link" href="#locals">3.6.1. Locals</a></h4>
<div class="paragraph">
<p><em>ClojureScript</em> does not have the concept of variables as in ALGOL-like languages, but it does
have locals. Locals, as per usual, are immutable, and if you try to mutate them, the compiler
will throw an error.</p>
</div>
<div class="paragraph">
<p>Locals are defined with the <code>let</code> expression. The expression starts with a vector as the first parameter
followed by an arbitrary number of expressions. The first parameter (the vector) should contain an arbitrary
number of pairs that give a <em>binding form</em> (usually a symbol) followed by an expression whose value will
be bound to this new local for the remainder of the <code>let</code> expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-mi">1</span><span class="tok-p">)</span>
      <span class="tok-nv">y</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-mi">1</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Simple message from the body of a let&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">))</span>
<span class="tok-c1">;; Simple message from the body of a let</span>
<span class="tok-c1">;; =&gt; 6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the symbol <code>x</code> is bound to the value <code>(inc 1)</code>, which comes out to 2,
and the symbol <code>y</code> is bound to the sum of <code>x</code> and 1, which comes out to 3. Given those bindings, the
expressions <code>(println "Simple message from the body of a let")</code> and <code>(* x y)</code> are evaluated.</p>
</div>
</div>
<div class="sect3">
<h4 id="blocks"><a class="link" href="#blocks">3.6.2. Blocks</a></h4>
<div class="paragraph">
<p>In JavaScript, braces <code>{</code> and <code>}</code> delimit a block of code that “belongs together”. Blocks in
<em>ClojureScript</em> are created using the <code>do</code> expression and are usually used for side effects, like
printing something to the console or writing a log in a logger.</p>
</div>
<div class="paragraph">
<p>A side effect is something that is not necessary for the return value.</p>
</div>
<div class="paragraph">
<p>The <code>do</code> expression accepts as its parameter an arbitrary number of other expressions, but it returns
the return value only from the last one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">do</span>
   <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;hello world&quot;</span><span class="tok-p">)</span>
   <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;hola mundo&quot;</span><span class="tok-p">)</span>
   <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-mi">3</span> <span class="tok-mi">5</span><span class="tok-p">)</span> <span class="tok-c1">;; this value will not be returned; it is thrown away</span>
   <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>

<span class="tok-c1">;; hello world</span>
<span class="tok-c1">;; hola mundo</span>
<span class="tok-c1">;; =&gt; 3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The body of the <code>let</code> expression, explained in the previous section, is very similar to the
<code>do</code> expression in that it allows multiple expressions. In fact, the <code>let</code> has an implicit <code>do</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="loops"><a class="link" href="#loops">3.6.3. Loops</a></h4>
<div class="paragraph">
<p>The functional approach of <em>ClojureScript</em> means that it does not have standard,
well-known, statement-based loops such as <code>for</code> in JavaScript. The loops in <em>ClojureScript</em> are handled using recursion.
Recursion sometimes requires additional thinking about how to model your problem in
a slightly different way than imperative languages.</p>
</div>
<div class="paragraph">
<p>Many of the common patterns for which <code>for</code> is used in other languages are achieved
through higher-order functions - functions that accept other functions as parameters.</p>
</div>
<div class="sect4">
<h5 id="looping-with-loop-recur"><a class="link" href="#looping-with-loop-recur">Looping with loop/recur</a></h5>
<div class="paragraph">
<p>Let&#8217;s take a look at how to express loops using recursion with the <code>loop</code> and <code>recur</code> forms.
<code>loop</code> defines a possibly empty list of bindings (notice the symmetry with <code>let</code>) and <code>recur</code>
jumps execution back to the looping point with new values for those bindings.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">loop </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-mi">0</span><span class="tok-p">]</span>
   <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Looping with &quot;</span> <span class="tok-nv">x</span><span class="tok-p">)</span>
   <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">x</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Done looping!&quot;</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">x</span><span class="tok-p">))))</span>
<span class="tok-c1">;; Looping with 0</span>
<span class="tok-c1">;; Looping with 1</span>
<span class="tok-c1">;; Looping with 2</span>
<span class="tok-c1">;; Done looping!</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above snippet, we bind the name <code>x</code> to the value <code>0</code> and execute the body. Since the
condition is not met the first time, it&#8217;s rerun with <code>recur</code>, incrementing the binding value with
the <code>inc</code> function. We do this once more until the condition is met and, since there aren&#8217;t any
more <code>recur</code> calls, exit the loop.</p>
</div>
<div class="paragraph">
<p>Note that <code>loop</code> isn&#8217;t the only point we can <code>recur</code> to; using <code>recur</code> inside a function
executes the body of the function recursively with the new bindings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">recursive-function</span> <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span>
   <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Looping with&quot;</span> <span class="tok-nv">x</span><span class="tok-p">)</span>
   <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">x</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Done looping!&quot;</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">x</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">recursive-function</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; Looping with 0</span>
<span class="tok-c1">;; Looping with 1</span>
<span class="tok-c1">;; Looping with 2</span>
<span class="tok-c1">;; Done looping!</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="replacing-for-loops-with-higher-order-functions"><a class="link" href="#replacing-for-loops-with-higher-order-functions">Replacing for loops with higher-order functions</a></h5>
<div class="paragraph">
<p>In imperative programming languages it is common to use <code>for</code> loops to iterate over data and
transform it, usually with the intent being one of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Transform every value in the iterable yielding another iterable</p>
</li>
<li>
<p>Filter the elements of the iterable by certain criteria</p>
</li>
<li>
<p>Convert the iterable to a value where each iteration depends on the result from the previous one</p>
</li>
<li>
<p>Run a computation for every value in the iterable</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The above actions are encoded in higher-order functions and syntactic constructs in ClojureScript;
let&#8217;s see an example of the first three.</p>
</div>
<div class="paragraph">
<p>For transforming every value in an iterable data structure we use the <code>map</code> function, which takes a
function and a sequence and applies the function to every element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (1 2 3)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The first parameter for <code>map</code> can be <em>any</em> function that takes one argument and returns a value.
For example, if you had a graphing application and you wanted to graph the equation
<code>y&#160;=&#160;3x&#160;+&#160;5</code> for a set of <em>x</em> values, you could get the <em>y</em> values like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">y-value</span> <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-mi">3</span> <span class="tok-nv">x</span><span class="tok-p">)</span> <span class="tok-mi">5</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">y-value</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (8 11 14 17 20)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If your function is short, you can use an anonymous function instead, either the normal or short syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-mi">3</span> <span class="tok-nv">x</span><span class="tok-p">)</span> <span class="tok-mi">5</span><span class="tok-p">))</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (8 11 14 17 20)</span>
<span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-mi">3</span> <span class="tok-nv">%</span><span class="tok-p">)</span> <span class="tok-mi">5</span><span class="tok-p">)</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (8 11 14 17 20)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For filtering the values of a data structure we use the <code>filter</code> function, which takes a predicate
and a sequence and gives a new sequence with only the elements that returned <code>true</code> for the given
predicate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-nv">odd?</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (1 3)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, you can use any function that returns <code>true</code> or <code>false</code> as the first argument to <code>filter</code>.
Here is an example that keeps only words less than five characters long. (The <code>count</code> function
returns the length of its argument.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">word</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">&lt; </span><span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-nv">word</span><span class="tok-p">)</span> <span class="tok-mi">5</span><span class="tok-p">))</span> <span class="tok-p">[</span><span class="tok-s">&quot;ant&quot;</span> <span class="tok-s">&quot;baboon&quot;</span> <span class="tok-s">&quot;crab&quot;</span> <span class="tok-s">&quot;duck&quot;</span> <span class="tok-s">&quot;echidna&quot;</span> <span class="tok-s">&quot;fox&quot;</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (&quot;ant&quot; &quot;crab&quot; &quot;duck&quot; &quot;fox&quot;)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Converting an iterable to a single value, accumulating the intermediate result at every step of the iteration
can be achieved with <code>reduce</code>, which takes a function for accumulating values, an optional initial value
and a collection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">reduce + </span><span class="tok-mi">0</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 10</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Yet again, you can provide your own function as the first argument to <code>reduce</code>, but your function must have
<em>two</em> parameters. The first one is the "accumulated value" and the second parameter is the collection item
being processed. The function returns a value that becomes the accumulator for the next item in the list.
For example, here is how you would find the sum of squares of a set of numbers (this is
an important calculation in statistics). Using a separate function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">sum-squares</span> <span class="tok-p">[</span><span class="tok-nv">accumulator</span> <span class="tok-nv">item</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">accumulator</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">item</span> <span class="tok-nv">item</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-nv">sum-squares</span> <span class="tok-mi">0</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 50</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;and with an anonymous function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">item</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">acc</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">item</span> <span class="tok-nv">item</span><span class="tok-p">)))</span> <span class="tok-mi">0</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 50</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is a <code>reduce</code> that finds the total number of characters in a set of words:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">word</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">acc</span> <span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-nv">word</span><span class="tok-p">)))</span> <span class="tok-mi">0</span> <span class="tok-p">[</span><span class="tok-s">&quot;ant&quot;</span> <span class="tok-s">&quot;bee&quot;</span> <span class="tok-s">&quot;crab&quot;</span> <span class="tok-s">&quot;duck&quot;</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 14</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We have not used the short syntax here because, although it requires less typing,
it can be less readable, and when you are starting with a new language,
it&#8217;s important to be able to read what you wrote! If you are comfortable with the
short syntax, feel free to use it.</p>
</div>
<div class="paragraph">
<p>Remember to choose your starting value for the accumulator carefully. If you
wanted to use <code>reduce</code> to find the product of a series of numbers, you would have to start
with one rather than zero, otherwise all the numbers would be multiplied by zero!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-c1">;; wrong starting value</span>
<span class="tok-p">(</span><span class="tok-nb">reduce * </span><span class="tok-mi">0</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 0</span>

<span class="tok-c1">;; correct starting accumulator</span>
<span class="tok-p">(</span><span class="tok-nb">reduce * </span><span class="tok-mi">1</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 60</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="code-for-code-sequence-comprehensions"><a class="link" href="#code-for-code-sequence-comprehensions"><code>for</code> sequence comprehensions</a></h5>
<div class="paragraph">
<p>In ClojureScript, the <code>for</code> construct isn&#8217;t used for iteration but for generating sequences, an operation
also known as "sequence comprehension". In this section we&#8217;ll learn how it works and use it to
declaratively build sequences.</p>
</div>
<div class="paragraph">
<p><code>for</code> takes a vector of bindings and an expression and generates a sequence of the result of evaluating the
expression. Let&#8217;s take a look at an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">for </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]]</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">x</span> <span class="tok-nv">x</span><span class="tok-p">)])</span>
<span class="tok-c1">;; =&gt; ([1 1] [2 4] [3 9])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, <code>x</code> is bound to each of the items in the vector <code>[1 2 3]</code> in turn, and returns a new
sequence of two-item vectors with the original item squared.</p>
</div>
<div class="paragraph">
<p><code>for</code> supports multiple bindings, which will cause the collections to be iterated in a nested fashion, much
like nesting <code>for</code> loops in imperative languages. The innermost binding iterates “fastest.”</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">for </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
      <span class="tok-nv">y</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]]</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">])</span>

<span class="tok-c1">;; =&gt; ([1 4] [1 5] [2 4] [2 5] [3 4] [3 5])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also follow the bindings with three modifiers: <code>:let</code> for creating local bindings, <code>:while</code> for
breaking out of the sequence generation, and <code>:when</code> for filtering out values.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of local bindings using the <code>:let</code> modifier; note that the bindings defined with it
will be available in the expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">for </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
      <span class="tok-nv">y</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]</span>
      <span class="tok-ss">:let</span> <span class="tok-p">[</span><span class="tok-nv">z</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)]]</span>
  <span class="tok-nv">z</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (5 6 6 7 7 8)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can use the <code>:while</code> modifier for expressing a condition that, when it is no longer met, will stop
the sequence generation. Here&#8217;s an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">for </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
      <span class="tok-nv">y</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]</span>
      <span class="tok-ss">:while</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">y</span> <span class="tok-mi">4</span><span class="tok-p">)]</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">])</span>

<span class="tok-c1">;; =&gt; ([1 4] [2 4] [3 4])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For filtering out generated values, use the <code>:when</code> modifier as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">for </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
      <span class="tok-nv">y</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]</span>
      <span class="tok-ss">:when</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)</span> <span class="tok-mi">6</span><span class="tok-p">)]</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">])</span>

<span class="tok-c1">;; =&gt; ([1 5] [2 4])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can combine the modifiers shown above for expressing complex sequence generations or
more clearly expressing the intent of our comprehension:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">for </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
      <span class="tok-nv">y</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]</span>
      <span class="tok-ss">:let</span> <span class="tok-p">[</span><span class="tok-nv">z</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)]</span>
      <span class="tok-ss">:when</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">z</span> <span class="tok-mi">6</span><span class="tok-p">)]</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">])</span>

<span class="tok-c1">;; =&gt; ([1 5] [2 4])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When we outlined the most common usages of the <code>for</code> construct in imperative programming languages,
we mentioned that sometimes we want to run a computation for every value in a sequence, not caring
about the result. Presumably we do this for achieving some sort of side-effect with the values of
the sequence.</p>
</div>
<div class="paragraph">
<p>ClojureScript provides the <code>doseq</code> construct, which is analogous to <code>for</code> but executes the expression,
discards the resulting values, and returns <code>nil</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">doseq </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
        <span class="tok-nv">y</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]</span>
       <span class="tok-ss">:let</span> <span class="tok-p">[</span><span class="tok-nv">z</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)]]</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-nv">x</span> <span class="tok-s">&quot;+&quot;</span> <span class="tok-nv">y</span> <span class="tok-s">&quot;=&quot;</span> <span class="tok-nv">z</span><span class="tok-p">))</span>

<span class="tok-c1">;; 1 + 4 = 5</span>
<span class="tok-c1">;; 1 + 5 = 6</span>
<span class="tok-c1">;; 2 + 4 = 6</span>
<span class="tok-c1">;; 2 + 5 = 7</span>
<span class="tok-c1">;; 3 + 4 = 7</span>
<span class="tok-c1">;; 3 + 5 = 8</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="collection-types"><a class="link" href="#collection-types">3.7. Collection types</a></h3>
<div class="sect3">
<h4 id="immutable-and-persistent"><a class="link" href="#immutable-and-persistent">3.7.1. Immutable and persistent</a></h4>
<div class="paragraph">
<p>We mentioned before that ClojureScript collections are persistent and immutable, but we didn&#8217;t explain what
that meant.</p>
</div>
<div class="paragraph">
<p>An immutable data structure, as its name suggests, is a data structure that cannot be changed. In-place
updates are not allowed in immutable data structures.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s illustrate that with an example: appending values to a vector using the <code>conj</code> (conjoin) operation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">xs</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
      <span class="tok-nv">ys</span> <span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">xs</span> <span class="tok-mi">4</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;xs:&quot;</span> <span class="tok-nv">xs</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;ys:&quot;</span> <span class="tok-nv">ys</span><span class="tok-p">))</span>

<span class="tok-c1">;; xs: [1 2 3]</span>
<span class="tok-c1">;; ys: [1 2 3 4]</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, we derived a new version of the <code>xs</code> vector appending an element to it and got a new
vector <code>ys</code> with the element added. However, the <code>xs</code> vector remained unchanged because it is immutable.</p>
</div>
<div class="paragraph">
<p>A persistent data structure is a data structure that returns a new version of itself when transforming
it, leaving the original unmodified. ClojureScript makes this memory and time efficient using an
implementation technique called <em>structural sharing</em>, where most of the data shared between two versions
of a value is not duplicated and transformations of a value are implemented by copying the minimal amount of data
required.</p>
</div>
<div class="paragraph">
<p>If you want to see an example of how structural sharing works, read on. If you&#8217;re not interested in more details
you can skip over to the <a href="#the-sequence-abstraction">next section</a>.</p>
</div>
<div class="paragraph">
<p>For illustrating the structural sharing of ClojureScript data structures, let&#8217;s compare whether some parts
of the old and new versions of a data structure are actually the same object with the <code>identical?</code> predicate.
We&#8217;ll use the list data type for this purpose:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">xs</span> <span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
      <span class="tok-nv">ys</span> <span class="tok-p">(</span><span class="tok-nb">cons </span><span class="tok-mi">0</span> <span class="tok-nv">xs</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;xs:&quot;</span> <span class="tok-nv">xs</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;ys:&quot;</span> <span class="tok-nv">ys</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;(rest ys):&quot;</span> <span class="tok-p">(</span><span class="tok-nb">rest </span><span class="tok-nv">ys</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nb">identical? </span><span class="tok-nv">xs</span> <span class="tok-p">(</span><span class="tok-nb">rest </span><span class="tok-nv">ys</span><span class="tok-p">)))</span>

<span class="tok-c1">;; xs: (1 2 3)</span>
<span class="tok-c1">;; ys: (0 1 2 3)</span>
<span class="tok-c1">;; (rest ys): (1 2 3)</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see in the example, we used <code>cons</code> (construct) to prepend a value to the <code>xs</code> list and we got
a new list <code>ys</code> with the element added. The <code>rest</code> of the <code>ys</code> list (all the values but the first)
are the same object in memory as the <code>xs</code> list, thus <code>xs</code> and <code>ys</code> share structure.</p>
</div>
</div>
<div class="sect3">
<h4 id="the-sequence-abstraction"><a class="link" href="#the-sequence-abstraction">3.7.2. The sequence abstraction</a></h4>
<div class="paragraph">
<p>One of the central ClojureScript abstractions is the <em>sequence</em> which can be thought of as a list and can be derived
from any of the collection types. It is persistent and immutable like all collection types, and many of the
core ClojureScript functions return sequences.</p>
</div>
<div class="paragraph">
<p>The types that can be used to generate a sequence are called "seqables"; we can call <code>seq</code> on them and get
a sequence back. Sequences support two basic operations: <code>first</code> and <code>rest</code>. They both call <code>seq</code> on the
argument we provide them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">first </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nb">rest </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (2 3)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Calling <code>seq</code> on a seqable can yield different results if the seqable is empty or not. It will return <code>nil</code>
when empty and a sequence otherwise:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">seq </span><span class="tok-p">[])</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nb">seq </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (1 2 3)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>next</code> is a similar sequence operation to <code>rest</code>, but it differs from the latter in that it yields a <code>nil</code> value
when called with a sequence with one or zero elements. Note that, when given one of the aforementioned sequences,
the empty sequence returned by <code>rest</code> will evaluate as a boolean true whereas the <code>nil</code> value returned by <code>next</code>
will evaluate as false (<a href="#truthiness-section">see the section on <em>truthiness</em> later in this chapter</a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">rest </span><span class="tok-p">[])</span>
<span class="tok-c1">;; =&gt; ()</span>

<span class="tok-p">(</span><span class="tok-nb">next </span><span class="tok-p">[])</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nb">rest </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (2 3)</span>

<span class="tok-p">(</span><span class="tok-nb">next </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (2 3)</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="nil-punning"><a class="link" href="#nil-punning">nil-punning</a></h5>
<div class="paragraph">
<p>Since <code>seq</code> returns <code>nil</code> when the collection is empty, and <code>nil</code> evaluates to false in boolean context, you can
check to see if a collection is empty by using the <code>seq</code> function. The technical term for this is nil-punning.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">print-coll</span>
  <span class="tok-p">[</span><span class="tok-nv">coll</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">when </span><span class="tok-p">(</span><span class="tok-nb">seq </span><span class="tok-nv">coll</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Saw &quot;</span> <span class="tok-p">(</span><span class="tok-nb">first </span><span class="tok-nv">coll</span><span class="tok-p">))</span>
    <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nb">rest </span><span class="tok-nv">coll</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">print-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; Saw 1</span>
<span class="tok-c1">;; Saw 2</span>
<span class="tok-c1">;; Saw 3</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">print-coll</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">})</span>
<span class="tok-c1">;; Saw 1</span>
<span class="tok-c1">;; Saw 3</span>
<span class="tok-c1">;; Saw 2</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Though <code>nil</code> is neither a seqable nor a sequence, it is supported by all the functions we saw so far:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">seq </span><span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nb">first </span><span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nb">rest </span><span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; ()</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="functions-that-work-on-sequences"><a class="link" href="#functions-that-work-on-sequences">Functions that work on sequences</a></h5>
<div class="paragraph">
<p>The ClojureScript core functions for transforming collections make sequences out of their arguments and are
implemented in terms of the generic sequence operations we learned about in the preceding section. This makes
them highly generic because we can use them on any data type that is seqable. Let&#8217;s see how we can use <code>map</code> with
a variety of seqables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (2 3 4)</span>

<span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; (2 4 3)</span>

<span class="tok-p">(</span><span class="tok-nb">map count </span><span class="tok-p">{</span><span class="tok-ss">:a</span> <span class="tok-mi">41</span> <span class="tok-ss">:b</span> <span class="tok-mi">40</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; (2 2)</span>

<span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; (2 3 4)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note: When you use the <code>map</code> function on a map collection, your higher-order function
will receive a two-item vector containing a key and value from the map. The following example
uses <a href="#destructuring-section">destructuring</a> to access the key and value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[[</span><span class="tok-nb">key </span><span class="tok-nv">value</span><span class="tok-p">]]</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">value</span> <span class="tok-nv">value</span><span class="tok-p">))</span> <span class="tok-p">{</span><span class="tok-ss">:ten</span> <span class="tok-mi">10</span> <span class="tok-ss">:seven</span> <span class="tok-mi">7</span> <span class="tok-ss">:four</span> <span class="tok-mi">4</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; (100 49 16)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you may have noticed, functions that operate on sequences are safe to use with empty collections or even
<code>nil</code> values since they don&#8217;t need to do anything but return an empty sequence when encountering such values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-p">[])</span>
<span class="tok-c1">;; =&gt; ()</span>

<span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-o">#</span><span class="tok-p">{})</span>
<span class="tok-c1">;; =&gt; ()</span>

<span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; ()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We already saw examples with the usual suspects like <code>map</code>, <code>filter</code>, and <code>reduce</code>, but ClojureScript offers a
plethora of generic sequence operations in its core namespace. Note that many of the operations we&#8217;ll learn about
either work with seqables or are extensible to user-defined types.</p>
</div>
<div class="paragraph">
<p>We can query a value to know whether it&#8217;s a collection type with the <code>coll?</code> predicate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">coll?</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>

<span class="tok-p">(</span><span class="tok-nf">coll?</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">coll?</span> <span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span> <span class="tok-ss">:file-extension</span> <span class="tok-s">&quot;cljs&quot;</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">coll?</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Similar predicates exist for checking if a value is a sequence (<code>seq?</code>) or a seqable (<code>seqable?</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">seq? </span><span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>
<span class="tok-p">(</span><span class="tok-nf">seqable?</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>

<span class="tok-p">(</span><span class="tok-nb">seq? </span><span class="tok-p">[])</span>
<span class="tok-c1">;; =&gt; false</span>
<span class="tok-p">(</span><span class="tok-nf">seqable?</span> <span class="tok-p">[])</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">seq? </span><span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; false</span>
<span class="tok-p">(</span><span class="tok-nf">seqable?</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">seq? </span><span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>
<span class="tok-p">(</span><span class="tok-nf">seqable?</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For collections that can be counted in constant time, we can use the <code>count</code> operation. This operation also works on strings, even though, as you have seen, they are not collections, sequences, or seqable.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0</span>

<span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 3</span>

<span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span> <span class="tok-ss">:file-extension</span> <span class="tok-s">&quot;cljs&quot;</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; 2</span>

<span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 13</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also get an empty variant of a given collection with the <code>empty</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">empty</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">empty</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; []</span>

<span class="tok-p">(</span><span class="tok-nf">empty</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; #{}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>empty?</code> predicate returns true if the given collection is empty:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">empty?</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">empty?</span> <span class="tok-p">[])</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">empty?</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>conj</code> operation adds elements to collections and may add them in different "places" depending
on the type of collection. It adds them where it is most performant for the collection type,
but note that not every collection has a defined order.</p>
</div>
<div class="paragraph">
<p>We can pass as many elements as we want to add to <code>conj</code>; let&#8217;s see it in action:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">nil</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (42)</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [1 2 3]</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [1 2 3 4 5]</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (0 1 2)</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">}</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{1 3 2 4}</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">}</span> <span class="tok-p">[</span><span class="tok-ss">:file-extension</span> <span class="tok-s">&quot;cljs&quot;</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; {:language &quot;ClojureScript&quot;, :file-extension &quot;cljs&quot;}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="laziness"><a class="link" href="#laziness">Laziness</a></h5>
<div class="paragraph">
<p>Most of ClojureScript&#8217;s sequence-returning functions generate lazy sequences instead of eagerly creating
a whole new sequence. Lazy sequences generate their contents as they are requested, usually when iterating
over them. Laziness ensures that we don&#8217;t do more work than we need to and gives us the possibility of
treating potentially infinite sequences as regular ones.</p>
</div>
<div class="paragraph">
<p>Consider the <code>range</code> function, which generates a range of integers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">5</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (0 1 2 3 4)</span>
<span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">1</span> <span class="tok-mi">10</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (1 2 3 4 5 6 7 8 9)</span>
<span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">10</span> <span class="tok-mi">100</span> <span class="tok-mi">15</span><span class="tok-p">)</span>
<span class="tok-c1">;; (10 25 40 55 70 85)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you just say <code>(range)</code>, you will get an infinite sequence of all the integers.
Do <strong>not</strong> try this in the REPL, unless you are prepared to wait for a very, very long time, because
the REPL wants to fully evaluate the expression.</p>
</div>
<div class="paragraph">
<p>Here is a contrived example. Let&#8217;s say you are writing a graphing program and you are graphing the
equation <em>y</em>= 2_x_<sup>2</sup> + 5, and you want only those values of <em>x</em> for which the <em>y</em> value is less than 100.
You can generate all the numbers 0 through 100, which will certainly be enough, and then <code>take-while</code>
the condition holds:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">take-while </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">&lt; </span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-mi">2</span> <span class="tok-nv">x</span> <span class="tok-nv">x</span><span class="tok-p">)</span> <span class="tok-mi">5</span><span class="tok-p">)</span> <span class="tok-mi">100</span><span class="tok-p">))</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">0</span> <span class="tok-mi">100</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; (0 1 2 3 4 5 6)</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="collections-in-depth"><a class="link" href="#collections-in-depth">3.7.3. Collections in depth</a></h4>
<div class="paragraph">
<p>Now that we&#8217;re acquainted with ClojureScript&#8217;s sequence abstraction and some of the generic sequence manipulating
functions, it&#8217;s time to dive into the concrete collection types and the operations they support.</p>
</div>
<div class="sect4">
<h5 id="lists-2"><a class="link" href="#lists-2">Lists</a></h5>
<div class="paragraph">
<p>In ClojureScript, lists are mostly used as a data structure for grouping symbols together into programs. Unlike in other
Lisps, many of the syntactic constructs of ClojureScript use data structures different from the list (vectors and maps).
This makes code less uniform, but the gains in readability are well worth the price.</p>
</div>
<div class="paragraph">
<p>You can think of ClojureScript lists as singly linked lists, where each node contains a value and a pointer to the rest of the list.
This makes it natural (and fast!) to add items to the front of the list, since adding to the end would require traversal of the entire
list. The prepend operation is performed using the <code>cons</code> (construct) function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">cons </span><span class="tok-mi">0</span> <span class="tok-p">(</span><span class="tok-nb">cons </span><span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-nb">cons </span><span class="tok-mi">2</span> <span class="tok-p">())))</span>
<span class="tok-c1">;; =&gt; (0 1 2)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We used the literal <code>()</code> to represent the empty list. Since it doesn&#8217;t contain any symbols, it is not treated
as a function call. However, when using list literals that contain elements, we need to quote them to
prevent ClojureScript from evaluating them as a function call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">cons </span><span class="tok-mi">0</span> <span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; (0 1 2)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the head is the position that has constant time addition in the list collection, the <code>conj</code> operation
on lists naturally adds items to the front:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (0 1 2)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Lists and other ClojureScript data structures can be used as stacks using the <code>peek</code>, <code>pop</code>, and <code>conj</code> functions.
Note that the top of the stack will be the "place" where <code>conj</code> adds elements, making <code>conj</code> equivalent to the
stack&#8217;s push operation. In the case of lists, <code>conj</code> adds elements to the front of the list, <code>peek</code> returns the first
element of the list, and <code>pop</code> returns a list with all the elements but the first one.</p>
</div>
<div class="paragraph">
<p>Note that the two operations that return a stack (<code>conj</code> and <code>pop</code>) don&#8217;t change the type of the collection used for
the stack.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">list-stack</span> <span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">peek </span><span class="tok-nv">list-stack</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0</span>

<span class="tok-p">(</span><span class="tok-nb">pop </span><span class="tok-nv">list-stack</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (1 2)</span>

<span class="tok-p">(</span><span class="tok-nf">type</span> <span class="tok-p">(</span><span class="tok-nb">pop </span><span class="tok-nv">list-stack</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; cljs.core/List</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">list-stack</span> <span class="tok-mi">-1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (-1 0 1 2)</span>

<span class="tok-p">(</span><span class="tok-nf">type</span> <span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">list-stack</span> <span class="tok-mi">-1</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; cljs.core/List</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>One thing that lists are not particularly good at is random indexed access. Since they are stored in a single linked list-like
structure in memory, random access to a given index requires a linear traversal in order to either retrieve the requested
item or throw an index out of bounds error. Non-indexed ordered collections like lazy sequences also suffer from this limitation.</p>
</div>
</div>
<div class="sect4">
<h5 id="vectors-2"><a class="link" href="#vectors-2">Vectors</a></h5>
<div class="paragraph">
<p>Vectors are one of the most common data structures in ClojureScript. They are used as a syntactic construct in many
places where more traditional Lisps use lists, for example in function argument declarations and <code>let</code> bindings.</p>
</div>
<div class="paragraph">
<p>ClojureScript vectors have enclosing brackets <code>[]</code> in their syntax literals. They can be created with <code>vector</code> and from
another collection with <code>vec</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">vector? </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">vector </span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [0 1 2]</span>

<span class="tok-p">(</span><span class="tok-nf">vec</span> <span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; [0 1 2]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Vectors are, like lists, ordered collections of heterogeneous values. Unlike lists, vectors grow naturally from the tail,
so the <code>conj</code> operation appends items to the end of a vector. Insertion on the end of a vector is effectively constant
time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span><span class="tok-p">]</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [0 1 2]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Another thing that differentiates lists and vectors is that vectors are indexed collections and as such support efficient
random index access and non-destructive updates. We can use the <code>nth</code> function to retrieve values given an index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">nth </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since vectors associate sequential numeric keys (indexes) to values, we can treat them as an associative data structure. ClojureScript
provides the <code>assoc</code> function that, given an associative data structure and a set of key-value pairs, yields a new data structure with
the values corresponding to the keys modified. Indexes begin at zero for the first element in a vector.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-p">[</span><span class="tok-s">&quot;cero&quot;</span> <span class="tok-s">&quot;uno&quot;</span> <span class="tok-s">&quot;two&quot;</span><span class="tok-p">]</span> <span class="tok-mi">2</span> <span class="tok-s">&quot;dos&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [&quot;cero&quot; &quot;uno&quot; &quot;dos&quot;]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that we can only <code>assoc</code> to a key that is either contained in the vector already or if it is the last position in a vector:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-p">[</span><span class="tok-s">&quot;cero&quot;</span> <span class="tok-s">&quot;uno&quot;</span> <span class="tok-s">&quot;dos&quot;</span><span class="tok-p">]</span> <span class="tok-mi">3</span> <span class="tok-s">&quot;tres&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [&quot;cero&quot; &quot;uno&quot; &quot;dos&quot; &quot;tres&quot;]</span>

<span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-p">[</span><span class="tok-s">&quot;cero&quot;</span> <span class="tok-s">&quot;uno&quot;</span> <span class="tok-s">&quot;dos&quot;</span><span class="tok-p">]</span> <span class="tok-mi">4</span> <span class="tok-s">&quot;cuatro&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; Error: Index 4 out of bounds [0,3]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Perhaps surprisingly, associative data structures can also be used as functions. They are functions of their keys to the values they
are associated with. In the case of vectors, if the given key is not present an exception is thrown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">([</span><span class="tok-s">&quot;cero&quot;</span> <span class="tok-s">&quot;uno&quot;</span> <span class="tok-s">&quot;dos&quot;</span><span class="tok-p">]</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;cero&quot;</span>

<span class="tok-p">([</span><span class="tok-s">&quot;cero&quot;</span> <span class="tok-s">&quot;uno&quot;</span> <span class="tok-s">&quot;dos&quot;</span><span class="tok-p">]</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;dos&quot;</span>

<span class="tok-p">([</span><span class="tok-s">&quot;cero&quot;</span> <span class="tok-s">&quot;uno&quot;</span> <span class="tok-s">&quot;dos&quot;</span><span class="tok-p">]</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; Error: Not item 3 in vector of length 3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As with lists, vectors can also be used as stacks with the <code>peek</code>, <code>pop</code>, and <code>conj</code> functions. Note, however, that vectors grow
from the opposite end of the collection as lists:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">vector-stack</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nb">peek </span><span class="tok-nv">vector-stack</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>

<span class="tok-p">(</span><span class="tok-nb">pop </span><span class="tok-nv">vector-stack</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [0 1]</span>

<span class="tok-p">(</span><span class="tok-nf">type</span> <span class="tok-p">(</span><span class="tok-nb">pop </span><span class="tok-nv">vector-stack</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; cljs.core/PersistentVector</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">vector-stack</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [0 1 2 3]</span>

<span class="tok-p">(</span><span class="tok-nf">type</span> <span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">vector-stack</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; cljs.core/PersistentVector</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>map</code> and <code>filter</code> operations return lazy sequences, but as it is common to need a fully realized sequence after performing those operations, vector-returning counterparts of such functions are available as <code>mapv</code> and <code>filterv</code>. They have the advantages of being
faster than building a vector from a lazy sequence and making your intent more explicit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (1 2 3)</span>

<span class="tok-p">(</span><span class="tok-nf">type</span> <span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]))</span>
<span class="tok-c1">;; =&gt; cljs.core/LazySeq</span>

<span class="tok-p">(</span><span class="tok-nf">mapv</span> <span class="tok-nb">inc </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [1 2 3]</span>

<span class="tok-p">(</span><span class="tok-nf">type</span> <span class="tok-p">(</span><span class="tok-nf">mapv</span> <span class="tok-nb">inc </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]))</span>
<span class="tok-c1">;; =&gt; cljs.core/PersistentVector</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="maps"><a class="link" href="#maps">Maps</a></h5>
<div class="paragraph">
<p>Maps are ubiquitous in ClojureScript. Like vectors, they are also used as a syntactic construct, particularly for attaching
<a href="#metadata-section">metadata</a> to vars. Any ClojureScript data structure can be used as a key in a map, although it&#8217;s common
to use keywords since they can
also be called as functions.</p>
</div>
<div class="paragraph">
<p>ClojureScript maps are written literally as key-value pairs enclosed in braces <code>{}</code>. Alternatively, they can be created
with the <code>hash-map</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">map? </span><span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">hash-map </span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:name &quot;Cirilla&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">hash-map </span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span> <span class="tok-ss">:surname</span> <span class="tok-s">&quot;Fiona&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:name &quot;Cirilla&quot; :surname &quot;Fiona&quot;}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since regular maps don&#8217;t have a specific order, the <code>conj</code> operation just adds one or more key-value pairs to a map. <code>conj</code>
for maps expects one or more sequences of key-value pairs as its last arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ciri</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">})</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">ciri</span> <span class="tok-p">[</span><span class="tok-ss">:surname</span> <span class="tok-s">&quot;Fiona&quot;</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; {:name &quot;Cirilla&quot;, :surname &quot;Fiona&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">ciri</span> <span class="tok-p">[</span><span class="tok-ss">:surname</span> <span class="tok-s">&quot;Fiona&quot;</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-ss">:occupation</span> <span class="tok-s">&quot;Wizard&quot;</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; {:name &quot;Cirilla&quot;, :surname &quot;Fiona&quot;, :occupation &quot;Wizard&quot;}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, it just so happens that the order was preserved, but if you have many keys, you will see that
the order is not preserved.</p>
</div>
<div class="paragraph">
<p>Maps associate keys to values and, as such, are an associative data structure. They support adding associations with <code>assoc</code> and,
unlike vectors, removing them with <code>dissoc</code>. <code>assoc</code> will also update the value of an existing key. Let&#8217;s explore these functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">}</span> <span class="tok-ss">:surname</span> <span class="tok-s">&quot;Fiona&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:name &quot;Cirilla&quot;, :surname &quot;Fiona&quot;}</span>
<span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">}</span> <span class="tok-ss">:name</span> <span class="tok-s">&quot;Alfonso&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:name &quot;Alfonso&quot;}</span>
<span class="tok-p">(</span><span class="tok-nb">dissoc </span><span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">}</span> <span class="tok-ss">:name</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Maps are also functions of their keys, returning the values related to the given keys. Unlike vectors, they return <code>nil</code> if we supply
a key that is not present in the map:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">({</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">}</span> <span class="tok-ss">:name</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Cirilla&quot;</span>

<span class="tok-p">({</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">}</span> <span class="tok-ss">:surname</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>ClojureScript also offers sorted hash maps which behave like their unsorted versions but preserve order when iterating over them. We
can create a sorted map with default ordering with <code>sorted-map</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">sm</span> <span class="tok-p">(</span><span class="tok-nb">sorted-map </span><span class="tok-ss">:c</span> <span class="tok-mi">2</span> <span class="tok-ss">:b</span> <span class="tok-mi">1</span> <span class="tok-ss">:a</span> <span class="tok-mi">0</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; {:a 0, :b 1, :c 2}</span>

<span class="tok-p">(</span><span class="tok-nb">keys </span><span class="tok-nv">sm</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (:a :b :c)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If we need a custom ordering we can provide a comparator function to <code>sorted-map-by</code>, let&#8217;s see an example inverting the value
returned by the built-in <code>compare</code> function. Comparator functions take two items to compare
and return -1 (if the first item is less than the second), 0 (if they are equal),
or 1 (if the first item is greater than the second).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">reverse-compare</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-nv">b</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">compare</span> <span class="tok-nv">b</span> <span class="tok-nv">a</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">sm</span> <span class="tok-p">(</span><span class="tok-nb">sorted-map-by </span><span class="tok-nv">reverse-compare</span> <span class="tok-ss">:a</span> <span class="tok-mi">0</span> <span class="tok-ss">:b</span> <span class="tok-mi">1</span> <span class="tok-ss">:c</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; {:c 2, :b 1, :a 0}</span>

<span class="tok-p">(</span><span class="tok-nb">keys </span><span class="tok-nv">sm</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (:c :b :a)</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sets-2"><a class="link" href="#sets-2">Sets</a></h5>
<div class="paragraph">
<p>Sets in ClojureScript have literal syntax as values enclosed in <code>#{}</code> and they can be created with the <code>set</code> constructor. They are
unordered collections of values without duplicates.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">set?</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-sc">\a</span> <span class="tok-sc">\e</span> <span class="tok-sc">\i</span> <span class="tok-sc">\o</span> <span class="tok-sc">\u</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">set </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; #{1 2 3}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Set literals cannot contain duplicate values. If you accidentally write a set literal with duplicates an error will be thrown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">}</span>
<span class="tok-c1">;; clojure.lang.ExceptionInfo: Duplicate key: 1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are many operations that can be performed with sets, although they are located in the <code>clojure.set</code> namespace and thus
need to be imported. You&#8217;ll learn <a href="#namespace-section">the details of namespacing</a> later; for now, you only need to know that
we are loading a namespace called <code>clojure.set</code> and binding it to the <code>s</code> symbol.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">clojure.set</span> <span class="tok-ss">:as</span> <span class="tok-nv">s</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">danish-vowels</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-sc">\a</span> <span class="tok-sc">\e</span> <span class="tok-sc">\i</span> <span class="tok-sc">\o</span> <span class="tok-sc">\u</span> <span class="tok-sc">\æ</span> <span class="tok-sc">\ø</span> <span class="tok-sc">\å</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; #{&quot;a&quot; &quot;e&quot; &quot;å&quot; &quot;æ&quot; &quot;i&quot; &quot;o&quot; &quot;u&quot; &quot;ø&quot;}</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">spanish-vowels</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-sc">\a</span> <span class="tok-sc">\e</span> <span class="tok-sc">\i</span> <span class="tok-sc">\o</span> <span class="tok-sc">\u</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; #{&quot;a&quot; &quot;e&quot; &quot;i&quot; &quot;o&quot; &quot;u&quot;}</span>

<span class="tok-p">(</span><span class="tok-nf">s/difference</span> <span class="tok-nv">danish-vowels</span> <span class="tok-nv">spanish-vowels</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{&quot;å&quot; &quot;æ&quot; &quot;ø&quot;}</span>

<span class="tok-p">(</span><span class="tok-nf">s/union</span> <span class="tok-nv">danish-vowels</span> <span class="tok-nv">spanish-vowels</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{&quot;a&quot; &quot;e&quot; &quot;å&quot; &quot;æ&quot; &quot;i&quot; &quot;o&quot; &quot;u&quot; &quot;ø&quot;}</span>

<span class="tok-p">(</span><span class="tok-nf">s/intersection</span> <span class="tok-nv">danish-vowels</span> <span class="tok-nv">spanish-vowels</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{&quot;a&quot; &quot;e&quot; &quot;i&quot; &quot;o&quot; &quot;u&quot;}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A nice property of immutable sets is that they can be nested. Languages that have mutable sets can end up containing duplicate values,
but that can&#8217;t happen in ClojureScript. In fact, all ClojureScript data structures can be nested arbitrarily due to immutability.</p>
</div>
<div class="paragraph">
<p>Sets also support the generic <code>conj</code> operation just like every other collection does.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">spanish-vowels</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-sc">\a</span> <span class="tok-sc">\e</span> <span class="tok-sc">\i</span> <span class="tok-sc">\o</span> <span class="tok-sc">\u</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; #{&quot;a&quot; &quot;e&quot; &quot;i&quot; &quot;o&quot; &quot;u&quot;}</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">danish-vowels</span> <span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">spanish-vowels</span> <span class="tok-sc">\æ</span> <span class="tok-sc">\ø</span> <span class="tok-sc">\å</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #{&quot;a&quot; &quot;e&quot; &quot;i&quot; &quot;o&quot; &quot;u&quot; &quot;æ&quot; &quot;ø&quot; &quot;å&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">}</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{1 3 2}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Sets act as read-only associative data that associates the values it contains to themselves. Since every value except <code>nil</code> and <code>false</code>
is truthy in ClojureScript, we can use sets as predicate functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">vowels</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-sc">\a</span> <span class="tok-sc">\e</span> <span class="tok-sc">\i</span> <span class="tok-sc">\o</span> <span class="tok-sc">\u</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; #{&quot;a&quot; &quot;e&quot; &quot;i&quot; &quot;o&quot; &quot;u&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">get </span><span class="tok-nv">vowels</span> <span class="tok-sc">\b</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nb">contains? </span><span class="tok-nv">vowels</span> <span class="tok-sc">\b</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>

<span class="tok-p">(</span><span class="tok-nf">vowels</span> <span class="tok-sc">\a</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;a&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">vowels</span> <span class="tok-sc">\z</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-nv">vowels</span> <span class="tok-s">&quot;Hound dog&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (&quot;o&quot; &quot;u&quot; &quot;o&quot;)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Sets have a sorted counterpart like maps do that are created using the functions <code>sorted-set</code> and <code>sorted-set-by</code> which are analogous to map&#8217;s <code>sorted-map</code> and <code>sorted-map-by</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">unordered-set</span> <span class="tok-o">#</span><span class="tok-p">{[</span><span class="tok-mi">0</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">1</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">2</span><span class="tok-p">]})</span>
<span class="tok-c1">;; =&gt; #{[0] [2] [1]}</span>

<span class="tok-p">(</span><span class="tok-nb">seq </span><span class="tok-nv">unordered-set</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; ([0] [2] [1])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ordered-set</span> <span class="tok-p">(</span><span class="tok-nb">sorted-set </span><span class="tok-p">[</span><span class="tok-mi">0</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">1</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">2</span><span class="tok-p">]))</span>
<span class="tok-c1">;; =&gt;# {[0] [1] [2]}</span>

<span class="tok-p">(</span><span class="tok-nb">seq </span><span class="tok-nv">ordered-set</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; ([0] [1] [2])</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="queues"><a class="link" href="#queues">Queues</a></h5>
<div class="paragraph">
<p>ClojureScript also provides a persistent and immutable queue. Queues are not used as pervasively as other collection types.  They can be created using the <code>#queue []</code> literal syntax, but there are no convenient constructor functions for them.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">pq</span> <span class="tok-o">#</span><span class="tok-nv">queue</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; #queue [1 2 3]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>conj</code> to add values to a queue adds items onto the rear:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">pq</span> <span class="tok-o">#</span><span class="tok-nv">queue</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; #queue [1 2 3]</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">pq</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #queue [1 2 3 4 5]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A thing to bear in mind about queues is that the stack operations don&#8217;t follow the usual stack semantics (pushing and popping from the same end). <code>pop</code> takes values from the front position, and <code>conj</code> pushes (appends) elements to the back.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">pq</span> <span class="tok-o">#</span><span class="tok-nv">queue</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; #queue [1 2 3]</span>

<span class="tok-p">(</span><span class="tok-nb">peek </span><span class="tok-nv">pq</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nb">pop </span><span class="tok-nv">pq</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #queue [2 3]</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">pq</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #queue [1 2 3 4]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Queues are not as frequently used as lists or vectors, but it is good to know that they are available in ClojureScript, as they may occasionally come in handy.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="destructuring-section"><a class="link" href="#destructuring-section">3.8. Destructuring</a></h3>
<div class="paragraph">
<p>Destructuring, as its name suggests, is a way of taking apart structured data such as collections
and focusing on individual parts of them. ClojureScript offers a concise syntax for destructuring
both indexed sequences and associative data structures that can be used any place where bindings
are declared.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see an example of what destructuring is useful for that will help us understand the previous
statements better. Imagine that you have a sequence but are only interested in the first and third
item. You could get a reference to them easily with the <code>nth</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">v</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]</span>
      <span class="tok-nv">fst</span> <span class="tok-p">(</span><span class="tok-nb">nth </span><span class="tok-nv">v</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
      <span class="tok-nv">thrd</span> <span class="tok-p">(</span><span class="tok-nb">nth </span><span class="tok-nv">v</span> <span class="tok-mi">2</span><span class="tok-p">)]</span>
  <span class="tok-p">[</span><span class="tok-nv">thrd</span> <span class="tok-nv">fst</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [2 0]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, the previous code is overly verbose. Destructuring lets us extract values of indexed
sequences more succintly using a vector on the left-hand side of a binding:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[[</span><span class="tok-nv">fst</span> <span class="tok-nv">_</span> <span class="tok-nv">thrd</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]]</span>
  <span class="tok-p">[</span><span class="tok-nv">thrd</span> <span class="tok-nv">fst</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [2 0]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, <code>[fst _ thrd]</code> is a destructuring form. It is represented as a vector and
used for binding indexed values to the symbols <code>fst</code> and <code>thrd</code>, corresponding to the index <code>0</code>
and <code>2</code>, respectively. The <code>_</code> symbol is used as a placeholder for indexes we are not interested
in — in this case <code>1</code>.</p>
</div>
<div class="paragraph">
<p>Note that destructuring is not limited to the <code>let</code> binding form; it works in almost every place
where we bind values to symbols such as in the <code>for</code> and <code>doseq</code> special forms or in function
arguments. We can write a function that takes a pair and swaps its positions very concisely using
destructuring syntax in function arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">swap-pair</span> <span class="tok-p">[[</span><span class="tok-nv">fst</span> <span class="tok-nv">snd</span><span class="tok-p">]]</span>
  <span class="tok-p">[</span><span class="tok-nv">snd</span> <span class="tok-nv">fst</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">swap-pair</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [2 1]</span>

<span class="tok-p">(</span><span class="tok-nf">swap-pair</span> <span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; [4 3]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Positional destructuring with vectors is quite handy for taking indexed values out of sequences,
but sometimes we don&#8217;t want to discard the rest of the elements in the sequence when destructuring.
Similarly to how <code>&amp;</code> is used for accepting variadic function arguments, the ampersand can be used
inside a vector destructuring form for grouping together the rest of a sequence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[[</span><span class="tok-nv">fst</span> <span class="tok-nv">snd</span> <span class="tok-o">&amp;</span> <span class="tok-nv">more</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">10</span><span class="tok-p">)]</span>
  <span class="tok-p">{</span><span class="tok-ss">:first</span> <span class="tok-nv">fst</span>
   <span class="tok-ss">:snd</span> <span class="tok-nv">snd</span>
   <span class="tok-ss">:rest</span> <span class="tok-nv">more</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; {:first 0, :snd 1, :rest (2 3 4 5 6 7 8 9)}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how the value in the <code>0</code> index got bound to <code>fst</code>, the value in the <code>1</code> index got bound to
<code>snd</code>, and the sequence of elements from <code>2</code> onwards got bound to the <code>more</code> symbol.</p>
</div>
<div class="paragraph">
<p>We may still be interested in a data structure as a whole even when we are destructuring it. This
can be achieved with the <code>:as</code> keyword. If used inside a destructuring form, the original data
structure is bound to the symbol following that keyword:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[[</span><span class="tok-nv">fst</span> <span class="tok-nv">snd</span> <span class="tok-o">&amp;</span> <span class="tok-nv">more</span> <span class="tok-ss">:as</span> <span class="tok-nv">original</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">10</span><span class="tok-p">)]</span>
  <span class="tok-p">{</span><span class="tok-ss">:first</span> <span class="tok-nv">fst</span>
   <span class="tok-ss">:snd</span> <span class="tok-nv">snd</span>
   <span class="tok-ss">:rest</span> <span class="tok-nv">more</span>
   <span class="tok-ss">:original</span> <span class="tok-nv">original</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; {:first 0, :snd 1, :rest (2 3 4 5 6 7 8 9), :original (0 1 2 3 4 5 6 7 8 9)}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Not only can indexed sequences be destructured, but associative data can also be destructured. Its
destructuring binding form is represented as a map instead of a vector, where the keys are the
symbols we want to bind values to and the values are the keys that we want to look up in the
associative data structure. Let&#8217;s see an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-nv">language</span> <span class="tok-ss">:language</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">}]</span>
  <span class="tok-nv">language</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;ClojureScript&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, we are extracting the value associated with the <code>:language</code> key and binding
it to the <code>language</code> symbol. When looking up keys that are not present, the symbol will get bound
to <code>nil</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-nb">name </span><span class="tok-ss">:name</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">}]</span>
  <span class="tok-nv">name</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Associative destructuring lets us give default values to bindings which will be used if the key
isn&#8217;t found in the data structure we are taking apart. A map following the <code>:or</code> keyword is used
for default values as the following examples show:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-nb">name </span><span class="tok-ss">:name</span> <span class="tok-ss">:or</span> <span class="tok-p">{</span><span class="tok-nb">name </span><span class="tok-s">&quot;Anonymous&quot;</span><span class="tok-p">}}</span> <span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">}]</span>
  <span class="tok-nv">name</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Anonymous&quot;</span>

<span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-nb">name </span><span class="tok-ss">:name</span> <span class="tok-ss">:or</span> <span class="tok-p">{</span><span class="tok-nb">name </span><span class="tok-s">&quot;Anonymous&quot;</span><span class="tok-p">}}</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">}]</span>
  <span class="tok-nv">name</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Cirilla&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Associative destructuring also supports binding the original data structure to a symbol placed
after the <code>:as</code> keyword:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-nb">name </span><span class="tok-ss">:name</span> <span class="tok-ss">:as</span> <span class="tok-nv">person</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span> <span class="tok-ss">:age</span> <span class="tok-mi">49</span><span class="tok-p">}]</span>
  <span class="tok-p">[</span><span class="tok-nb">name </span><span class="tok-nv">person</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [&quot;Cirilla&quot; {:name &quot;Cirilla&quot; :age 49}]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Keywords aren&#8217;t the only things that can be the keys of associative data structures.
Numbers, strings, symbols and many other data structures can be used as keys, so we
can destructure using those, too. Note that we need to quote the symbols to prevent
them from being resolved as a var lookup:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-nv">one</span> <span class="tok-mi">1</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-mi">0</span> <span class="tok-s">&quot;zero&quot;</span> <span class="tok-mi">1</span> <span class="tok-s">&quot;one&quot;</span><span class="tok-p">}]</span>
  <span class="tok-nv">one</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;one&quot;</span>

<span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-nb">name </span><span class="tok-s">&quot;name&quot;</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-s">&quot;name&quot;</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">}]</span>
  <span class="tok-nv">name</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Cirilla&quot;</span>

<span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-nv">lang</span> <span class="tok-ss">&#39;language</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">&#39;language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">}]</span>
  <span class="tok-nv">lang</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;ClojureScript&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the values corresponding to keys are usually bound to their equivalent symbol representation
(for example, when binding the value of <code>:language</code> to the symbol <code>language</code>) and keys are usually
keywords, strings, or symbols, ClojureScript offers shorthand syntax for these cases.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll show examples of all of these, starting with destructuring keywords using <code>:keys</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-ss">:keys</span> <span class="tok-p">[</span><span class="tok-nb">name </span><span class="tok-nv">surname</span><span class="tok-p">]}</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span> <span class="tok-ss">:surname</span> <span class="tok-s">&quot;Fiona&quot;</span><span class="tok-p">}]</span>
  <span class="tok-p">[</span><span class="tok-nb">name </span><span class="tok-nv">surname</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [&quot;Cirilla&quot; &quot;Fiona&quot;]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see in the example, if we use the <code>:keys</code> keyword and associate it with a vector of
symbols in a binding form, the values corresponding to the keywordized version of the symbols will
be bound to them. The <code>{:keys [name surname]}</code> destructuring is equivalent to
<code>{name :name surname :surname}</code>, only shorter.</p>
</div>
<div class="paragraph">
<p>The string and symbol shorthand syntax works exactly like <code>:keys</code>, but using the <code>:strs</code> and <code>:syms</code>
keywords respectively:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-ss">:strs</span> <span class="tok-p">[</span><span class="tok-nb">name </span><span class="tok-nv">surname</span><span class="tok-p">]}</span> <span class="tok-p">{</span><span class="tok-s">&quot;name&quot;</span> <span class="tok-s">&quot;Cirilla&quot;</span> <span class="tok-s">&quot;surname&quot;</span> <span class="tok-s">&quot;Fiona&quot;</span><span class="tok-p">}]</span>
  <span class="tok-p">[</span><span class="tok-nb">name </span><span class="tok-nv">surname</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [&quot;Cirilla&quot; &quot;Fiona&quot;]</span>

<span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-ss">:syms</span> <span class="tok-p">[</span><span class="tok-nb">name </span><span class="tok-nv">surname</span><span class="tok-p">]}</span> <span class="tok-p">{</span><span class="tok-ss">&#39;name</span> <span class="tok-s">&quot;Cirilla&quot;</span> <span class="tok-ss">&#39;surname</span> <span class="tok-s">&quot;Fiona&quot;</span><span class="tok-p">}]</span>
  <span class="tok-p">[</span><span class="tok-nb">name </span><span class="tok-nv">surname</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [&quot;Cirilla&quot; &quot;Fiona&quot;]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An interesting property of destructuring is that we can nest destructuring forms arbitrarily, which
makes code that accesses nested data on a collection very easy to understand, as it mimics the
collection&#8217;s structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{[</span><span class="tok-nv">fst</span> <span class="tok-nv">snd</span><span class="tok-p">]</span> <span class="tok-ss">:languages</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">:languages</span> <span class="tok-p">[</span><span class="tok-s">&quot;ClojureScript&quot;</span> <span class="tok-s">&quot;Clojure&quot;</span><span class="tok-p">]}]</span>
  <span class="tok-p">[</span><span class="tok-nv">snd</span> <span class="tok-nv">fst</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [&quot;Clojure&quot; &quot;ClojureScript&quot;]</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="namespace-section"><a class="link" href="#namespace-section">3.9. Namespaces</a></h3>
<div class="sect3">
<h4 id="defining-a-namespace"><a class="link" href="#defining-a-namespace">3.9.1. Defining a namespace</a></h4>
<div class="paragraph">
<p>The <em>namespace</em> is ClojureScript&#8217;s fundamental unit of code modularity. Namespaces are analogous to Java packages or
Ruby and Python modules and can be defined with the <code>ns</code> macro. If you have ever looked at a little bit of
ClojureScript source, you may have noticed something like this at the beginning of the file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">myapp.core</span>
  <span class="tok-s">&quot;Some docstring for the namespace.&quot;</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">x</span> <span class="tok-s">&quot;hello&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Namespaces are dynamic, meaning you can create one at any time. However, the convention is to have one namespace
per file. Naturally, a namespace definition is usually at the beginning of the file, followed by an optional
docstring.</p>
</div>
<div class="paragraph">
<p>Previously we have explained vars and symbols. Every var that you define will be associated
with its namespace. If you do not define a concrete namespace, then the default one called "cljs.user" will be
used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">x</span> <span class="tok-s">&quot;hello&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&#39;cljs.user/x</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="loading-other-namespaces"><a class="link" href="#loading-other-namespaces">3.9.2. Loading other namespaces</a></h4>
<div class="paragraph">
<p>Defining a namespace and the vars in it is really easy, but it&#8217;s not very useful if we can&#8217;t
use symbols from other namespaces. For this purpose, the <code>ns</code> macro offers a simple way to load other
namespaces.</p>
</div>
<div class="paragraph">
<p>Observe the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">myapp.main</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-nv">myapp.core</span>
            <span class="tok-nv">clojure.string</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">clojure.string/upper-case</span> <span class="tok-nv">myapp.core/x</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;HELLO&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can observe, we are using fully qualified names (namespace + var name) for access to vars and
functions from different namespaces.</p>
</div>
<div class="paragraph">
<p>While this will let you access other namespaces, it&#8217;s also repetitive and overly verbose. It will be especially
uncomfortable if the name of a namespace is very long. To solve that, you can use the <code>:as</code> directive to
create an additional (usually shorter) alias to the namespace.
This is how it can be done:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">myapp.main</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">myapp.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">core</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">clojure.string</span> <span class="tok-ss">:as</span> <span class="tok-nv">str</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nf">str/upper-case</span> <span class="tok-nv">core/x</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;HELLO&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Additionally, <em>ClojureScript</em> offers a simple way to refer to specific vars or functions from a concrete namespace using the <code>:refer</code> directive, followed by a sequence of symbols that will
refer to vars in the namespace. Effectively, it is as if those vars and
functions are now part of your namespace, and you do not need to qualify them at all.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">myapp.main</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">clojure.string</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">upper-case</span><span class="tok-p">]]))</span>
<span class="tok-p">(</span><span class="tok-nf">upper-case</span> <span class="tok-nv">x</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;HELLO&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And finally, you should know that everything located in the <code>cljs.core</code> namespace is automatically
loaded and you should not require it explicitly. Sometimes you may want to declare vars that will clash
with some others defined in the <code>cljs.core</code> namespace. To do this, the <code>ns</code> macro offers another directive that
allows you to exclude specific symbols and prevent them from being automatically loaded.</p>
</div>
<div class="paragraph">
<p>Observe the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">myapp.main</span>
  <span class="tok-p">(</span><span class="tok-ss">:refer-clojure</span> <span class="tok-ss">:exclude</span> <span class="tok-p">[</span><span class="tok-nv">min</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">min</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">&gt; </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)</span>
    <span class="tok-nv">y</span>
    <span class="tok-nv">x</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ns</code> macro also has other directives for loading host classes (<code>:import</code>) and macros
(<code>:refer-macros</code>), but these are explained in other sections.</p>
</div>
</div>
<div class="sect3">
<h4 id="namespaces-and-file-names"><a class="link" href="#namespaces-and-file-names">3.9.3. Namespaces and File Names</a></h4>
<div class="paragraph">
<p>When you have a namespace like <code>myapp.core</code>, the code must be in a file named  <em>core.cljs</em> inside the
<em>myapp</em> directory.  So, the preceding examples with namespaces <code>myapp.core</code> and <code>myapp.main</code> would be
found in project with a file structure like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>myapp
└── src
    └── myapp
        ├── core.cljs
        └── main.cljs</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="abstractions-and-polymorphism"><a class="link" href="#abstractions-and-polymorphism">3.10. Abstractions and Polymorphism</a></h3>
<div class="paragraph">
<p>I&#8217;m sure that at more than one time you have found yourself in this situation: you have defined a great
abstraction (using interfaces or something similar) for your "business logic", and you have found
the need to deal with another module over which you have absolutely no control, and you probably
were thinking of creating adapters, proxies, and other approaches that imply a great amount
of additional complexity.</p>
</div>
<div class="paragraph">
<p>Some dynamic languages allow "monkey-patching"; languages where the classes are open and any
method can be defined and redefined at any time. Also, it is well known that this technique is a very
bad practice.</p>
</div>
<div class="paragraph">
<p>We can not trust languages that allow you to silently overwrite methods that you are using when you
import third party libraries; you cannot expect consistent behavior when this happens.</p>
</div>
<div class="paragraph">
<p>These symptoms are commonly called the "expression problem";
see <a href="http://en.wikipedia.org/wiki/Expression_problem" class="bare">http://en.wikipedia.org/wiki/Expression_problem</a> for more details</p>
</div>
<div class="sect3">
<h4 id="protocols"><a class="link" href="#protocols">3.10.1. Protocols</a></h4>
<div class="paragraph">
<p>The <em>ClojureScript</em> primitive for defining "interfaces" is called a protocol. A protocol consists of
a name and set of functions. All the functions have at least one argument corresponding to the
<code>this</code> in JavaScript or <code>self</code> in Python.</p>
</div>
<div class="paragraph">
<p>Protocols provide a type-based polymorphism, and the dispatch is always done by the
first argument (equivalent to JavaScript’s <code>this</code>, as previously mentioned).</p>
</div>
<div class="paragraph">
<p>A protocol looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">myapp.testproto</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defprotocol </span><span class="tok-nv">IProtocolName</span>
  <span class="tok-s">&quot;A docstring describing the protocol.&quot;</span>
  <span class="tok-p">(</span><span class="tok-nf">sample-method</span> <span class="tok-p">[</span><span class="tok-nv">this</span><span class="tok-p">]</span> <span class="tok-s">&quot;A doc string of the function associated with the protocol.&quot;</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
the "I" prefix is commonly used to designate the separation of protocols and types. In the Clojure
community, there are many different opinions about how the "I" prefix should be used. In our opinion, it is an
acceptable solution to avoid name clashing and possible confusion.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>From the user perspective, protocol functions are simply plain functions defined in the namespace
where the protocol is defined. As you can intuit, this namespacing of protocols allows us to avoid
any conflict between different protocols implemented for the same type.</p>
</div>
<div class="paragraph">
<p>Here is an example. Let&#8217;s create a protocol called <code>IInvertible</code> for data that can be "inverted".
It will have a single method named <code>invert</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">proto.testproto</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defprotocol </span><span class="tok-nv">IInvertible</span>
  <span class="tok-s">&quot;This is a protocol for data types that are &#39;invertible&#39;&quot;</span>
    <span class="tok-p">(</span><span class="tok-nf">invert</span> <span class="tok-p">[</span><span class="tok-nv">this</span><span class="tok-p">]</span> <span class="tok-s">&quot;Invert the given item.&quot;</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="extending-existing-types"><a class="link" href="#extending-existing-types">Extending existing types</a></h5>
<div class="paragraph">
<p>One of the big strengths of protocols is the ability to extend existing and maybe third party types,
and this operation can be done in different ways. The majority of time you will tend to use
the <strong>extend-protocol</strong> or the <strong>extend-type</strong> macros.</p>
</div>
<div class="paragraph">
<p>This is an example of how the <strong>extend-type</strong> macro can be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">TypeA</span>
  <span class="tok-nv">ProtocolA</span>
  <span class="tok-p">(</span><span class="tok-nf">function-from-protocol-a</span> <span class="tok-p">[</span><span class="tok-nv">this</span><span class="tok-p">]</span>
    <span class="tok-c1">;; implementation here</span>
    <span class="tok-p">)</span>

  <span class="tok-nv">ProtocolB</span>
  <span class="tok-p">(</span><span class="tok-nf">function-from-protocol-b-1</span> <span class="tok-p">[</span><span class="tok-nv">this</span> <span class="tok-nv">parameter1</span><span class="tok-p">]</span>
    <span class="tok-c1">;; implementation here</span>
    <span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">function-from-protocol-b-2</span> <span class="tok-p">[</span><span class="tok-nv">this</span> <span class="tok-nv">parameter1</span> <span class="tok-nv">parameter2</span><span class="tok-p">]</span>
    <span class="tok-c1">;; implementation here</span>
    <span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can observe that with <strong>extend-type</strong> you are extending a single type with different protocols
in a single expression.  Here is code that will extend the <code>number</code>, <code>string</code>, <code>List</code>, and
<code>PersistentVector</code> types to be "invertible".  For numbers, we define the inverse to be the
reciprocal of the number (or zero, if the number is zero). For strings, lists, and vectors,
the inverse is defined as the reverse of the input.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>(extend-type number
  IInvertible
  (invert [this] (if (zero? this) 0 (/ 1 this))))

(extend-type string
  IInvertible
  (invert [this] (apply str (reverse this))))

(extend-type List
  IInvertible
  (invert [this] (reverse this)))

(extend-type PersistentVector
  IInvertible
  (invert [this] (into [] (reverse this))))</pre>
</div>
</div>
<div class="paragraph">
<p>If you load in this code, you can see that it works:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">proto.testproto/invert</span> <span class="tok-s">&quot;abc&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;cba&quot;</span>
<span class="tok-p">(</span><span class="tok-nf">proto.testproto/invert</span> <span class="tok-mi">25</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0.04</span>
<span class="tok-p">(</span><span class="tok-nf">proto.testproto/invert</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0</span>
<span class="tok-p">(</span><span class="tok-nf">proto.testproto/invert</span> <span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; (3 2 1)</span>
<span class="tok-p">(</span><span class="tok-nf">proto.testproto/invert</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [3 2 1]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Admittedly, this is a somewhat contrived example. In <a href="#extend-type-section">the next section</a>
you will see how to extend an existing type.</p>
</div>
<div class="paragraph">
<p>In comparison, <strong>extend-protocol</strong> does the inverse;
given a protocol, it adds implementations for multiple types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-protocol</span> <span class="tok-nv">ProtocolA</span>
  <span class="tok-nv">TypeA</span>
  <span class="tok-p">(</span><span class="tok-nf">function-from-protocol-a</span> <span class="tok-p">[</span><span class="tok-nv">this</span><span class="tok-p">]</span>
    <span class="tok-c1">;; implementation here</span>
    <span class="tok-p">)</span>

  <span class="tok-nv">TypeB</span>
  <span class="tok-p">(</span><span class="tok-nf">function-from-protocol-a</span> <span class="tok-p">[</span><span class="tok-nv">this</span><span class="tok-p">]</span>
    <span class="tok-c1">;; implementation here</span>
    <span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Thus, the previous example could have been written equally well this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-protocol</span> <span class="tok-nv">IInvertible</span>
  <span class="tok-nv">number</span>
  <span class="tok-p">(</span><span class="tok-nf">invert</span> <span class="tok-p">[</span><span class="tok-nv">this</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">zero? </span><span class="tok-nv">this</span><span class="tok-p">)</span> <span class="tok-mi">0</span> <span class="tok-p">(</span><span class="tok-nb">/ </span><span class="tok-mi">1</span> <span class="tok-nv">this</span><span class="tok-p">)))</span>

  <span class="tok-nv">string</span>
  <span class="tok-p">(</span><span class="tok-nf">invert</span> <span class="tok-p">[</span><span class="tok-nv">this</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">apply str </span><span class="tok-p">(</span><span class="tok-nb">reverse </span><span class="tok-nv">this</span><span class="tok-p">)))</span>

  <span class="tok-nv">List</span>
  <span class="tok-p">(</span><span class="tok-nf">invert</span> <span class="tok-p">[</span><span class="tok-nv">this</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">reverse </span><span class="tok-nv">this</span><span class="tok-p">))</span>

  <span class="tok-nv">PersistentVector</span>
  <span class="tok-p">(</span><span class="tok-nf">invert</span> <span class="tok-p">[</span><span class="tok-nv">this</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">into </span><span class="tok-p">[]</span> <span class="tok-p">(</span><span class="tok-nb">reverse </span><span class="tok-nv">this</span><span class="tok-p">))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are other ways to extend a type with a protocol implementation, but they will be covered
in another section of this book.</p>
</div>
</div>
<div class="sect4">
<h5 id="participate-in-clojurescript-abstractions"><a class="link" href="#participate-in-clojurescript-abstractions">Participate in ClojureScript abstractions</a></h5>
<div class="paragraph">
<p>ClojureScript itself is built up on abstractions defined as protocols. Almost all behavior
in the <em>ClojureScript</em> language itself can be adapted to third party libraries. Let&#8217;s look at a
real life example.</p>
</div>
<div class="paragraph">
<p>In previous sections, we have explained the different kinds of built-in collections. For this example we
will use a <strong>set</strong>. See this snippet of code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">mynums</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">})</span>

<span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-nv">mynums</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span> <span class="tok-mi">1</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (1 2 1)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>What happened? In this case, the <em>set</em> type implements the <em>ClojureScript</em> internal
<code>IFn</code> protocol that represents an abstraction for functions or anything callable. This way it can be
used like a callable predicate in filter.</p>
</div>
<div class="paragraph">
<p>OK, but what happens if we want to use a regular expression as a predicate function for filtering
a collection of strings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-o">#</span><span class="tok-s">&quot;^foo&quot;</span> <span class="tok-p">[</span><span class="tok-s">&quot;haha&quot;</span> <span class="tok-s">&quot;foobar&quot;</span> <span class="tok-s">&quot;baz&quot;</span> <span class="tok-s">&quot;foobaz&quot;</span><span class="tok-p">])</span>
<span class="tok-c1">;; TypeError: Cannot call undefined</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The exception is raised because the <code>RegExp</code> type does not implement the <code>IFn</code> protocol
so it cannot behave like a callable, but that can be easily fixed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">js/RegExp</span>
  <span class="tok-nv">IFn</span>
  <span class="tok-p">(</span><span class="tok-nf">-invoke</span>
   <span class="tok-p">([</span><span class="tok-nv">this</span> <span class="tok-nv">a</span><span class="tok-p">]</span>
     <span class="tok-p">(</span><span class="tok-nb">re-find </span><span class="tok-nv">this</span> <span class="tok-nv">a</span><span class="tok-p">))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let’s analyze this:  we are extending the <code>js/RegExp</code> type so that it implements the <code>invoke</code> function in the
<code>IFn</code> protocol. To invoke a regular expression <code>a</code> as if it were a function, call the <code>re-find</code> function with
the object of the function and the pattern.</p>
</div>
<div class="paragraph">
<p>Now, you will be able use the regex instances as predicates in a filter operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-o">#</span><span class="tok-s">&quot;^foo&quot;</span> <span class="tok-p">[</span><span class="tok-s">&quot;haha&quot;</span> <span class="tok-s">&quot;foobar&quot;</span> <span class="tok-s">&quot;baz&quot;</span> <span class="tok-s">&quot;foobaz&quot;</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (&quot;foobar&quot; &quot;foobaz&quot;)</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="introspection-using-protocols"><a class="link" href="#introspection-using-protocols">Introspection using Protocols</a></h5>
<div class="paragraph">
<p><em>ClojureScript</em> comes with a useful function that allows runtime introspection: <code>satisfies?</code>. The
purpose of this function is to determine at runtime if some object (instance of some type) satisfies the
concrete protocol.</p>
</div>
<div class="paragraph">
<p>So, with the previous examples, if we check if a <code>set</code> instance satisfies an <strong>IFn</strong> protocol, it should
return <code>true</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">satisfies?</span> <span class="tok-nv">IFn</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="multimethods"><a class="link" href="#multimethods">3.10.2. Multimethods</a></h4>
<div class="paragraph">
<p>We have previously talked about protocols which solve a very common use case of polymorphism:
dispatch by type. But in some circumstances, the protocol approach can be limiting. And
here, <strong>multimethods</strong> come to the rescue.</p>
</div>
<div class="paragraph">
<p>These <strong>multimethods</strong> are not limited to type dispatch only; instead, they also offer dispatch
by types of multiple arguments and by value. They also allow ad-hoc hierarchies to be defined. Also,
like protocols, multimethods are an "Open System", so you or any third parties can extend a multimethod for
new types.</p>
</div>
<div class="paragraph">
<p>The basic constructions of <strong>multimethods</strong> are the <code>defmulti</code> and <code>defmethod</code> forms. The
<code>defmulti</code> form is used to create the multimethod with an initial dispatch function. This is
a model of what it looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defmulti </span><span class="tok-nv">say-hello</span>
  <span class="tok-s">&quot;A polymorphic function that return a greetings message</span>
<span class="tok-s">  depending on the language key with default lang as `:en`&quot;</span>
  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">param</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-ss">:locale</span> <span class="tok-nv">param</span><span class="tok-p">))</span>
  <span class="tok-ss">:default</span> <span class="tok-ss">:en</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The anonymous function defined within the <code>defmulti</code> form is a dispatch function. It will
be called in every call to the <code>say-hello</code> function and should return some kind of marker object
that will be used for dispatch. In our example, it returns the contents of the <code>:locale</code> key
of the first argument.</p>
</div>
<div class="paragraph">
<p>And finally, you should add implementations. That is done with the <code>defmethod</code> form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defmethod </span><span class="tok-nv">say-hello</span> <span class="tok-ss">:en</span>
  <span class="tok-p">[</span><span class="tok-nv">person</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">&quot;Hello &quot;</span> <span class="tok-p">(</span><span class="tok-ss">:name</span> <span class="tok-nv">person</span> <span class="tok-s">&quot;Anonymous&quot;</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-kd">defmethod </span><span class="tok-nv">say-hello</span> <span class="tok-ss">:es</span>
  <span class="tok-p">[</span><span class="tok-nv">person</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">&quot;Hola &quot;</span> <span class="tok-p">(</span><span class="tok-ss">:name</span> <span class="tok-nv">person</span> <span class="tok-s">&quot;Anónimo&quot;</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>So, if you execute that function over a hash map containing the <code>:locale</code> and optionally
the <code>:name</code> key, the multimethod will first call the dispatch function to determine the
dispatch value, then it will search for an implementation for that value. If an implementation
is found, the dispatcher will execute it. Otherwise, the dispatch will search for a default implementation
(if one is specified) and execute it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">say-hello</span> <span class="tok-p">{</span><span class="tok-ss">:locale</span> <span class="tok-ss">:es</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; &quot;Hola Anónimo&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">say-hello</span> <span class="tok-p">{</span><span class="tok-ss">:locale</span> <span class="tok-ss">:en</span> <span class="tok-ss">:name</span> <span class="tok-s">&quot;Ciri&quot;</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; &quot;Hello Ciri&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">say-hello</span> <span class="tok-p">{</span><span class="tok-ss">:locale</span> <span class="tok-ss">:fr</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; &quot;Hello Anonymous&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If the default implementation is not specified, an exception will be raised notifying you
that some value does not have an implementation for that multimethod.</p>
</div>
</div>
<div class="sect3">
<h4 id="hierarchies"><a class="link" href="#hierarchies">3.10.3. Hierarchies</a></h4>
<div class="paragraph">
<p>Hierarchies are <em>ClojureScript</em>’s way to let you build whatever relations that your
domain may require. Hierarchies are defined in term of relations between named objects,
such as symbols, keywords, or types.</p>
</div>
<div class="paragraph">
<p>Hierarchies can be defined globally or locally, depending on your needs. Like multimethods,
hierarchies are not limited to a single namespace. You can extend a hierarchy from any namespace,
not only from the one in which it is defined.</p>
</div>
<div class="paragraph">
<p>The global namespace is more limited, for good reasons. Keywords or symbols that are not namespaced can
not be used in the global hierarchy. That behavior helps prevent unexpected situations when
two or more third party libraries use the same symbol for different semantics.</p>
</div>
<div class="sect4">
<h5 id="defining-a-hierarchy"><a class="link" href="#defining-a-hierarchy">Defining a hierarchy</a></h5>
<div class="paragraph">
<p>The hierarchy relations should be established using the <code>derive</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">derive</span> <span class="tok-ss">::circle</span> <span class="tok-ss">::shape</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">derive</span> <span class="tok-ss">::box</span> <span class="tok-ss">::shape</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We have just defined a set of relationships between namespaced keywords. In this case the
<code>::circle</code> is a child of <code>::shape</code>, and <code>::box</code> is also a child of <code>::shape</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
The <code>::circle</code> keyword syntax is a shorthand for <code>:current.ns/circle</code>. So if you are executing
it in a REPL, <code>::circle</code> will be evaluated as <code>:cljs.user/circle</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="hierarchies-and-introspection"><a class="link" href="#hierarchies-and-introspection">Hierarchies and introspection</a></h5>
<div class="paragraph">
<p><em>ClojureScript</em> comes with a little toolset of functions that allows runtime introspection
of globally or locally defined hierarchies. This toolset consists of three functions:
<code>isa?</code>, <code>ancestors</code>, and <code>descendants</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see an example of how it can be used with the hierarchy defined in the previous example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">ancestors</span> <span class="tok-ss">::box</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{:cljs.user/shape}</span>

<span class="tok-p">(</span><span class="tok-nf">descendants</span> <span class="tok-ss">::shape</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{:cljs.user/circle :cljs.user/box}</span>

<span class="tok-p">(</span><span class="tok-nf">isa?</span> <span class="tok-ss">::box</span> <span class="tok-ss">::shape</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">isa?</span> <span class="tok-ss">::rect</span> <span class="tok-ss">::shape</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="locally-defined-hierarchies"><a class="link" href="#locally-defined-hierarchies">Locally defined hierarchies</a></h5>
<div class="paragraph">
<p>As we mentioned previously, in <em>ClojureScript</em> you also can define local hierarchies. This can be
done with the <code>make-hierarchy</code> function. Here is an example of how you can replicate the previous
example using a local hierarchy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">h</span> <span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">(</span><span class="tok-nf">make-hierarchy</span><span class="tok-p">)</span>
           <span class="tok-p">(</span><span class="tok-nf">derive</span> <span class="tok-ss">:box</span> <span class="tok-ss">:shape</span><span class="tok-p">)</span>
           <span class="tok-p">(</span><span class="tok-nf">derive</span> <span class="tok-ss">:circle</span> <span class="tok-ss">:shape</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you can use the same introspection functions with that locally defined hierarchy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">isa?</span> <span class="tok-nv">h</span> <span class="tok-ss">:box</span> <span class="tok-ss">:shape</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">isa?</span> <span class="tok-ss">:box</span> <span class="tok-ss">:shape</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can observe, in local hierarchies we can use normal (not namespace qualified) keywords,
and if we execute the <code>isa?</code> without passing the local hierarchy parameter, it returns <code>false</code>
as expected.</p>
</div>
</div>
<div class="sect4">
<h5 id="hierarchies-in-multimethods"><a class="link" href="#hierarchies-in-multimethods">Hierarchies in multimethods</a></h5>
<div class="paragraph">
<p>One of the big advantages of hierarchies is that they work very well together with multimethods.
This is because multimethods by default use the <code>isa?</code> function for the last step of dispatching.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see an example to clearly understand what that means. First, we define the multimethod with
the <code>defmulti</code> form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defmulti </span><span class="tok-nv">stringify-shape</span>
  <span class="tok-s">&quot;A function that prints a human readable representation</span>
<span class="tok-s">  of a shape keyword.&quot;</span>
  <span class="tok-nv">identity</span>
  <span class="tok-ss">:hierarchy</span> <span class="tok-o">#</span><span class="tok-ss">&#39;h</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>With the <code>:hierarchy</code> keyword parameter, we indicate to the multimethod what hierarchy we want to use;
if it is not specified, the global hierarchy will be used.</p>
</div>
<div class="paragraph">
<p>Second, we define an implementation for our multimethod using the <code>defmethod</code> form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defmethod </span><span class="tok-nv">stringify-shape</span> <span class="tok-ss">:box</span>
  <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
  <span class="tok-s">&quot;A box shape&quot;</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defmethod </span><span class="tok-nv">stringify-shape</span> <span class="tok-ss">:shape</span>
  <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
  <span class="tok-s">&quot;A generic shape&quot;</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defmethod </span><span class="tok-nv">stringify-shape</span> <span class="tok-ss">:default</span>
  <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
  <span class="tok-s">&quot;Unexpected object&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, let&#8217;s see what happens if we execute that function with a box:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">stringify-shape</span> <span class="tok-ss">:box</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;A box shape&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now everything works as expected; the multimethod executes the direct matching implementation
for the given parameter. Next, let&#8217;s see what happens if we execute the same function but with the <code>:circle</code>
keyword as the parameter which does not have the direct matching dispatch value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">stringify-shape</span> <span class="tok-ss">:circle</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;A generic shape&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The multimethod automatically resolves it using the provided hierarchy, and since <code>:circle</code> is
a descendant of <code>:shape</code>, the <code>:shape</code> implementation is executed.</p>
</div>
<div class="paragraph">
<p>Finally, if you give a keyword that isn&#8217;t part of the hierarchy, you get the <code>:default</code> implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">stringify-shape</span> <span class="tok-ss">:triangle</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Unexpected object&quot;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="data-types"><a class="link" href="#data-types">3.11. Data types</a></h3>
<div class="paragraph">
<p>Until now, we have used maps, sets, lists, and vectors to represent our data. And in most cases, this is a
really great approach. But sometimes we need to define our own types, and in this book we will
call them <strong>data types</strong>.</p>
</div>
<div class="paragraph">
<p>A data type provides the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A unique host-backed type, either named or anonymous.</p>
</li>
<li>
<p>The ability to implement protocols (inline).</p>
</li>
<li>
<p>Explicitly declared structure using fields or closures.</p>
</li>
<li>
<p>Map-like behavior (via records, see below).</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="deftype"><a class="link" href="#deftype">3.11.1. Deftype</a></h4>
<div class="paragraph">
<p>The most low-level construction in <em>ClojureScript</em> for creating your own types is the <code>deftype</code> macro. As a
demonstration, we will define a type called <code>User</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">deftype </span><span class="tok-nv">User</span> <span class="tok-p">[</span><span class="tok-nv">firstname</span> <span class="tok-nv">lastname</span><span class="tok-p">])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Once the type has been defined, we can create an instance of our <code>User</code>. In the
following example, the <code>.</code> after <code>User</code> indicates that we are calling a constructor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">person</span> <span class="tok-p">(</span><span class="tok-nf">User.</span> <span class="tok-s">&quot;Triss&quot;</span> <span class="tok-s">&quot;Merigold&quot;</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Its fields can be accessed using the prefix dot notation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">.-firstname</span> <span class="tok-nv">person</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Triss&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Types defined with <code>deftype</code> (and <code>defrecord</code>, which we will see later) create a host-backed class-like object
associated with the current namespace. For convenience, <em>ClojureScript</em> also defines a constructor function called
<code>&#8594;User</code> that can be imported using the <code>:require</code> directive.</p>
</div>
<div class="paragraph">
<p>We personally do not like this type of function, and we prefer to define our own constructors with more
idiomatic names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">make-user</span>
  <span class="tok-p">[</span><span class="tok-nv">firstname</span> <span class="tok-nv">lastname</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">User.</span> <span class="tok-nv">firstname</span> <span class="tok-nv">lastname</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We use this in our code instead of <code>&#8594;User</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="defrecord"><a class="link" href="#defrecord">3.11.2. Defrecord</a></h4>
<div class="paragraph">
<p>The record is a slightly higher-level abstraction for defining types in <em>ClojureScript</em> and should be
the preferred way to do it.</p>
</div>
<div class="paragraph">
<p>As we know, <em>ClojureScript</em> tends to use plain data types such as maps, but in most cases we need
a named type to represent the entities of our application. Here come the records.</p>
</div>
<div class="paragraph">
<p>A record is a data type that implements the map protocol and therefore can be used like any other map.
And since records are also proper types, they support type-based polymorphism through protocols.</p>
</div>
<div class="paragraph">
<p>In summary: with records, we have the best of both worlds, maps that can play in different
abstractions.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start defining the <code>User</code> type but using records:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defrecord </span><span class="tok-nv">User</span> <span class="tok-p">[</span><span class="tok-nv">firstname</span> <span class="tok-nv">lastname</span><span class="tok-p">])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It looks really similar to the <code>deftype</code> syntax; in fact, it uses <code>deftype</code> behind the scenes as a low-level
primitive for defining types.</p>
</div>
<div class="paragraph">
<p>Now, look at the difference with raw types for access to its fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">person</span> <span class="tok-p">(</span><span class="tok-nf">User.</span> <span class="tok-s">&quot;Yennefer&quot;</span> <span class="tok-s">&quot;of Vengerberg&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-ss">:firstname</span> <span class="tok-nv">person</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Yennefer&quot;</span>

<span class="tok-p">(</span><span class="tok-nb">get </span><span class="tok-nv">person</span> <span class="tok-ss">:firstname</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Yennefer&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As we mentioned previously, records are maps and act like them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">map? </span><span class="tok-nv">person</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And like maps, they support extra fields that are not initially defined:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">person2</span> <span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-nv">person</span> <span class="tok-ss">:age</span> <span class="tok-mi">92</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-ss">:age</span> <span class="tok-nv">person2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 92</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As we can see, the <code>assoc</code> function works as expected and returns a new instance of the same
type but with new key value pair. But take care with <code>dissoc</code>! Its behavior with records is slightly
different than with maps; it will return a new record if the field being dissociated is an optional
field, but it will return a plain map if you dissociate a mandatory field.</p>
</div>
<div class="paragraph">
<p>Another difference with maps is that records do not act like functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">plain-person</span> <span class="tok-p">{</span><span class="tok-ss">:firstname</span> <span class="tok-s">&quot;Yennefer&quot;</span>, <span class="tok-ss">:lastname</span> <span class="tok-s">&quot;of Vengerberg&quot;</span><span class="tok-p">})</span>

<span class="tok-p">(</span><span class="tok-nf">plain-person</span> <span class="tok-ss">:firstname</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Yennefer&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">person</span> <span class="tok-ss">:firstname</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; person.User does not implement IFn protocol.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For convenience, the <code>defrecord</code> macro, like <code>deftype</code>, exposes a <code>&#8594;User</code> function, as well as an additional
<code>map&#8594;User</code> constructor function. We have the same opinion about that constructor as with
<code>deftype</code> defined ones: we recommend defining your own instead of using the other ones. But as they exist, let’s see
how they can be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">cirilla</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;User</span> <span class="tok-s">&quot;Cirilla&quot;</span> <span class="tok-s">&quot;Fiona&quot;</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">yen</span> <span class="tok-p">(</span><span class="tok-nf">map-&gt;User</span> <span class="tok-p">{</span><span class="tok-ss">:firstname</span> <span class="tok-s">&quot;Yennefer&quot;</span>
                     <span class="tok-ss">:lastname</span> <span class="tok-s">&quot;of Vengerberg&quot;</span><span class="tok-p">}))</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="implementing-protocols"><a class="link" href="#implementing-protocols">3.11.3. Implementing protocols</a></h4>
<div class="paragraph">
<p>Both type definition primitives that we have seen so far allow inline implementations for protocols
(explained in a previous section). Let&#8217;s define one for example purposes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defprotocol </span><span class="tok-nv">IUser</span>
  <span class="tok-s">&quot;A common abstraction for working with user types.&quot;</span>
  <span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span> <span class="tok-s">&quot;Get the full name of the user.&quot;</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, you can define a type with inline implementation for an abstraction, in our case the <code>IUser</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defrecord </span><span class="tok-nv">User</span> <span class="tok-p">[</span><span class="tok-nv">firstname</span> <span class="tok-nv">lastname</span><span class="tok-p">]</span>
  <span class="tok-nv">IUser</span>
  <span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-nv">firstname</span> <span class="tok-s">&quot; &quot;</span> <span class="tok-nv">lastname</span><span class="tok-p">)))</span>

<span class="tok-c1">;; Create an instance.</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">user</span> <span class="tok-p">(</span><span class="tok-nf">User.</span> <span class="tok-s">&quot;Yennefer&quot;</span> <span class="tok-s">&quot;of Vengerberg&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-nv">user</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Yennefer of Vengerberg&quot;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reify"><a class="link" href="#reify">3.11.4. Reify</a></h4>
<div class="paragraph">
<p>The <code>reify</code> macro is an <em>ad hoc constructor</em> you can use to create objects without pre-defining a type.
Protocol implementations are supplied the same as <code>deftype</code> and <code>defrecord</code>, but in contrast, <code>reify</code>
does not have accessible fields.</p>
</div>
<div class="paragraph">
<p>This is how we can emulate an instance of the user type that plays well with the <code>IUser</code> abstraction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">user</span>
  <span class="tok-p">[</span><span class="tok-nv">firstname</span> <span class="tok-nv">lastname</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">reify</span>
    <span class="tok-nv">IUser</span>
    <span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
      <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-nv">firstname</span> <span class="tok-s">&quot; &quot;</span> <span class="tok-nv">lastname</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">yen</span> <span class="tok-p">(</span><span class="tok-nf">user</span> <span class="tok-s">&quot;Yennefer&quot;</span> <span class="tok-s">&quot;of Vengerberg&quot;</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-nv">yen</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Yennefer of Vengerberg&quot;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="specify"><a class="link" href="#specify">3.11.5. Specify</a></h4>
<div class="paragraph">
<p><code>specify!</code> is an advanced alternative to <code>reify</code>, allowing you to add protocol
implementations to an existing JavaScript object.  This can be useful if
you want to graft protocols onto a JavaScript library&#8217;s components.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">obj</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">{})</span>

<span class="tok-p">(</span><span class="tok-nf">specify!</span> <span class="tok-nv">obj</span>
  <span class="tok-nv">IUser</span>
  <span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
    <span class="tok-s">&quot;my full name&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-nv">obj</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;my full name&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>specify</code> is an immutable version of <code>specify!</code> that can be used on immutable,
copyable values implementing <code>ICloneable</code> (e.g. ClojureScript collections).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a</span> <span class="tok-p">{})</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">b</span> <span class="tok-p">(</span><span class="tok-nf">specify</span> <span class="tok-nv">a</span>
         <span class="tok-nv">IUser</span>
         <span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
           <span class="tok-s">&quot;my full name&quot;</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-nv">a</span><span class="tok-p">)</span>
<span class="tok-c1">;; Error: No protocol method IUser.full-name defined for type cljs.core/PersistentArrayMap: {}</span>

<span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-nv">b</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;my full name&quot;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="host-interoperability"><a class="link" href="#host-interoperability">3.12. Host interoperability</a></h3>
<div class="paragraph">
<p><em>ClojureScript</em>, in the same way as its brother Clojure, is designed to be a "guest" language. This means
that the design of the language works well on top of an existing ecosystem such as JavaScript
for <em>ClojureScript</em> and the JVM for <em>Clojure</em>.</p>
</div>
<div class="sect3">
<h4 id="the-types"><a class="link" href="#the-types">3.12.1. The types</a></h4>
<div class="paragraph">
<p><em>ClojureScript</em>, unlike what you might expect, tries to take advantage of every type that the platform provides. This
is a (perhaps incomplete) list of things that <em>ClojureScript</em> inherits and reuses from the underlying
platform:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>ClojureScript</em> strings are JavaScript <strong>Strings</strong>.</p>
</li>
<li>
<p><em>ClojureScript</em> numbers are JavaScript <strong>Numbers</strong>.</p>
</li>
<li>
<p><em>ClojureScript</em> <code>nil</code> is a JavaScript <strong>null</strong>.</p>
</li>
<li>
<p><em>ClojureScript</em> regular expressions are JavaScript <code>RegExp</code> instances.</p>
</li>
<li>
<p><em>ClojureScript</em> is not interpreted; it is always compiled down to JavaScript.</p>
</li>
<li>
<p><em>ClojureScript</em> allows easy call to platform APIs with the same semantics.</p>
</li>
<li>
<p><em>ClojureScript</em> data types internally compile to objects in JavaScript.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>On top of it, <em>ClojureScript</em> builds its own abstractions and types that do not exist in the
platform, such as Vectors, Maps, Sets, and others that are explained in preceding sections of this chapter.</p>
</div>
</div>
<div class="sect3">
<h4 id="interacting-with-platform-types"><a class="link" href="#interacting-with-platform-types">3.12.2. Interacting with platform types</a></h4>
<div class="paragraph">
<p><em>ClojureScript</em> comes with a little set of special forms that allows it to interact with platform
types such as calling object methods, creating new instances, and accessing object
properties.</p>
</div>
<div class="sect4">
<h5 id="access-to-the-platform"><a class="link" href="#access-to-the-platform">Access to the platform</a></h5>
<div class="paragraph">
<p><em>ClojureScript</em> has a special syntax for access to the entire platform environment through the
<code>js/</code> special namespace. This is an example of an expression to execute JavaScript&#8217;s
built-in <code>parseInt</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">js/parseInt</span> <span class="tok-s">&quot;222&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 222</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="creating-new-instances"><a class="link" href="#creating-new-instances">Creating new instances</a></h5>
<div class="paragraph">
<p><em>ClojureScript</em> has two ways to create instances:</p>
</div>
<div class="paragraph">
<p>Using the <code>new</code> special form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">new </span><span class="tok-nv">js/RegExp</span> <span class="tok-s">&quot;^foo$&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the <code>.</code> special form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">js/RegExp.</span> <span class="tok-s">&quot;^foo$&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The last one is the recommended way to create instances. We are not aware of any real differences
between the two forms, but in the ClojureScript community, the last one is used most often.</p>
</div>
</div>
<div class="sect4">
<h5 id="invoke-instance-methods"><a class="link" href="#invoke-instance-methods">Invoke instance methods</a></h5>
<div class="paragraph">
<p>To invoke methods of some object instance, as opposed to how it is done in JavaScript (e.g.,
<code>obj.method()</code>, the method name comes first like any other standard function in Lisp languages
but with a little variation: the function name starts with special form <code>.</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see how we can call the <code>.test()</code> method of a regexp instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">re</span> <span class="tok-p">(</span><span class="tok-nf">js/RegExp</span> <span class="tok-s">&quot;^Clojure&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">.test</span> <span class="tok-nv">re</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can invoke instance methods on JavaScript objects. The first example follows the pattern you have seen;
the last one is a shortcut:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">.sqrt</span> <span class="tok-nv">js/Math</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1.4142135623730951</span>
<span class="tok-p">(</span><span class="tok-nf">js/Math.sqrt</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1.4142135623730951</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="access-to-object-properties"><a class="link" href="#access-to-object-properties">Access to object properties</a></h5>
<div class="paragraph">
<p>Access to an object&#8217;s properties is really very similar to calling a method. The difference is that
instead of using the <code>.</code> you use <code>.-</code>. Let&#8217;s see an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">.-multiline</span> <span class="tok-nv">re</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>
<span class="tok-p">(</span><span class="tok-nf">.-PI</span> <span class="tok-nv">js/Math</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 3.141592653589793</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="property-access-shorthand"><a class="link" href="#property-access-shorthand">Property access shorthand</a></h5>
<div class="paragraph">
<p>Symbols with the <code>js/</code> prefix can contain dots to denote nested property access.
Both of the following expressions invoke the same function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">.log</span> <span class="tok-nv">js/console</span> <span class="tok-s">&quot;Hello World&quot;</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">js/console.log</span> <span class="tok-s">&quot;Hello World&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And both of the following expressions access the same property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">.-PI</span> <span class="tok-nv">js/Math</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 3.141592653589793</span>

<span class="tok-nv">js/Math.PI</span>
<span class="tok-c1">;; =&gt; 3.141592653589793</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="javascript-objects"><a class="link" href="#javascript-objects">JavaScript objects</a></h5>
<div class="paragraph">
<p><em>ClojureScript</em> has different ways to create plain JavaScript objects; each one has its own
purpose. The basic one is the <code>js-obj</code> function. It accepts a variable number of pairs of keys and
values and returns a JavaScript object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">js-obj</span> <span class="tok-s">&quot;country&quot;</span> <span class="tok-s">&quot;FR&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #js {:country &quot;FR&quot;}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The return value can be passed to some kind of third party library that accepts a plain
JavaScript object, but you can observe the real representation of the return value of this
function. It is really another form for doing the same thing.</p>
</div>
<div class="paragraph">
<p>Using the reader macro <code>#js</code> consists of prepending it to a ClojureScript map or vector, and the
result will be transformed to plain JavaScript:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">myobj</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">{</span><span class="tok-ss">:country</span> <span class="tok-s">&quot;FR&quot;</span><span class="tok-p">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The translation of that to plain JavaScript is similar to this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="javascript"><span class="tok-kd">var</span> <span class="tok-nx">myobj</span> <span class="tok-o">=</span> <span class="tok-p">{</span><span class="tok-nx">country</span><span class="tok-o">:</span> <span class="tok-s2">&quot;FR&quot;</span><span class="tok-p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As explained in the previous section, you can also access the plain object properties using
the <code>.-</code> syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">.-country</span> <span class="tok-nv">myobj</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;FR&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And as JavaScript objects are mutable, you can set a new value for some property using
the <code>set!</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-p">(</span><span class="tok-nf">.-country</span> <span class="tok-nv">myobj</span><span class="tok-p">)</span> <span class="tok-s">&quot;KR&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="conversions"><a class="link" href="#conversions">Conversions</a></h5>
<div class="paragraph">
<p>The inconvenience of the previously explained forms is that they do not make recursive
transformations, so if you have nested objects, the nested objects will not be converted.
Consider this example that uses Clojurescript maps, then a similar one with JavaScript objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">clj-map</span> <span class="tok-p">{</span><span class="tok-ss">:country</span> <span class="tok-p">{</span><span class="tok-ss">:code</span> <span class="tok-s">&quot;FR&quot;</span> <span class="tok-ss">:name</span> <span class="tok-s">&quot;France&quot;</span><span class="tok-p">}})</span>
<span class="tok-c1">;; =&gt; {:country {:code &quot;FR&quot;, :name &quot;France&quot;}}</span>
<span class="tok-p">(</span><span class="tok-ss">:code</span> <span class="tok-p">(</span><span class="tok-ss">:country</span> <span class="tok-nv">clj-map</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;FR&quot;</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">js-obj</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">{</span><span class="tok-ss">:country</span> <span class="tok-p">{</span><span class="tok-ss">:code</span> <span class="tok-s">&quot;FR&quot;</span> <span class="tok-ss">:name</span> <span class="tok-s">&quot;France&quot;</span><span class="tok-p">}})</span>
<span class="tok-c1">;; =&gt; #js {:country {:code &quot;FR&quot;, :name &quot;France&quot;}</span>
<span class="tok-p">(</span><span class="tok-nf">.-country</span> <span class="tok-nv">js-obj</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:code &quot;FR&quot;, :name &quot;France&quot;}</span>
<span class="tok-p">(</span><span class="tok-nf">.-code</span> <span class="tok-p">(</span><span class="tok-nf">.-country</span> <span class="tok-nv">js-obj</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To solve that use case, <em>ClojureScript</em> comes with the <code>clj&#8594;js</code> and <code>js&#8594;clj</code> functions
that transform Clojure collection types into JavaScript and back. Note that the conversion to
ClojureScript changes the <code>:country</code> keyword to a string.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">clj-&gt;js</span> <span class="tok-p">{</span><span class="tok-ss">:foo</span> <span class="tok-p">{</span><span class="tok-ss">:bar</span> <span class="tok-s">&quot;baz&quot;</span><span class="tok-p">}})</span>
<span class="tok-c1">;; =&gt; #js {:foo #js {:bar &quot;baz&quot;}}</span>
<span class="tok-p">(</span><span class="tok-nf">js-&gt;clj</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">{</span><span class="tok-ss">:country</span> <span class="tok-p">{</span><span class="tok-ss">:code</span> <span class="tok-s">&quot;FR&quot;</span> <span class="tok-ss">:name</span> <span class="tok-s">&quot;France&quot;</span><span class="tok-p">}}))</span>
<span class="tok-c1">;; =&gt; {&quot;country&quot; {:code &quot;FR&quot;, :name &quot;France&quot;}}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the case of arrays, there is a specialized function <code>into-array</code> that behaves as expected:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">into-array </span><span class="tok-p">[</span><span class="tok-s">&quot;France&quot;</span> <span class="tok-s">&quot;Korea&quot;</span> <span class="tok-s">&quot;Peru&quot;</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; #js [&quot;France&quot; &quot;Korea&quot; &quot;Peru&quot;]</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="arrays"><a class="link" href="#arrays">Arrays</a></h5>
<div class="paragraph">
<p>In the previous example, we saw how we can create an array from an existing <em>ClojureScript</em>
collection. But there is another function for creating arrays: <code>make-array</code>.</p>
</div>
<div class="listingblock">
<div class="title">Creating a preallocated array with length 10</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nb">make-array </span><span class="tok-mi">10</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #js [nil nil nil nil nil nil nil nil nil nil]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In <em>ClojureScript</em>, arrays also play well with sequence abstractions, so you can iterate
over them or simply get the number of elements with the <code>count</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-nv">a</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 10</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As arrays in the JavaScript platform are a mutable collection type, you can access a concrete index
and set the value at that position:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">aset </span><span class="tok-nv">a</span> <span class="tok-mi">0</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>
<span class="tok-nv">a</span>
<span class="tok-c1">;; =&gt; #js [2 nil nil nil nil nil nil nil nil nil]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Or access in an indexed way to get its values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">aget </span><span class="tok-nv">a</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In JavaScript, array index access is equivalent to object property access, so you can use the same functions for interacting
with plain objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">b</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">{</span><span class="tok-ss">:hour</span> <span class="tok-mi">16</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; #js {:hour 16}</span>

<span class="tok-p">(</span><span class="tok-nb">aget </span><span class="tok-nv">b</span> <span class="tok-s">&quot;hour&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 16</span>

<span class="tok-p">(</span><span class="tok-nb">aset </span><span class="tok-nv">b</span> <span class="tok-s">&quot;minute&quot;</span> <span class="tok-mi">22</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 22</span>

<span class="tok-nv">b</span>
<span class="tok-c1">;; =&gt; #js {:hour 16, :minute 22}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truthiness-section"><a class="link" href="#truthiness-section">3.13. Truthiness</a></h3>
<div class="paragraph">
<p>This is the aspect where each language has its own semantics. The majority of languages
consider empty collections, the integer 0, and other things like this to be false.
In <em>ClojureScript</em>, unlike in other languages, only two values are considered as false: <code>nil</code>
and <code>false</code>. Everything else is treated as <code>true</code>.</p>
</div>
<div class="paragraph">
<p>Thanks to this, sets can also be considered as predicates. If a set returns a value, it exists;
if it returns <code>nil</code>, the value does not exist:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">s</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">})</span>

<span class="tok-p">(</span><span class="tok-nf">s</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nf">s</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="state-management"><a class="link" href="#state-management">3.14. State management</a></h3>
<div class="paragraph">
<p>We&#8217;ve learned that one of ClojureScript&#8217;s fundamental ideas is immutability. Both scalar values
and collections are immutable in ClojureScript, except those mutable types present in the JS host
like <code>Date</code>.</p>
</div>
<div class="paragraph">
<p>Immutability has many great properties but we are sometimes faced with the need to model values
that change over time. How can we achieve this if we can&#8217;t change data structures in place?</p>
</div>
<div class="sect3">
<h4 id="vars-2"><a class="link" href="#vars-2">3.14.1. Vars</a></h4>
<div class="paragraph">
<p>Vars can be redefined at will inside a namespace but there is no way to know <strong>when</strong> they change. The
inability to redefine vars from other namespaces is a bit limiting; also, if we are modifying state, we&#8217;re
probably interested in knowing when it occurs.</p>
</div>
</div>
<div class="sect3">
<h4 id="atoms"><a class="link" href="#atoms">3.14.2. Atoms</a></h4>
<div class="paragraph">
<p>ClojureScript gives us the <code>Atom</code> type, which is an object containing a value that can be altered at
will. Besides altering its value, it also supports observation through watcher functions that can
be attached and detached from it and validation for ensuring that the value contained in the atom is
always valid.</p>
</div>
<div class="paragraph">
<p>If we were to model an identity corresponding to a person called Ciri, we could wrap an immutable value
containing Ciri&#8217;s data in an atom. Note that we can get the atom&#8217;s value with the <code>deref</code> function or using
its shorthand <code>@</code> notation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ciri</span> <span class="tok-p">(</span><span class="tok-nf">atom</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span> <span class="tok-ss">:lastname</span> <span class="tok-s">&quot;Fiona&quot;</span> <span class="tok-ss">:age</span> <span class="tok-mi">20</span><span class="tok-p">}))</span>
<span class="tok-c1">;; #&lt;Atom: {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 20}&gt;</span>

<span class="tok-p">(</span><span class="tok-nb">deref </span><span class="tok-nv">ciri</span><span class="tok-p">)</span>
<span class="tok-c1">;; {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 20}</span>

<span class="tok-o">@</span><span class="tok-nv">ciri</span>
<span class="tok-c1">;; {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 20}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can use the <code>swap!</code> function on an atom to alter its value with a function. Since Ciri&#8217;s birthday is
today, let&#8217;s increment her age count:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">swap!</span> <span class="tok-nv">ciri</span> <span class="tok-nv">update</span> <span class="tok-ss">:age</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
<span class="tok-c1">;; {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 21}</span>

<span class="tok-o">@</span><span class="tok-nv">ciri</span>
<span class="tok-c1">;; {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 21}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>reset!</code> functions replaces the value contained in the atom with a new one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">reset!</span> <span class="tok-nv">ciri</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span>, <span class="tok-ss">:lastname</span> <span class="tok-s">&quot;Fiona&quot;</span>, <span class="tok-ss">:age</span> <span class="tok-mi">22</span><span class="tok-p">})</span>
<span class="tok-c1">;; {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 22}</span>

<span class="tok-o">@</span><span class="tok-nv">ciri</span>
<span class="tok-c1">;; {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 22}</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="observation"><a class="link" href="#observation">Observation</a></h5>
<div class="paragraph">
<p>We can add and remove watcher functions for atoms. Whenever the atom&#8217;s value is changed through a <code>swap!</code> or <code>reset!</code>,
all the atom&#8217;s watcher functions will be called. Watchers are added with the <code>add-watch</code> function. Notice that each
watcher has a key associated (<code>:logger</code> in the example) to it which is later used to remove the watch from the atom.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">atom</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">add-watch</span> <span class="tok-nv">a</span> <span class="tok-ss">:logger</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nb">key </span><span class="tok-nv">the-atom</span> <span class="tok-nv">old-value</span> <span class="tok-nv">new-value</span><span class="tok-p">]</span>
                       <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Key:&quot;</span> <span class="tok-nb">key </span><span class="tok-s">&quot;Old:&quot;</span> <span class="tok-nv">old-value</span> <span class="tok-s">&quot;New:&quot;</span> <span class="tok-nv">new-value</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">reset!</span> <span class="tok-nv">a</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; Key: :logger Old: nil New: 42</span>
<span class="tok-c1">;; =&gt; 42</span>

<span class="tok-p">(</span><span class="tok-nf">swap!</span> <span class="tok-nv">a</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
<span class="tok-c1">;; Key: :logger Old: 42 New: 43</span>
<span class="tok-c1">;; =&gt; 4</span>

<span class="tok-p">(</span><span class="tok-nf">remove-watch</span> <span class="tok-nv">a</span> <span class="tok-ss">:logger</span><span class="tok-p">)</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="volatiles"><a class="link" href="#volatiles">3.14.3. Volatiles</a></h4>
<div class="paragraph">
<p>Volatiles, like atoms, are objects containing a value that can be altered. However, they don&#8217;t provide
the observation and validation capabilities that atoms provide. This makes them slightly more performant
and a more suitable mutable container to use inside stateful functions that don&#8217;t need observation nor
validation.</p>
</div>
<div class="paragraph">
<p>Their API closely resembles that of atoms. They can be dereferenced to grab the value they contain and
support swapping and resetting with <code>vswap!</code> and <code>vreset!</code> respectively:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ciri</span> <span class="tok-p">(</span><span class="tok-nf">volatile!</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span> <span class="tok-ss">:lastname</span> <span class="tok-s">&quot;Fiona&quot;</span> <span class="tok-ss">:age</span> <span class="tok-mi">20</span><span class="tok-p">}))</span>
<span class="tok-c1">;; #&lt;Volatile: {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 20}&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">volatile?</span> <span class="tok-nv">ciri</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">deref </span><span class="tok-nv">ciri</span><span class="tok-p">)</span>
<span class="tok-c1">;; {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 20}</span>

<span class="tok-p">(</span><span class="tok-nf">vswap!</span> <span class="tok-nv">ciri</span> <span class="tok-nv">update</span> <span class="tok-ss">:age</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
<span class="tok-c1">;; {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 21}</span>

<span class="tok-p">(</span><span class="tok-nf">vreset!</span> <span class="tok-nv">ciri</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span>, <span class="tok-ss">:lastname</span> <span class="tok-s">&quot;Fiona&quot;</span>, <span class="tok-ss">:age</span> <span class="tok-mi">22</span><span class="tok-p">})</span>
<span class="tok-c1">;; {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 22}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that another difference with atoms is that the constructor of volatiles uses a bang at the end. You create
volatiles with <code>volatile!</code> and atoms with <code>atom</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tooling-compiler"><a class="link" href="#tooling-compiler">4. Tooling &amp; Compiler</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter will cover a little introduction to existing tooling for making things easy
when developing using ClojureScript. It will cover:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Using the repl</p>
</li>
<li>
<p>Leiningen and cljsbuild</p>
</li>
<li>
<p>Google Closure Library</p>
</li>
<li>
<p>Modules</p>
</li>
<li>
<p>Unit testing</p>
</li>
<li>
<p>Library development</p>
</li>
<li>
<p>Browser based development</p>
</li>
<li>
<p>Server based development</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Unlike the previous chapter, this chapter intends to tell different stories each
independent of the other.</p>
</div>
<div class="sect2">
<h3 id="getting-started-with-the-compiler"><a class="link" href="#getting-started-with-the-compiler">4.1. Getting Started with the Compiler</a></h3>
<div class="paragraph">
<p>At this point, you are surely very bored with the constant theoretical explanations about
the language itself and will want to write and execute some code. The goal of this section
is to provide a little practical introduction to the <em>ClojureScript</em> compiler.</p>
</div>
<div class="paragraph">
<p>The <em>ClojureScript</em> compiler takes the source code that has been split over numerous
directories and namespaces and compiles it down to JavaScript. Today, JavaScript has a
great number of different environments where it can be executed - each with its own
peculiarities.</p>
</div>
<div class="paragraph">
<p>This chapter intends to explain how to use <em>ClojureScript</em> without any additional tooling.
This will help you understand how the compiler works and how you can use it when other
tooling is not available (such as <a href="http://leiningen.org/">leiningen</a><br/>
<a href="https://github.com/emezeske/lein-cljsbuild">cljsbuild</a> or
<a href="http://boot-clj.com/">boot</a>).</p>
</div>
<div class="sect3">
<h4 id="execution-environments"><a class="link" href="#execution-environments">4.1.1. Execution environments</a></h4>
<div class="paragraph">
<p>What is an execution environment? An execution environment is an engine where JavaScript
can be executed. For example, the most popular execution environment is a browser (Chrome,
Firefox, &#8230;&#8203;) followed by the second most popular - <a href="https://nodejs.org/">nodejs</a>.</p>
</div>
<div class="paragraph">
<p>There are others, such as Rhino (JDK 6+), Nashorn (JDK 8), QtQuick (QT),&#8230;&#8203; but none of
them have significant differences from the first two. So, <em>ClojureScript</em> at the moment
may compile code to run in the browser or in nodejs-like environments out of the box.</p>
</div>
</div>
<div class="sect3">
<h4 id="download-the-compiler"><a class="link" href="#download-the-compiler">4.1.2. Download the compiler</a></h4>
<div class="paragraph">
<p>The <em>ClojureScript</em> compiler is implemented in Java. To use it, you should have jdk8
installed. <em>ClojureScript</em> itself only requires JDK 7, but the standalone compiler that we
are going to use in this chapter requires JDK 8, which can be found at
<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" class="bare">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
</div>
<div class="paragraph">
<p>You can download the latest <em>ClojureScript</em> compiler using <code>wget</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">wget https://github.com/clojure/clojurescript/releases/download/r1.7.28/cljs.jar</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>ClojureScript</em> compiler is packaged in a standalone executable jar file, so this is
the only file (along with JDK 8) that you need to compile your <em>ClojureScript</em> source code
to JavaScript.</p>
</div>
</div>
<div class="sect3">
<h4 id="compile-for-nodejs"><a class="link" href="#compile-for-nodejs">4.1.3. Compile for nodejs</a></h4>
<div class="paragraph">
<p>Let’s start with a practical example compiling code that will target <strong>nodejs</strong>. For
this example, you should have nodejs installed.</p>
</div>
<div class="paragraph">
<p>There are different ways to install nodejs, but the recommended way is using nvm (node
version manager). You can read the instructions on how to install and use nvm on its
<a href="https://github.com/creationix/nvm">home page</a>.</p>
</div>
<div class="paragraph">
<p>When you have installed nvm, follow installing the latest version of nodejs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell">nvm install v5.4.1
nvm alias default v5.4.1</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can test if <strong>nodejs</strong> is installed in your system with this command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell">$ node --version
v5.4.1</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="create-the-example-application"><a class="link" href="#create-the-example-application">Create the example application</a></h5>
<div class="paragraph">
<p>For the first step of our practical example, we will create our application directory
structure and populate it with example code.</p>
</div>
<div class="paragraph">
<p>Start by creating the directory tree structure for our “hello world” application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">mkdir -p myapp/src/myapp
touch myapp/src/myapp/core.cljs</code></pre>
</div>
</div>
<div class="paragraph">
<p>Resulting in this directory tree:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text">myapp
└── src
    └── myapp
        └── core.cljs</code></pre>
</div>
</div>
<div class="paragraph">
<p>Second, write the example code into the previously created <code>myapp/src/myapp/core.cljs</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">myapp.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">cljs.nodejs</span> <span class="tok-ss">:as</span> <span class="tok-nv">nodejs</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nf">nodejs/enable-util-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">-main</span>
  <span class="tok-p">[</span><span class="tok-o">&amp;</span> <span class="tok-nv">args</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Hello world!&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-nv">*main-cli-fn*</span> <span class="tok-nv">-main</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
It is very important that the declared namespace in the file exactly matches the
directory structure. This is the way <em>ClojureScript</em> structures its source code.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="compile-the-example-application"><a class="link" href="#compile-the-example-application">Compile the example application</a></h5>
<div class="paragraph">
<p>In order to compile that source code, we need a simple build script that tells the
<em>ClojureScript</em> compiler the source directory and the output file. <em>ClojureScript</em> has a
lot of other options, but at this moment we can ignore that.</p>
</div>
<div class="paragraph">
<p>Let’s create the <em>myapp/build.clj</em> file with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.build.api</span> <span class="tok-ss">:as</span> <span class="tok-nv">b</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">b/build</span> <span class="tok-s">&quot;src&quot;</span>
 <span class="tok-p">{</span><span class="tok-ss">:main</span> <span class="tok-ss">&#39;myapp.core</span>
  <span class="tok-ss">:output-to</span> <span class="tok-s">&quot;main.js&quot;</span>
  <span class="tok-ss">:output-dir</span> <span class="tok-s">&quot;out&quot;</span>
  <span class="tok-ss">:target</span> <span class="tok-ss">:nodejs</span>
  <span class="tok-ss">:verbose</span> <span class="tok-nv">true</span><span class="tok-p">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a brief explanation of the compiler options used in this example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>:output-to</code> parameter indicates to the compiler the destination of the compiled
code, in this case to the "main.js" file.</p>
</li>
<li>
<p>The <code>:main</code> property indicates to the compiler the namespace that will act as the entry
point of your application when it&#8217;s executed.</p>
</li>
<li>
<p>The <code>:target</code> property indicates the platform where you want to execute the compiled
code. In this case, we are going to use <strong>nodejs</strong>. If you omit this
parameter, the source will be compiled to run in the browser environment.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To run the compilation, just execute the following command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nb">cd </span>myapp
java -cp ../cljs.jar:src clojure.main build.clj</code></pre>
</div>
</div>
<div class="paragraph">
<p>And when it finishes, execute the compiled file using <strong>node</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell">$ node main.js
Hello world!</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="compile-for-the-browser"><a class="link" href="#compile-for-the-browser">4.1.4. Compile for the Browser</a></h4>
<div class="paragraph">
<p>In this section we are going to create an application similar to the "hello world" example
from the previous section to run in the browser environment. The minimal requirement for
this application is just a browser that can execute JavaScript.</p>
</div>
<div class="paragraph">
<p>The process is almost the same, and the directory structure is the same. The only things
that changes is the entry point of the application and the build script. So, start
re-creating the directory tree from previous example in a different directory.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">mkdir -p mywebapp/src/mywebapp
touch mywebapp/src/mywebapp/core.cljs</code></pre>
</div>
</div>
<div class="paragraph">
<p>Resulting in this directory tree:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text">mywebapp
└── src
    └── mywebapp
        └── core.cljs</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, write new content to the <code>mywebapp/src/mywebapp/core.cljs</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">mywebapp.core</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Hello world!&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the browser environment we do not need a specific entry point for the application, so
the entry point is the entire namespace.</p>
</div>
<div class="sect4">
<h5 id="compile-the-example-application-2"><a class="link" href="#compile-the-example-application-2">Compile the example application</a></h5>
<div class="paragraph">
<p>In order to compile the source code to run properly in a browser, overwrite the
<em>mywebapp/build.clj</em> file with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.build.api</span> <span class="tok-ss">:as</span> <span class="tok-nv">b</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">b/build</span> <span class="tok-s">&quot;src&quot;</span>
 <span class="tok-p">{</span><span class="tok-ss">:output-to</span> <span class="tok-s">&quot;main.js&quot;</span>
  <span class="tok-ss">:output-dir</span> <span class="tok-s">&quot;out/&quot;</span>
  <span class="tok-ss">:source-map</span> <span class="tok-s">&quot;main.js.map&quot;</span>
  <span class="tok-ss">:main</span> <span class="tok-ss">&#39;mywebapp.core</span>
  <span class="tok-ss">:verbose</span> <span class="tok-nv">true</span>
  <span class="tok-ss">:optimizations</span> <span class="tok-ss">:none</span><span class="tok-p">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a brief explanation of the compiler options we&#8217;re using:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>:output-to</code> parameter indicates to the compiler the destination of the compiled
code, in this case the "main.js" file.</p>
</li>
<li>
<p>The <code>:main</code> property indicates to the compiler the namespace that will act as the  entry
point of your application when it&#8217;s executed.</p>
</li>
<li>
<p><code>:source-map</code> indicates the destination of the source map. (The source map connects the
ClojureScript source to the generated JavaScript so that error messages can point you
back to the original source.)</p>
</li>
<li>
<p><code>:output-dir</code> indicates the destination directory for all file sources used in a
compilation. It is just for making source maps work properly with the rest of the code,
not only your source.</p>
</li>
<li>
<p><code>:optimizations</code> indicates the compilation optimization. There are different values for
this option, but that will be covered in subsequent sections in more detail.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To run the compilation, just execute the following command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nb">cd </span>mywebapp<span class="tok-p">;</span>
java -cp ../cljs.jar:src clojure.main build.clj</code></pre>
</div>
</div>
<div class="paragraph">
<p>This process can take some time, so do not worry; wait a little bit. The JVM bootstrap
with the Clojure compiler is slightly slow. In the following sections, we will explain how
to start a watch process to avoid constantly starting and stopping this slow process.</p>
</div>
<div class="paragraph">
<p>While waiting for the compilation, let&#8217;s create a dummy HTML file to make it easy to
execute our example app in the browser. Create the <em>index.html</em> file with the following
content; it goes in the main <em>mywebapp</em> directory.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="html"><span class="tok-cp">&lt;!DOCTYPE html&gt;</span>
<span class="tok-nt">&lt;html&gt;</span>
  <span class="tok-nt">&lt;header&gt;</span>
    <span class="tok-nt">&lt;meta</span> <span class="tok-na">charset=</span><span class="tok-s">&quot;utf-8&quot;</span> <span class="tok-nt">/&gt;</span>
    <span class="tok-nt">&lt;title&gt;</span>Hello World from ClojureScript<span class="tok-nt">&lt;/title&gt;</span>
  <span class="tok-nt">&lt;/header&gt;</span>
  <span class="tok-nt">&lt;body&gt;</span>
    <span class="tok-nt">&lt;script </span><span class="tok-na">src=</span><span class="tok-s">&quot;main.js&quot;</span><span class="tok-nt">&gt;&lt;/script&gt;</span>
  <span class="tok-nt">&lt;/body&gt;</span>
<span class="tok-nt">&lt;/html&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, when the compilation finishes and you have the basic HTML file you can just open it
with your favorite browser and take a look in the development tools console. The
"Hello world!" message should appear there.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="watch-process"><a class="link" href="#watch-process">4.1.5. Watch process</a></h4>
<div class="paragraph">
<p>Surely, you have already experienced the slow startup of the <em>ClojureScript</em> compiler. To
solve this, the <em>ClojureScript</em> standalone compiler also comes with tools to start a
process that watches the changes in some directory and performs an incremental
compilation.</p>
</div>
<div class="paragraph">
<p>Start creating another build script, but in this case, name it <em>watch.clj</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.build.api</span> <span class="tok-ss">:as</span> <span class="tok-nv">b</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">b/watch</span> <span class="tok-s">&quot;src&quot;</span>
 <span class="tok-p">{</span><span class="tok-ss">:output-to</span> <span class="tok-s">&quot;main.js&quot;</span>
  <span class="tok-ss">:output-dir</span> <span class="tok-s">&quot;out/&quot;</span>
  <span class="tok-ss">:source-map</span> <span class="tok-s">&quot;main.js.map&quot;</span>
  <span class="tok-ss">:main</span> <span class="tok-ss">&#39;mywebapp.core</span>
  <span class="tok-ss">:optimizations</span> <span class="tok-ss">:none</span><span class="tok-p">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, execute that script like any other that you have executed in previous sections:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>java -cp ../cljs.jar:src clojure.main watch.clj
Building ...
Reading analysis cache <span class="tok-k">for</span> jar:file:/home/niwi/cljsbook/playground/cljs.jar!/cljs/core.cljs
Compiling src/mywebapp/core.cljs
Compiling out/cljs/core.cljs
Using cached cljs.core out/cljs/core.cljs
... <span class="tok-k">done</span>. Elapsed 0.754487937 seconds
Watching paths: /home/niwi/cljsbook/playground/mywebapp/src</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can observe that in the second compilation, the time is drastically reduced. Another
advantage of this method is that it gives a little bit more output.</p>
</div>
</div>
<div class="sect3">
<h4 id="optimization-levels"><a class="link" href="#optimization-levels">4.1.6. Optimization levels</a></h4>
<div class="paragraph">
<p>The <em>ClojureScript</em> compiler has different levels of optimization. Behind the scenes,
those compilation levels are coming from Google Closure Compiler.</p>
</div>
<div class="paragraph">
<p>A very simplified overview of the compilation process is:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The reader reads the code and makes some analysis. This process can raise some warnings
during this phase.</p>
</li>
<li>
<p>Then, the <em>ClojureScript</em> compiler emits JavaScript code. The result is one JavaScript
file for each cljs file.</p>
</li>
<li>
<p>The generated files passes through the Closure Compiler that, depending on the
optimization level and other options (sourcemaps, output dir output to, &#8230;&#8203;) generates
the final output.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The final output depends strictly on the optimization level.</p>
</div>
<div class="sect4">
<h5 id="none"><a class="link" href="#none">none</a></h5>
<div class="paragraph">
<p>Implies that closure compiler just writes the files as is, without any additional
optimization applied to the source code.</p>
</div>
</div>
<div class="sect4">
<h5 id="whitespace"><a class="link" href="#whitespace">whitespace</a></h5>
<div class="paragraph">
<p>This optimization level consists of concatenating the compiled files in an appropriate
order, removing line breaks and other whitespace and generating the output as one large
file.</p>
</div>
<div class="paragraph">
<p>It also has some compilation speed penalty, resulting in slower compilations. In any case,
it is not terribly slow and is completely usable in small/medium applications.</p>
</div>
</div>
<div class="sect4">
<h5 id="simple"><a class="link" href="#simple">simple</a></h5>
<div class="paragraph">
<p>The simple compilation level implies (includes) all transformations from whitespace
optimization and additionally performs optimizations within expressions and functions,
including renaming local variables and function parameters to shorter names.</p>
</div>
<div class="paragraph">
<p>Compilation with the <code>:simple</code> optimization always preserves the functionality of
syntactically valid JavaScript, so it does not interfere with the interaction between the
compiled <em>ClojureScript</em> and other JavaScript.</p>
</div>
</div>
<div class="sect4">
<h5 id="advanced"><a class="link" href="#advanced">advanced</a></h5>
<div class="paragraph">
<p>The advanced compilation level includes all transformations from simple
optimization and additionally performs more aggressive optimizations and dead
code elimination. This results in significantly smaller output files.</p>
</div>
<div class="paragraph">
<p>The <code>:advanced</code> optimizations can only work for a strict subset of JavaScript
code that follows the Google Closure Compiler rules.  <em>ClojureScript</em> generates
valid JavaScript within this strict subset, but if you are interacting with
third party JavaScript code, some additional tasks should be done to make
everything work as expected.</p>
</div>
<div class="paragraph">
<p>This interaction with third party javascript libraries will be explained
in later sections.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="working-with-the-repl"><a class="link" href="#working-with-the-repl">4.2. Working with the REPL</a></h3>
<div class="sect3">
<h4 id="introduction-2"><a class="link" href="#introduction-2">4.2.1. Introduction</a></h4>
<div class="paragraph">
<p>Although you can create a source file and compile it every time you want to try something
out in ClojureScript, it&#8217;s easier to use the REPL. REPL stands for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Read - get input from the keyboard</p>
</li>
<li>
<p>Evaluate the input</p>
</li>
<li>
<p>Print the result</p>
</li>
<li>
<p>Loop back for more input</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In other words, the REPL lets you try out ClojureScript concepts and get immediate
feedback.</p>
</div>
<div class="paragraph">
<p><em>ClojureScript</em> comes with support for executing the REPL in different execution
environments, each one has its own advantages or disadvantages. For example, you can run a
REPL in nodejs but in that environment you don&#8217;t have access to the DOM.</p>
</div>
<div class="paragraph">
<p>In summary: everything really depends on your needs or requirements.</p>
</div>
</div>
<div class="sect3">
<h4 id="nashorn-repl"><a class="link" href="#nashorn-repl">4.2.2. Nashorn REPL</a></h4>
<div class="paragraph">
<p>The Nashorn REPL is the easiest and maybe most painless REPL environment because it does
not require any special stuff, just the JVM (JDK 8) that you have used in previous
examples for running the <em>ClojureScript</em> compiler.</p>
</div>
<div class="paragraph">
<p>Let’s start creating the <em>repl.clj</em> file with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.repl</span><span class="tok-p">]</span>
         <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.repl.nashorn</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">cljs.repl/repl</span>
 <span class="tok-p">(</span><span class="tok-nf">cljs.repl.nashorn/repl-env</span><span class="tok-p">)</span>
 <span class="tok-ss">:output-dir</span> <span class="tok-s">&quot;out&quot;</span>
 <span class="tok-ss">:cache-analysis</span> <span class="tok-nv">true</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, execute the following command to get the REPL up and running:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>java -cp cljs.jar:src clojure.main repl.clj
To quit, <span class="tok-nb">type</span>: :cljs/quit
cljs.user<span class="tok-o">=</span>&gt; <span class="tok-o">(</span>+ <span class="tok-m">1</span> 2<span class="tok-o">)</span>
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may have noticed that the REPL does not have support for history and other shell-like
facilities. This is because the default REPL does not comes with "readline" support. But
this problem can be solved using the simple tool called <code>rlwrap</code> that you can certainly
find with the package manager of your operating system.</p>
</div>
<div class="paragraph">
<p>The <code>rlwrap</code> makes the REPL "readline" capable and will allow you to have command history,
code navigation, and other shell-like utilities that will make your REPL experience much
more pleasant. To use it, just prepend it to the previous command that we have used to
execute the REPL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>rlwrap java -cp cljs.jar:src clojure.main repl.clj
To quit, <span class="tok-nb">type</span>: :cljs/quit
cljs.user<span class="tok-o">=</span>&gt; <span class="tok-o">(</span>+ <span class="tok-m">1</span> 2<span class="tok-o">)</span>
3</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="node-repl"><a class="link" href="#node-repl">4.2.3. Node REPL</a></h4>
<div class="paragraph">
<p>This REPL uses nodejs as an execution environment and obviously requires that nodejs
to be installed in your system.</p>
</div>
<div class="paragraph">
<p>Surely you are asking yourself, why do I need a repl with nodejs when we have nashorn
that does not require any additional dependencies. The answer is very simple: nodejs
is the most used JavaScript execution environment on the backend, and it has a great
amount of community packages around it.</p>
</div>
<div class="paragraph">
<p>Well, the good news is that starting a nodejs repl is very easy once you have it
installed in your system. Start writing this content to a new <code>repl.clj</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.repl</span><span class="tok-p">]</span>
         <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.repl.node</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">cljs.repl/repl</span>
 <span class="tok-p">(</span><span class="tok-nf">cljs.repl.node/repl-env</span><span class="tok-p">)</span>
 <span class="tok-ss">:output-dir</span> <span class="tok-s">&quot;out&quot;</span>
 <span class="tok-ss">:cache-analysis</span> <span class="tok-nv">true</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And start the REPL like you have done it previously with nashorn REPL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>rlwrap java -cp cljs.jar:src clojure.main repl.clj
To quit, <span class="tok-nb">type</span>: :cljs/quit
cljs.user<span class="tok-o">=</span>&gt; <span class="tok-o">(</span>+ <span class="tok-m">1</span> 2<span class="tok-o">)</span>
3</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="browser-repl"><a class="link" href="#browser-repl">4.2.4. Browser REPL</a></h4>
<div class="paragraph">
<p>This REPL is the most laborious to get up and running. This is because it uses a browser
for its execution environment and it has additional requirements.</p>
</div>
<div class="paragraph">
<p>Let’s start by creating a file named <code>brepl.clj</code> with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span>
  <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.build.api</span> <span class="tok-ss">:as</span> <span class="tok-nv">b</span><span class="tok-p">]</span>
  <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.repl</span> <span class="tok-ss">:as</span> <span class="tok-nv">repl</span><span class="tok-p">]</span>
  <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.repl.browser</span> <span class="tok-ss">:as</span> <span class="tok-nv">browser</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">b/build</span> <span class="tok-s">&quot;src&quot;</span>
 <span class="tok-p">{</span><span class="tok-ss">:output-to</span> <span class="tok-s">&quot;main.js&quot;</span>
  <span class="tok-ss">:output-dir</span> <span class="tok-s">&quot;out/&quot;</span>
  <span class="tok-ss">:source-map</span> <span class="tok-s">&quot;main.js.map&quot;</span>
  <span class="tok-ss">:main</span> <span class="tok-ss">&#39;myapp.core</span>
  <span class="tok-ss">:verbose</span> <span class="tok-nv">true</span>
  <span class="tok-ss">:optimizations</span> <span class="tok-ss">:none</span><span class="tok-p">})</span>

<span class="tok-p">(</span><span class="tok-nf">repl/repl</span> <span class="tok-p">(</span><span class="tok-nf">browser/repl-env</span><span class="tok-p">)</span>
  <span class="tok-ss">:output-dir</span> <span class="tok-s">&quot;out&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This script builds the source, just as we did earlier, and then starts the REPL.</p>
</div>
<div class="paragraph">
<p>But the browser REPL also requires that some code be executed in the browser before
getting the REPL working. To do that, just re-create the application structure very
similar to the one that we have used in previous sections:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">mkdir -p src/myapp
touch src/myapp/core.cljs</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, write new content to the <code>src/myapp/core.cljs</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">myapp.core</span>
 <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">clojure.browser.repl</span> <span class="tok-ss">:as</span> <span class="tok-nv">repl</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-kd">defonce </span><span class="tok-nv">conn</span>
  <span class="tok-p">(</span><span class="tok-nf">repl/connect</span> <span class="tok-s">&quot;http://localhost:9000/repl&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Hello, world!&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And finally, create the missing <em>index.html</em> file that is going to be used as the entry
point for running the browser side code of the REPL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="html"><span class="tok-cp">&lt;!DOCTYPE html&gt;</span>
<span class="tok-nt">&lt;html&gt;</span>
  <span class="tok-nt">&lt;header&gt;</span>
    <span class="tok-nt">&lt;meta</span> <span class="tok-na">charset=</span><span class="tok-s">&quot;utf-8&quot;</span> <span class="tok-nt">/&gt;</span>
    <span class="tok-nt">&lt;title&gt;</span>Hello World from ClojureScript<span class="tok-nt">&lt;/title&gt;</span>
  <span class="tok-nt">&lt;/header&gt;</span>
  <span class="tok-nt">&lt;body&gt;</span>
    <span class="tok-nt">&lt;script </span><span class="tok-na">src=</span><span class="tok-s">&quot;main.js&quot;</span><span class="tok-nt">&gt;&lt;/script&gt;</span>
  <span class="tok-nt">&lt;/body&gt;</span>
<span class="tok-nt">&lt;/html&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Well, that was a lot of setup! But trust us, it’s all worth it when you see it in action.
To do that, just execute the <code>brepl.clj</code> in the same way that we have done it in previous
examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>rlwrap java -cp cljs.jar:src clojure.main brepl.clj
Compiling client js ...
Waiting <span class="tok-k">for</span> browser to connect ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>And finally, open your favourite browser and go to <a href="http://localhost:9000/" class="bare">http://localhost:9000/</a>. Once the page
is loaded (the page will be blank), switch back to the console where you have run the REPL
and you will see that it is up and running:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-o">[</span>...<span class="tok-o">]</span>
To quit, <span class="tok-nb">type</span>: :cljs/quit
cljs.user<span class="tok-o">=</span>&gt; <span class="tok-o">(</span>+ <span class="tok-m">14</span> 28<span class="tok-o">)</span>
42</code></pre>
</div>
</div>
<div class="paragraph">
<p>One of the big advantages of this REPL is that you have access to all the browser
environment. To demonstrate it, just enter <code>(js/alert "hello world")</code> in the repl. The
result of that will be the typical browser alert dialog.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="the-closure-library"><a class="link" href="#the-closure-library">4.3. The Closure Library</a></h3>
<div class="paragraph">
<p>The Google Closure Library is a javascript library developed by Google, based on a modular
architecture and provides cross-browser functions for DOM manipulations and events, ajax
and JSON, among other features.</p>
</div>
<div class="paragraph">
<p>It&#8217;s written specifically to take advantage of the Closure Compiler (that is used
internally by the <em>ClojureScript</em> compiler).</p>
</div>
<div class="paragraph">
<p>And <em>ClojureScript</em> is built on Closure Compiler and Closure Library. In fact,
<em>ClojureScript</em> namespaces are Closure modules. This means that
you can interact with the Closure Library in a very easy way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">yourapp.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">goog.dom</span> <span class="tok-ss">:as</span> <span class="tok-nv">dom</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">element</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;body&quot;</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>With the previous snippet of code you can observe the way you can import the <strong>dom</strong> module of
the closure library and use one function declared in that module.</p>
</div>
<div class="paragraph">
<p>Additionally, the closure library also exposes "special" modules that behave like a
class or object. For importing these kinds of things you should use the <code>:import</code> directive.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">yourapp.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:import</span> <span class="tok-nv">goog.History</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">instance</span> <span class="tok-p">(</span><span class="tok-nf">History.</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are familiar with Clojure, it imports Java classes using
the same <code>:import</code> directive. However, if you define types (classes) using <em>ClojureScript</em>
primitives, you should not use <code>:import</code> to import them, the standard <code>:require</code>
directives should be used.</p>
</div>
</div>
<div class="sect2">
<h3 id="dependency-management"><a class="link" href="#dependency-management">4.4. Dependency management</a></h3>
<div class="paragraph">
<p>Until now, we have used the builtin <em>ClojureScript</em> toolchain to compile our
sources to JavaScript.  This is the minimal setup required for working with and
understanding the compiler, but for larger projects, we often require a larger
build tool that can manage a project&#8217;s dependencies on other libraries.</p>
</div>
<div class="paragraph">
<p>Thus, this chapter intends to explain how you can use <strong>Leiningen</strong>, the de facto clojure build
and dependency management tool, to build <em>ClojureScript</em> projects. There is another
build tool called <strong>boot</strong> that is growing in popularity, but at this moment it will not be
covered in this book.</p>
</div>
<div class="sect3">
<h4 id="installing-leiningen"><a class="link" href="#installing-leiningen">4.4.1. Installing leiningen</a></h4>
<div class="paragraph">
<p>The installation process of leiningen is quite simple; just follow these steps:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">mkdir ~/bin
<span class="tok-nb">cd</span> ~/bin
wget https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein
chmod a+x ./lein
<span class="tok-nb">export </span><span class="tok-nv">PATH</span><span class="tok-o">=</span><span class="tok-nv">$PATH</span>:~/bin</code></pre>
</div>
</div>
<div class="paragraph">
<p>Make sure that the <code>~/bin</code> directory is always set on your path. To make it permanent,
add the line starting with <code>export</code> to your <code>~/.bashrc</code> file (we are supposing that you
are using the bash shell).</p>
</div>
<div class="paragraph">
<p>Now, open another clean terminal and execute <code>lein version</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>lein version
Leiningen 2.5.1 on Java 1.8.0_45 OpenJDK 64-Bit Server VM</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
We are supposing that you are using a Unix-like system such as Linux or BSD. If you
are a Windows user, please check the instructions on the
<a href="http://leiningen.org/">Leiningen homepage</a>. You can also get the Linux/Mac OSX/BSD
version of the leiningen script at the web site.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="first-project"><a class="link" href="#first-project">4.4.2. First project</a></h4>
<div class="paragraph">
<p>The best way to show how a tool works is by creating a toy project with it. In this case,
we will create a small application that calculates if a year is a leap year or not. To
start, we will use the <strong>mies</strong> leiningen template.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Templates are a facility in leiningen for creating an initial project structure.
The clojure community has a great many of them. In this case
we&#8217;ll use the <strong>mies</strong> template that was started by the clojurescript core developer.  Consult
the leiningen docs to learn more about templates.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s start creating the project layout:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>lein new mies leapyears
<span class="tok-nv">$ </span><span class="tok-nb">cd </span>leapyears <span class="tok-c"># move into newly created project directory</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The project has the following structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>leapyears
├── index.html
├── project.clj
├── README.md
├── scripts
│   ├── build
│   ├── release
│   ├── watch
│   ├── repl
│   └── brepl
└── src
    └── leapyears
        └── core.cljs</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>project.clj</code> file contains information that Leiningen uses to download dependencies
and build the project. For now, just trust that everything in that file is exactly as it
should be.</p>
</div>
<div class="paragraph">
<p>Open the <code>index.html</code> file and add the following content at the beginning of body:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="html"><span class="tok-nt">&lt;section</span> <span class="tok-na">class=</span><span class="tok-s">&quot;viewport&quot;</span><span class="tok-nt">&gt;</span>
  <span class="tok-nt">&lt;div</span> <span class="tok-na">id=</span><span class="tok-s">&quot;result&quot;</span><span class="tok-nt">&gt;</span>
    ----
  <span class="tok-nt">&lt;/div&gt;</span>
  <span class="tok-nt">&lt;form</span> <span class="tok-na">action=</span><span class="tok-s">&quot;&quot;</span> <span class="tok-na">method=</span><span class="tok-s">&quot;&quot;</span><span class="tok-nt">&gt;</span>
    <span class="tok-nt">&lt;label</span> <span class="tok-na">for=</span><span class="tok-s">&quot;year&quot;</span><span class="tok-nt">&gt;</span>Input a year<span class="tok-nt">&lt;/label&gt;</span>
    <span class="tok-nt">&lt;input</span> <span class="tok-na">id=</span><span class="tok-s">&quot;year&quot;</span> <span class="tok-na">name=</span><span class="tok-s">&quot;year&quot;</span> <span class="tok-nt">/&gt;</span>
  <span class="tok-nt">&lt;/form&gt;</span>
<span class="tok-nt">&lt;/section&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And the next step is adding some code to make the form interactive. Put the following
code into the <code>src/leapyear/core.cljs</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">leapyears.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">goog.dom</span> <span class="tok-ss">:as</span> <span class="tok-nv">dom</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">goog.events</span> <span class="tok-ss">:as</span> <span class="tok-nv">events</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">cljs.reader</span> <span class="tok-ss">:refer</span> <span class="tok-p">(</span><span class="tok-nf">read-string</span><span class="tok-p">)]))</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">input</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;year&quot;</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">result</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;result&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">leap?</span>
  <span class="tok-p">[</span><span class="tok-nv">year</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">and </span><span class="tok-p">(</span><span class="tok-nb">zero? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">4</span><span class="tok-p">))</span>
       <span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">100</span><span class="tok-p">))</span>
       <span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">400</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">on-change</span>
  <span class="tok-p">[</span><span class="tok-nv">event</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">target</span> <span class="tok-p">(</span><span class="tok-nf">.-target</span> <span class="tok-nv">event</span><span class="tok-p">)</span>
        <span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">read-string</span> <span class="tok-p">(</span><span class="tok-nf">.-value</span> <span class="tok-nv">target</span><span class="tok-p">))]</span>
    <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">leap?</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-p">(</span><span class="tok-nf">.-innerHTML</span> <span class="tok-nv">result</span><span class="tok-p">)</span> <span class="tok-s">&quot;YES&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-p">(</span><span class="tok-nf">.-innerHTML</span> <span class="tok-nv">result</span><span class="tok-p">)</span> <span class="tok-s">&quot;NO&quot;</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">events/listen</span> <span class="tok-nv">input</span> <span class="tok-s">&quot;keyup&quot;</span> <span class="tok-nv">on-change</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, compile the clojurescript code with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>./scripts/watch</code></pre>
</div>
</div>
<div class="paragraph">
<p>This script executes the following behind the scenes, similar to the <code>java</code>
build commands from the previous section, but with our <code>lein</code> build tool:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">rlwrap lein trampoline run -m clojure.main scripts/watch.clj</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
you should have <code>rlwrap</code> installed on your system.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, open the <code>index.html</code> file in a browser.  Typing a year in the textbox
should display an indication of its leap year status.</p>
</div>
<div class="paragraph">
<p>You may have noticed other files in the scripts directory, like <code>build</code> and
<code>release</code>.  These are the same build scripts mentioned in the previous section,
but we will stick with <code>watch</code> here.</p>
</div>
</div>
<div class="sect3">
<h4 id="managing-dependencies"><a class="link" href="#managing-dependencies">4.4.3. Managing dependencies</a></h4>
<div class="paragraph">
<p>The real purpose of using Leiningen for the ClojureScript compilation process is to automate
the retrieval of dependencies.  This is dramatically simpler than retrieving them manually.</p>
</div>
<div class="paragraph">
<p>The dependencies, among other parameters, are declared in the <code>project.clj</code> file and have
this form (from <strong>mies</strong> template):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defproject </span><span class="tok-nv">leapyears</span> <span class="tok-s">&quot;0.1.0-SNAPSHOT&quot;</span>
  <span class="tok-ss">:description</span> <span class="tok-s">&quot;FIXME: write this!&quot;</span>
  <span class="tok-ss">:url</span> <span class="tok-s">&quot;http://example.com/FIXME&quot;</span>
  <span class="tok-ss">:dependencies</span> <span class="tok-p">[[</span><span class="tok-nv">org.clojure/clojure</span> <span class="tok-s">&quot;1.8.0&quot;</span><span class="tok-p">]</span>
                 <span class="tok-p">[</span><span class="tok-nv">org.clojure/clojurescript</span> <span class="tok-s">&quot;1.7.228&quot;</span><span class="tok-p">]</span>
                 <span class="tok-p">[</span><span class="tok-nv">org.clojure/data.json</span> <span class="tok-s">&quot;0.2.6&quot;</span><span class="tok-p">]]</span>
  <span class="tok-ss">:jvm-opts</span> <span class="tok-o">^</span><span class="tok-ss">:replace</span> <span class="tok-p">[</span><span class="tok-s">&quot;-Xmx1g&quot;</span> <span class="tok-s">&quot;-server&quot;</span><span class="tok-p">]</span>
  <span class="tok-ss">:node-dependencies</span> <span class="tok-p">[[</span><span class="tok-nv">source-map-support</span> <span class="tok-s">&quot;0.3.2&quot;</span><span class="tok-p">]]</span>
  <span class="tok-ss">:plugins</span> <span class="tok-p">[[</span><span class="tok-nv">lein-npm</span> <span class="tok-s">&quot;0.5.0&quot;</span><span class="tok-p">]]</span>
  <span class="tok-ss">:source-paths</span> <span class="tok-p">[</span><span class="tok-s">&quot;src&quot;</span> <span class="tok-s">&quot;target/classes&quot;</span><span class="tok-p">]</span>
  <span class="tok-ss">:clean-targets</span> <span class="tok-p">[</span><span class="tok-s">&quot;out&quot;</span> <span class="tok-s">&quot;release&quot;</span><span class="tok-p">]</span>
  <span class="tok-ss">:target-path</span> <span class="tok-s">&quot;target&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And here is a brief explanation of the properties relevant for ClojureScript:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:dependencies</code>: a vector of dependencies that your project needs.</p>
</li>
<li>
<p><code>:clean-targets</code>: a vector of paths that <code>lein clean</code> should delete.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The dependencies in ClojureScript are packaged using <code>jar</code> files. If you are coming from
Clojure or any JVM language, <code>jar</code> files will be very familiar to you. But if you
aren&#8217;t familiar with them, do not worry: a .jar file is like a plain zip file that contains
the <code>project.clj</code> for the library, some metadata, and the ClojureScript sources. The
packaging will be explained in another section.</p>
</div>
<div class="paragraph">
<p>Clojure packages are often published on <a href="http://clojars.org">Clojars</a>; also you
can find many different third party libraries on the
<a href="https://github.com/clojure/clojurescript/wiki#libraries">ClojureScript Wiki</a>.</p>
</div>
<div class="paragraph">
<p>To understand dependencies better, we are going to replace the DOM utiltiles of the Google Closure
library with a third party library for interacting with the DOM.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start by adding <code>[prismatic/dommy "1.1.0"]</code> at the end of the <code>:dependencies</code> vector in
<strong>project.clj</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-ss">:dependencies</span> <span class="tok-p">[[</span><span class="tok-nv">org.clojure/clojure</span> <span class="tok-s">&quot;1.8.0&quot;</span><span class="tok-p">]</span>
               <span class="tok-p">[</span><span class="tok-nv">org.clojure/clojurescript</span> <span class="tok-s">&quot;1.7.228&quot;</span><span class="tok-p">]</span>
               <span class="tok-p">[</span><span class="tok-nv">org.clojure/data.json</span> <span class="tok-s">&quot;0.2.6&quot;</span><span class="tok-p">]</span>
               <span class="tok-p">[</span><span class="tok-nv">prismatic/dommy</span> <span class="tok-s">&quot;1.1.0&quot;</span><span class="tok-p">]]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>At this moment you should restart the <code>watch</code> process that we had started at the beginning
of this subchapter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>./scripts/watch
Retrieving prismatic/dommy/1.1.0/dommy-1.1.0.pom from clojars
Retrieving prismatic/dommy/1.1.0/dommy-1.1.0.jar from clojars
Building ...
... <span class="tok-k">done</span>. Elapsed 0.227999601 seconds
Watching paths: /home/niwi/cljsbook/playground/leapyears/src</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can observe that the dommy dependency is successfully downloaded, and then the
watch process is started.  In fact, Leiningen will ensure all dependencies are
downloaded before performing any tasks.</p>
</div>
<div class="paragraph">
<p>Now it&#8217;s time to write some code. Replace the contents of the <code>src/leapyear/core.cljs</code>
with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">leapyears.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">dommy.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">dom</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">cljs.reader</span> <span class="tok-ss">:refer</span> <span class="tok-p">(</span><span class="tok-nf">read-string</span><span class="tok-p">)]))</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">input</span> <span class="tok-p">(</span><span class="tok-nf">dom/sel1</span> <span class="tok-ss">:#year</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">result</span> <span class="tok-p">(</span><span class="tok-nf">dom/sel1</span> <span class="tok-ss">:#result</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">leap?</span>
  <span class="tok-p">[</span><span class="tok-nv">year</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">and </span><span class="tok-p">(</span><span class="tok-nb">zero? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">4</span><span class="tok-p">))</span>
       <span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">100</span><span class="tok-p">))</span>
       <span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">400</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">on-change</span>
  <span class="tok-p">[</span><span class="tok-nv">event</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">target</span> <span class="tok-p">(</span><span class="tok-nf">.-target</span> <span class="tok-nv">event</span><span class="tok-p">)</span>
        <span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">read-string</span> <span class="tok-p">(</span><span class="tok-nf">dom/value</span> <span class="tok-nv">target</span><span class="tok-p">))]</span>
    <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">leap?</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">dom/set-html!</span> <span class="tok-nv">result</span> <span class="tok-s">&quot;YES&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">dom/set-html!</span> <span class="tok-nv">result</span> <span class="tok-s">&quot;NO&quot;</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">dom/listen!</span> <span class="tok-nv">input</span> <span class="tok-ss">:keyup</span> <span class="tok-nv">on-change</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can observe, the code now looks more “Clojure-friendly.” The host
interoperabilty calls have now been replaced by functions provided by this
third-party library.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-javascript-libraries"><a class="link" href="#using-javascript-libraries">4.5. Using javascript libraries</a></h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="unit-testing"><a class="link" href="#unit-testing">4.6. Unit testing</a></h3>
<div class="paragraph">
<p>As you may expect, testing in <em>ClojureScript</em> consists of the same concepts as
you may know from any other language such as Clojure, Java, Python, JavaScript, etc.</p>
</div>
<div class="paragraph">
<p>Regardless of the language, the main objective of unit testing is to run some test code,
and verify that your code behaves as expected and returns without raising unexpected
exceptions.</p>
</div>
<div class="paragraph">
<p>The immutablity of <em>ClojureScript</em> in fact helps your program to be less
error prone and facilitates testing a little bit. Another advantage of <em>ClojureScript</em>
is that it tends to use plain data instead of complex objects. Building "mock" objects
for testing is greatly simplified.</p>
</div>
<div class="sect3">
<h4 id="first-steps"><a class="link" href="#first-steps">4.6.1. First steps</a></h4>
<div class="paragraph">
<p>The "official" <em>ClojureScript</em> testing framework is in the core library under the "cljs.test"
namespace. It is a very simple library, but it should be more than enough for our purposes.</p>
</div>
<div class="paragraph">
<p>There are other libraries that offer additional features or directly different approaches
for testing, such as <a href="https://github.com/clojure/test.check">test.check</a>. However, they
will not be covered in this subchapter.</p>
</div>
<div class="paragraph">
<p>Start creating a new project using the <strong>mies</strong> leiningen template for experimenting with
tests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>lein new mies appfortesting
<span class="tok-nv">$ </span><span class="tok-nb">cd </span>appfortesting</code></pre>
</div>
</div>
<div class="paragraph">
<p>This project will contain the same layout as we have seen in the <strong>dependency management</strong>
subchapter, so we won’t explain it again.</p>
</div>
<div class="paragraph">
<p>The next step is a creating a directory tree for our tests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>mkdir -p <span class="tok-nb">test</span>/appfortesting
<span class="tok-nv">$ </span>touch <span class="tok-nb">test</span>/appfortesting/core_tests.cljs</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, we should adapt the existing <code>watch.clj</code> script to work with this newly created
test directory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.build.api</span> <span class="tok-ss">:as</span> <span class="tok-nv">b</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">b/watch</span> <span class="tok-p">(</span><span class="tok-nf">b/inputs</span> <span class="tok-s">&quot;test&quot;</span> <span class="tok-s">&quot;src&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">{</span><span class="tok-ss">:main</span> <span class="tok-ss">&#39;appfortesting.core_tests</span>
   <span class="tok-ss">:target</span> <span class="tok-ss">:nodejs</span>
   <span class="tok-ss">:output-to</span> <span class="tok-s">&quot;out/appfortesting.js&quot;</span>
   <span class="tok-ss">:output-dir</span> <span class="tok-s">&quot;out&quot;</span>
   <span class="tok-ss">:verbose</span> <span class="tok-nv">true</span><span class="tok-p">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This new script will compile and watch both directories "src" and "test", and
sets the new entry point to the <code>appfortesting.core_tests</code> namespace.</p>
</div>
<div class="paragraph">
<p>Next, write some test code into the <code>core_tests.cljs</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">appfortesting.core-tests</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">cljs.test</span> <span class="tok-ss">:as</span> <span class="tok-nv">t</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">t/deftest</span> <span class="tok-nv">my-first-test</span>
  <span class="tok-p">(</span><span class="tok-nf">t/is</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-nv">*main-cli-fn*</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nf">t/run-tests</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The relevant part of that code snippet is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">t/deftest</span> <span class="tok-nv">my-first-test</span>
  <span class="tok-p">(</span><span class="tok-nf">t/is</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>deftest</code> macro is a basic primitive for defining our tests. It takes a name as its first
parameter, followed by one or multiple "asserts" using the <code>is</code> macro. In that example,
the assert tries check that <code>(= 1 2)</code> is true.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s try to run this. First start the watch process:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>./scripts/watch
Building ...
Copying jar:file:/home/niwi/.m2/repository/org/clojure/clojurescript/1.7.228/clojurescript-1.7.228.jar!/cljs/core.cljs to out/cljs/core.cljs
Reading analysis cache <span class="tok-k">for</span> jar:file:/home/niwi/.m2/repository/org/clojure/clojurescript/1.7.228/clojurescript-1.7.228.jar!/cljs/core.cljs
Compiling out/cljs/core.cljs
... <span class="tok-k">done</span>. Elapsed 3.862126827 seconds
Watching paths: /home/niwi/cljsbook/playground/appfortesting/test, /home/niwi/cljsbook/playground/appfortesting/src</code></pre>
</div>
</div>
<div class="paragraph">
<p>And when the compilation is finished, try to run the compiled file with <code>nodejs</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>node out/appfortesting.js

Testing appfortesting.core-tests

FAIL in <span class="tok-o">(</span>my-first-test<span class="tok-o">)</span> <span class="tok-o">(</span>cljs/test.js:374:14<span class="tok-o">)</span>
expected: <span class="tok-o">(=</span> <span class="tok-m">1</span> 2<span class="tok-o">)</span>
  actual: <span class="tok-o">(</span>not <span class="tok-o">(=</span> <span class="tok-m">1</span> 2<span class="tok-o">))</span>

Ran <span class="tok-m">1</span> tests containing <span class="tok-m">1</span> assertions.
<span class="tok-m">1</span> failures, <span class="tok-m">0</span> errors.</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can observe that the expected assert failure is successfully printed in the console. To
fix the test, just change the <code>=</code> with <code>not=</code> and run the file again:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>node out/appfortesting.js

Testing appfortesting.core-tests

Ran <span class="tok-m">1</span> tests containing <span class="tok-m">1</span> assertions.
<span class="tok-m">0</span> failures, <span class="tok-m">0</span> errors.</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is fine to test these kinds of assertions, but they are not very useful. Let&#8217;s go to
test some application code. For this, we will use a function to check if a year is a leap year
or not. Then, write the following content to the <code>src/appfortesting/core.clj</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">leap?</span>
  <span class="tok-p">[</span><span class="tok-nv">year</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">and </span><span class="tok-p">(</span><span class="tok-nb">zero? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">4</span><span class="tok-p">))</span>
       <span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">100</span><span class="tok-p">))</span>
       <span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">400</span><span class="tok-p">))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, write a new test case to check that our new function defined in the
<code>appfortesting.core</code> namespace works properly. This is the new content
of the <code>core_tests.cljs</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">appfortesting.core-tests</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">cljs.test</span> <span class="tok-ss">:as</span> <span class="tok-nv">t</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">appfortesting.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">core</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">t/deftest</span> <span class="tok-nv">my-first-test</span>
  <span class="tok-p">(</span><span class="tok-nf">t/is</span> <span class="tok-p">(</span><span class="tok-nb">not= </span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">t/deftest</span> <span class="tok-nv">my-second-test</span>
  <span class="tok-p">(</span><span class="tok-nf">t/is</span> <span class="tok-p">(</span><span class="tok-nf">core/leap?</span> <span class="tok-mi">1980</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nf">t/is</span> <span class="tok-p">(</span><span class="tok-nb">not </span><span class="tok-p">(</span><span class="tok-nf">core/leap?</span> <span class="tok-mi">1981</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-nv">*main-cli-fn*</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nf">t/run-tests</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Run the compiled file again to see that there are now two tests running.  The
first test fails as it did before, but our leap year test passes as expected.</p>
</div>
</div>
<div class="sect3">
<h4 id="async-testing"><a class="link" href="#async-testing">4.6.2. Async Testing</a></h4>
<div class="paragraph">
<p>One of the peculiarities of <em>ClojureScript</em> is that it runs on asynchronous,
single-threaded execution environments, and this has its own challenges.</p>
</div>
<div class="paragraph">
<p>In async execution environments, we should be able to test asynchronous
functions.  To this end, the <em>ClojureScript</em> testing library offers the <code>async</code>
macro, allowing you to create tests that play well with asynchronous code.</p>
</div>
<div class="paragraph">
<p>First, we need to write a function that works in an asynchronous way. For this
purpose, we will create the <code>async-leap?</code> predicate that will do the same operation but
asychronously return a result using a callback:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">async-leap?</span>
  <span class="tok-p">[</span><span class="tok-nv">year</span> <span class="tok-nv">callback</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">js/setImmediate</span>
   <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[]</span>
     <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">result</span> <span class="tok-p">(</span><span class="tok-nb">and </span><span class="tok-p">(</span><span class="tok-nb">zero? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">4</span><span class="tok-p">))</span>
                       <span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">100</span><span class="tok-p">))</span>
                       <span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">400</span><span class="tok-p">)))]</span>
       <span class="tok-p">(</span><span class="tok-nf">callback</span> <span class="tok-nv">result</span><span class="tok-p">)))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The JavaScript function <code>setImmediate</code> is used to emulate an asynchronous task, and the callback
is executed with the result of that predicate.</p>
</div>
<div class="paragraph">
<p>To test it, we should write a test case using the previously mentioned <code>async</code> macro:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">t/deftest</span> <span class="tok-nv">my-async-test</span>
  <span class="tok-p">(</span><span class="tok-nf">t/async</span> <span class="tok-nv">done</span>
    <span class="tok-p">(</span><span class="tok-nf">core/async-leap?</span> <span class="tok-mi">1980</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">result</span><span class="tok-p">]</span>
                             <span class="tok-p">(</span><span class="tok-nf">t/is</span> <span class="tok-p">(</span><span class="tok-nb">true? </span><span class="tok-nv">result</span><span class="tok-p">))</span>
                             <span class="tok-p">(</span><span class="tok-nf">done</span><span class="tok-p">)))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>done</code> function exposed by the <code>async</code> macro should be called after the asynchronous
operation is finished and all assertions have run.</p>
</div>
<div class="paragraph">
<p>It is very important to execute the <code>done</code> function only once. Omitting or
executing it twice may cause strange behavior and should be avoided.</p>
</div>
</div>
<div class="sect3">
<h4 id="fixtures"><a class="link" href="#fixtures">4.6.3. Fixtures</a></h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect3">
<h4 id="integrating-with-ci"><a class="link" href="#integrating-with-ci">4.6.4. Integrating with CI</a></h4>
<div class="paragraph">
<p>Most continuous integration tools and services expect that test scripts you
provide return a standard exit code. But the ClojureScript test framework
cannot customize this exit code without some configuration, because JavaScript
lacks a universal exit code API for ClojureScript to use.</p>
</div>
<div class="paragraph">
<p>To fix this, the <em>ClojureScript</em> test framework provides an avenue for
executing custom code after the tests are done. This is where you are expected
to set the environment-specific exit code depending on the final test status:
<code>0</code> for success, <code>1</code> for failure.</p>
</div>
<div class="paragraph">
<p>Insert this code at the end of <code>core_tests.cljs</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defmethod </span><span class="tok-nv">t/report</span> <span class="tok-p">[</span><span class="tok-ss">::t/default</span> <span class="tok-ss">:end-run-tests</span><span class="tok-p">]</span>
  <span class="tok-p">[</span><span class="tok-nv">m</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">t/successful?</span> <span class="tok-nv">m</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-p">(</span><span class="tok-nf">.-exitCode</span> <span class="tok-nv">js/process</span><span class="tok-p">)</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-p">(</span><span class="tok-nf">.-exitCode</span> <span class="tok-nv">js/process</span><span class="tok-p">)</span> <span class="tok-mi">1</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, you may check the exit code of the test script after running:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>node out/appfortesting.js
<span class="tok-nv">$ </span><span class="tok-nb">echo</span> <span class="tok-nv">$?</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This code snippet obviously assumes that you are running the tests using <strong>nodejs</strong>.
If you are running your script in another execution environment, you should be
aware of how you can set the exit code in that environment and modify the previous snippet
accordingly.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="language-advanced-topics"><a class="link" href="#language-advanced-topics">5. Language (advanced topics)</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter intends to explain some advanced topics that are part of the language and
that does not fits in the first chapter. The good candidates for this section are
transducers, core protocols, transients, metadata. In summary: topics that are not
mandatory for understand the language.</p>
</div>
<div class="sect2">
<h3 id="transducers"><a class="link" href="#transducers">5.1. Transducers</a></h3>
<div class="sect3">
<h4 id="data-transformation"><a class="link" href="#data-transformation">5.1.1. Data transformation</a></h4>
<div class="paragraph">
<p>ClojureScript offers a rich vocabulary for data transformation in terms of the sequence abstraction,
which makes such transformations highly general and composable. Let&#8217;s see how we can combine several
collection processing functions to build new ones. We will be using a simple problem throughout this
section: splitting grape clusters, filtering out the rotten ones, and cleaning them. We have a collection
of grape clusters like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">grape-clusters</span> <span class="tok-p">[{</span><span class="tok-ss">:grapes</span> <span class="tok-p">[{</span><span class="tok-ss">:rotten?</span> <span class="tok-nv">false</span> <span class="tok-ss">:clean?</span> <span class="tok-nv">false</span><span class="tok-p">}</span>
                               <span class="tok-p">{</span><span class="tok-ss">:rotten?</span> <span class="tok-nv">true</span> <span class="tok-ss">:clean?</span> <span class="tok-nv">false</span><span class="tok-p">}]</span>
                      <span class="tok-ss">:color</span> <span class="tok-ss">:green</span><span class="tok-p">}</span>
                     <span class="tok-p">{</span><span class="tok-ss">:grapes</span> <span class="tok-p">[{</span><span class="tok-ss">:rotten?</span> <span class="tok-nv">true</span> <span class="tok-ss">:clean?</span> <span class="tok-nv">false</span><span class="tok-p">}</span>
                               <span class="tok-p">{</span><span class="tok-ss">:rotten?</span> <span class="tok-nv">false</span> <span class="tok-ss">:clean?</span> <span class="tok-nv">false</span><span class="tok-p">}]</span>
                      <span class="tok-ss">:color</span> <span class="tok-ss">:black</span><span class="tok-p">}])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We are interested in splitting the grape clusters into individual grapes, discarding the rotten ones
and cleaning the remaining grapes so they are ready for eating. We are well-equipped in ClojureScript
for this data transformation task; we could implement it using the familiar <code>map</code>, <code>filter</code> and <code>mapcat</code>
functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">split-cluster</span>
  <span class="tok-p">[</span><span class="tok-nv">c</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-ss">:grapes</span> <span class="tok-nv">c</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">not-rotten</span>
  <span class="tok-p">[</span><span class="tok-nv">g</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">not </span><span class="tok-p">(</span><span class="tok-ss">:rotten?</span> <span class="tok-nv">g</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">clean-grape</span>
  <span class="tok-p">[</span><span class="tok-nv">g</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-nv">g</span> <span class="tok-ss">:clean?</span> <span class="tok-nv">true</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-nv">grape-clusters</span>
     <span class="tok-p">(</span><span class="tok-nb">mapcat </span><span class="tok-nv">split-cluster</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-nv">not-rotten</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">clean-grape</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; ({rotten? false :clean? true} {:rotten? false :clean? true})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example we succintly solved the problem of selecting and cleaning the grapes, and
we can even abstract such transformations by combining the <code>mapcat</code>, <code>filter</code> and <code>map</code> operations
using partial application and function composition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">process-clusters</span>
  <span class="tok-p">(</span><span class="tok-nf">comp</span>
    <span class="tok-p">(</span><span class="tok-nb">partial map </span><span class="tok-nv">clean-grape</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">partial filter </span><span class="tok-nv">not-rotten</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">partial mapcat </span><span class="tok-nv">split-cluster</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">process-clusters</span> <span class="tok-nv">grape-clusters</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; ({rotten? false :clean? true} {:rotten? false :clean? true})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The code is very clean, but it has a few problems. For example, each call to <code>map</code>, <code>filter</code> and
<code>mapcat</code> consumes and produces a sequence that, although lazy, generates intermediate results
that will be discarded. Each sequence is fed to the next step, which also returns a
sequence. Wouldn&#8217;t be great if we could do the transformation in a single transversal of the <code>grape-cluster</code>
collection?</p>
</div>
<div class="paragraph">
<p>Another problem is that even though our <code>process-clusters</code> function works with any sequence, we
can&#8217;t reuse it with anything that is not a sequence. Imagine that instead of having the grape cluster
collection available in memory it is being pushed to us asynchronously in a stream. In that situation
we couldn&#8217;t reuse <code>process-clusters</code> since usually <code>map</code>, <code>filter</code> and <code>mapcat</code> have concrete
implementations depending on the type.</p>
</div>
</div>
<div class="sect3">
<h4 id="generalizing-to-process-transformations"><a class="link" href="#generalizing-to-process-transformations">5.1.2. Generalizing to process transformations</a></h4>
<div class="paragraph">
<p>The process of mapping, filtering or mapcatting isn&#8217;t necesarily tied to a concrete type, but we
keep reimplementing them for different types. Let&#8217;s see how we can generalize such processes to
be context independent. We&#8217;ll start by implementing naive versions of <code>map</code> and <code>filter</code> first to
see how they work internally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-map</span>
  <span class="tok-p">[</span><span class="tok-nv">f</span> <span class="tok-nv">coll</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">when-let </span><span class="tok-p">[</span><span class="tok-nv">s</span> <span class="tok-p">(</span><span class="tok-nb">seq </span><span class="tok-nv">coll</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-nb">cons </span><span class="tok-p">(</span><span class="tok-nf">f</span> <span class="tok-p">(</span><span class="tok-nb">first </span><span class="tok-nv">s</span><span class="tok-p">))</span> <span class="tok-p">(</span><span class="tok-nf">my-map</span> <span class="tok-nv">f</span> <span class="tok-p">(</span><span class="tok-nb">rest </span><span class="tok-nv">s</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-nf">my-map</span> <span class="tok-nb">inc </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (1 2 3)</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-filter</span>
  <span class="tok-p">[</span><span class="tok-nv">pred</span> <span class="tok-nv">coll</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">when-let </span><span class="tok-p">[</span><span class="tok-nv">s</span> <span class="tok-p">(</span><span class="tok-nb">seq </span><span class="tok-nv">coll</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">f</span> <span class="tok-p">(</span><span class="tok-nb">first </span><span class="tok-nv">s</span><span class="tok-p">)</span>
          <span class="tok-nv">r</span> <span class="tok-p">(</span><span class="tok-nb">rest </span><span class="tok-nv">s</span><span class="tok-p">)]</span>
      <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">pred</span> <span class="tok-nv">f</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-nb">cons </span><span class="tok-nv">f</span> <span class="tok-p">(</span><span class="tok-nf">my-filter</span> <span class="tok-nv">pred</span> <span class="tok-nv">r</span><span class="tok-p">))</span>
        <span class="tok-p">(</span><span class="tok-nf">my-filter</span> <span class="tok-nv">pred</span> <span class="tok-nv">r</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-nf">my-filter</span> <span class="tok-nv">odd?</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (1)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As we can see, they both assume that they receive a seqable and return a sequence. Like many recursive
functions they can be implemented in terms of the already familiar <code>reduce</code> function. Note that functions
that are given to reduce receive an accumulator and an input and return the next accumulator. We&#8217;ll call
these types of functions reducing functions from now on.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-mapr</span>
  <span class="tok-p">[</span><span class="tok-nv">f</span> <span class="tok-nv">coll</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>         <span class="tok-c1">;; reducing function</span>
            <span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">acc</span> <span class="tok-p">(</span><span class="tok-nf">f</span> <span class="tok-nv">input</span><span class="tok-p">)))</span>
          <span class="tok-p">[]</span>                      <span class="tok-c1">;; initial value</span>
          <span class="tok-nv">coll</span><span class="tok-p">))</span>                  <span class="tok-c1">;; collection to reduce</span>

<span class="tok-p">(</span><span class="tok-nf">my-mapr</span> <span class="tok-nb">inc </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [1 2 3]</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-filterr</span>
  <span class="tok-p">[</span><span class="tok-nv">pred</span> <span class="tok-nv">coll</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>         <span class="tok-c1">;; reducing function</span>
            <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">pred</span> <span class="tok-nv">input</span><span class="tok-p">)</span>
              <span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">)</span>
              <span class="tok-nv">acc</span><span class="tok-p">))</span>
          <span class="tok-p">[]</span>                      <span class="tok-c1">;; initial value</span>
          <span class="tok-nv">coll</span><span class="tok-p">))</span>                  <span class="tok-c1">;; collection to reduce</span>

<span class="tok-p">(</span><span class="tok-nf">my-filterr</span> <span class="tok-nv">odd?</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [1]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve made the previous versions more general since using <code>reduce</code> makes our functions work on any thing
that is reducible, not just sequences. However you may have noticed that, even though <code>my-mapr</code> and <code>my-filterr</code>
don&#8217;t know anything about the source (<code>coll</code>) they are still tied to the output they produce (a vector) both
with the initial value of the reduce (<code>[]</code>) and the hardcoded <code>conj</code> operation in the body of the reducing
function. We could have accumulated results in another data structure, for example a lazy sequence, but
we&#8217;d have to rewrite the functions in order to do so.</p>
</div>
<div class="paragraph">
<p>How can we make these functions truly generic? They shouldn&#8217;t know about either the source of inputs they
are transforming nor the output that is generated. Have you noticed that <code>conj</code> is just another reducing
function? It takes an accumulator and an input and returns another accumulator. So, if we parameterise
the reducing function that <code>my-mapr</code> and <code>my-filterr</code> use, they won&#8217;t know anything about the type of the
result they are building. Let&#8217;s give it a shot:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-mapt</span>
  <span class="tok-p">[</span><span class="tok-nv">f</span><span class="tok-p">]</span>                         <span class="tok-c1">;; function to map over inputs</span>
  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">rfn</span><span class="tok-p">]</span>                   <span class="tok-c1">;; parameterised reducing function</span>
    <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>           <span class="tok-c1">;; transformed reducing function, now it maps `f`!</span>
      <span class="tok-p">(</span><span class="tok-nf">rfn</span> <span class="tok-nv">acc</span> <span class="tok-p">(</span><span class="tok-nf">f</span> <span class="tok-nv">input</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">incer</span> <span class="tok-p">(</span><span class="tok-nf">my-mapt</span> <span class="tok-nv">inc</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-nf">incer</span> <span class="tok-nv">conj</span><span class="tok-p">)</span> <span class="tok-p">[]</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [1 2 3]</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-filtert</span>
  <span class="tok-p">[</span><span class="tok-nv">pred</span><span class="tok-p">]</span>                      <span class="tok-c1">;; predicate to filter out inputs</span>
  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">rfn</span><span class="tok-p">]</span>                   <span class="tok-c1">;; parameterised reducing function</span>
    <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>           <span class="tok-c1">;; transformed reducing function, now it discards values based on `pred`!</span>
      <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">pred</span> <span class="tok-nv">input</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-nf">rfn</span> <span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">)</span>
        <span class="tok-nv">acc</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">only-odds</span> <span class="tok-p">(</span><span class="tok-nf">my-filtert</span> <span class="tok-nv">odd?</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-nf">only-odds</span> <span class="tok-nv">conj</span><span class="tok-p">)</span> <span class="tok-p">[]</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [1]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s a lot of higher-order functions so let&#8217;s break it down for a better understanding of what&#8217;s going
on. We&#8217;ll examine how <code>my-mapt</code> works step by step. The mechanics are similar for <code>my-filtert</code>, so we&#8217;ll
leave it out for now.</p>
</div>
<div class="paragraph">
<p>First of all, <code>my-mapt</code> takes a mapping function; in the example we are giving it <code>inc</code> and getting
another function back. Let&#8217;s replace <code>f</code> with <code>inc</code> to see what we are building:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">incer</span> <span class="tok-p">(</span><span class="tok-nf">my-mapt</span> <span class="tok-nv">inc</span><span class="tok-p">))</span>
<span class="tok-c1">;; (fn [rfn]</span>
<span class="tok-c1">;;   (fn [acc input]</span>
<span class="tok-c1">;;     (rfn acc (inc input))))</span>
<span class="tok-c1">;;               ^^^</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The resulting function is still parameterised to receive a reducing function to which it will delegate,
let&#8217;s see what happens when we call it with <code>conj</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">incer</span> <span class="tok-nv">conj</span><span class="tok-p">)</span>
<span class="tok-c1">;; (fn [acc input]</span>
<span class="tok-c1">;;   (conj acc (inc input)))</span>
<span class="tok-c1">;;    ^^^^</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We get back a reducing function which uses <code>inc</code> to transform the inputs and the <code>conj</code> reducing function
to accumulate the results. In essence, we have defined map as the transformation of a reducing function.
The functions that transform one reducing function into another are called transducers in ClojureScript.</p>
</div>
<div class="paragraph">
<p>To ilustrate the generality of transducers, let&#8217;s use different sources and destinations in our call
to <code>reduce</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-nf">incer</span> <span class="tok-nv">str</span><span class="tok-p">)</span> <span class="tok-s">&quot;&quot;</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; &quot;123&quot;</span>

<span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-nf">only-odds</span> <span class="tok-nv">str</span><span class="tok-p">)</span> <span class="tok-s">&quot;&quot;</span> <span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; &quot;1&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The transducer versions of <code>map</code> and <code>filter</code> transform a process that carries inputs from a source to a
destination but don&#8217;t know anything about where the inputs come from and where they end up. In their
implementation they contain the <em>essence</em> of what they accomplish, independent of context.</p>
</div>
<div class="paragraph">
<p>Now that we know more about transducers we can try to implement our own version of <code>mapcat</code>. We already have
a fundamental piece of it: the <code>map</code> transducer. What <code>mapcat</code> does is map a function over an input and flatten
the resulting structure one level. Let&#8217;s try to implement the catenation part as a transducer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-cat</span>
  <span class="tok-p">[</span><span class="tok-nv">rfn</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-nv">rfn</span> <span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-nf">my-cat</span> <span class="tok-nv">conj</span><span class="tok-p">)</span> <span class="tok-p">[]</span> <span class="tok-p">[[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]])</span>
<span class="tok-c1">;; =&gt; [0 1 2 3 4 5]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>my-cat</code> transducer returns a reducing function that catenates its inputs into the accumulator. It does so
reducing the <code>input</code> reducible with the <code>rfn</code> reducing function and using the accumulator (<code>acc</code>) as the
initial value for such reduction. <code>mapcat</code> is simply the composition of <code>map</code> and <code>cat</code>. The order in which
transducers are composed may seem backwards but it&#8217;ll become clear in a moment.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-mapcat</span>
  <span class="tok-p">[</span><span class="tok-nv">f</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">comp </span><span class="tok-p">(</span><span class="tok-nf">my-mapt</span> <span class="tok-nv">f</span><span class="tok-p">)</span> <span class="tok-nv">my-cat</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">dupe</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">x</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">duper</span> <span class="tok-p">(</span><span class="tok-nf">my-mapcat</span> <span class="tok-nv">dupe</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-nf">duper</span> <span class="tok-nv">conj</span><span class="tok-p">)</span> <span class="tok-p">[]</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [0 0 1 1 2 2]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transducers-in-clojurescript-core"><a class="link" href="#transducers-in-clojurescript-core">5.1.3. Transducers in ClojureScript core</a></h4>
<div class="paragraph">
<p>Some of the ClojureScript core functions like <code>map</code>, <code>filter</code> and <code>mapcat</code> support an arity 1 version
that returns a transducer. Let&#8217;s revisit our definition of <code>process-cluster</code> and define it in terms of
transducers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">process-clusters</span>
  <span class="tok-p">(</span><span class="tok-nf">comp</span>
    <span class="tok-p">(</span><span class="tok-nb">mapcat </span><span class="tok-nv">split-cluster</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-nv">not-rotten</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">clean-grape</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A few things changed since our previous definition <code>process-clusters</code>. First of all, we are using the
transducer-returning versions of <code>mapcat</code>, <code>filter</code> and <code>map</code> instead of partially applying them for
working on sequences.</p>
</div>
<div class="paragraph">
<p>Also you may have noticed that the order in which they are composed is reversed, they appear in the order
they are executed. Note that all <code>map</code>, <code>filter</code> and <code>mapcat</code> return a transducer. <code>filter</code> transforms the
reducing function returned by <code>map</code>, applying the filtering before proceeding; <code>mapcat</code> transforms the reducing
function returned by <code>filter</code>, applying the mapping and catenation before proceeding.</p>
</div>
<div class="paragraph">
<p>One of the powerful properties of transducers is that they are combined using regular function composition.
What&#8217;s even more elegant is that the composition of various transducers is itself a transducer! This means
that our <code>process-cluster</code> is a transducer too, so we have defined a composable and context-independent
algorithmic transformation.</p>
</div>
<div class="paragraph">
<p>Many of the core ClojureScript functions accept a transducer, let&#8217;s look at some examples with our newly
created <code>process-cluster</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">into </span><span class="tok-p">[]</span> <span class="tok-nv">process-clusters</span> <span class="tok-nv">grape-clusters</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [{:rotten? false, :clean? true} {:rotten? false, :clean? true}]</span>

<span class="tok-p">(</span><span class="tok-nf">sequence</span> <span class="tok-nv">process-clusters</span> <span class="tok-nv">grape-clusters</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; ({:rotten? false, :clean? true} {:rotten? false, :clean? true})</span>

<span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-nf">process-clusters</span> <span class="tok-nv">conj</span><span class="tok-p">)</span> <span class="tok-p">[]</span> <span class="tok-nv">grape-clusters</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [{:rotten? false, :clean? true} {:rotten? false, :clean? true}]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since using <code>reduce</code> with the reducing function returned from a transducer is so common, there is
a function for reducing with a transformation called <code>transduce</code>. We can now rewrite the previous call
to <code>reduce</code> using <code>transduce</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">transduce</span> <span class="tok-nv">process-clusters</span> <span class="tok-nb">conj </span><span class="tok-p">[]</span> <span class="tok-nv">grape-clusters</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [{:rotten? false, :clean? true} {:rotten? false, :clean? true}]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="initialisation"><a class="link" href="#initialisation">5.1.4. Initialisation</a></h4>
<div class="paragraph">
<p>In the last example we provided an initial value to the <code>transduce</code> function (<code>[]</code>) but we can omit it
and get the same result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">transduce</span> <span class="tok-nv">process-clusters</span> <span class="tok-nb">conj </span><span class="tok-nv">grape-clusters</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [{:rotten? false, :clean? true} {:rotten? false, :clean? true}]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>What&#8217;s going on here? How can <code>transduce</code> know what initial value use as an accumulator when we haven&#8217;t
specified it? Try calling <code>conj</code> without any arguments and see what happens:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">conj</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; []</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>conj</code> function has a arity 0 version that returns an empty vector but is not the only reducing function
that supports arity 0. Let&#8217;s explore some others:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">+</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0</span>

<span class="tok-p">(</span><span class="tok-nf">*</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nf">str</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;&quot;</span>

<span class="tok-p">(</span><span class="tok-nb">= identity </span><span class="tok-p">(</span><span class="tok-nf">comp</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The reducing function returned by transducers must support the arity 0 as well, which will typically delegate
to the transformed reducing function. There is no sensible implementation of the arity 0 for the transducers
we have implemented so far, so we&#8217;ll simply call the reducing function without arguments. Here&#8217;s how our
modified <code>my-mapt</code> could look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-mapt</span>
  <span class="tok-p">[</span><span class="tok-nv">f</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">rfn</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">fn</span>
      <span class="tok-p">([]</span> <span class="tok-p">(</span><span class="tok-nf">rfn</span><span class="tok-p">))</span>                <span class="tok-c1">;; arity 0 that delegates to the reducing fn</span>
      <span class="tok-p">([</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>
        <span class="tok-p">(</span><span class="tok-nf">rfn</span> <span class="tok-nv">acc</span> <span class="tok-p">(</span><span class="tok-nf">f</span> <span class="tok-nv">input</span><span class="tok-p">))))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The call to the arity 0 of the reducing function returned by a transducer will call the arity 0 version of
every nested reducing function, eventually calling the outermost reducing function. Let&#8217;s see an example with
our already defined <code>process-clusters</code> transducer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">((</span><span class="tok-nf">process-clusters</span> <span class="tok-nv">conj</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; []</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The call to the arity 0 flows through the transducer stack, eventually calling <code>(conj)</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="stateful-transducers"><a class="link" href="#stateful-transducers">5.1.5. Stateful transducers</a></h4>
<div class="paragraph">
<p>So far we&#8217;ve only seen purely functional transducer; they don&#8217;t have any implicit state and are very
predictable. However, there are many data transformation functions that are inherently stateful, like
<code>take</code>. <code>take</code> receives a number <code>n</code> of elements to keep and a collection and returns a collection with at
most <code>n</code> elements.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">take </span><span class="tok-mi">10</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">100</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; (0 1 2 3 4 5 6 7 8 9)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s step back for a bit and learn about the early termination of the <code>reduce</code> function. We can wrap an
accumulator in a type called <code>reduced</code> for telling <code>reduce</code> that the reduction process should terminate
immediately. Let&#8217;s see an example of a reduction that aggregates the inputs in a collection and finishes
as soon as there are 10 elements in the accumulator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>
          <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-nv">acc</span><span class="tok-p">)</span> <span class="tok-mi">10</span><span class="tok-p">)</span>
            <span class="tok-p">(</span><span class="tok-nf">reduced</span> <span class="tok-nv">acc</span><span class="tok-p">)</span>
            <span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">)))</span>
         <span class="tok-p">[]</span>
         <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">100</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; [0 1 2 3 4 5 6 7 8 9]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since transducers are modifications of reducing functions they also use <code>reduced</code> for early termination.
Note that stateful transducers may need to do some cleanup before the process terminates, so they
must support an arity 1 as a "completion" step. Usually, like with arity 0, this arity will simply delegate
to the transformed reducing function&#8217;s arity 1.</p>
</div>
<div class="paragraph">
<p>Knowing this we are able to write stateful transducers like <code>take</code>. We&#8217;ll be using mutable state internally
for tracking the number of inputs we have seen so far, and wrap the accumulator in a <code>reduced</code> as soon as
we&#8217;ve seen enough elements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-take</span>
  <span class="tok-p">[</span><span class="tok-nv">n</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">rfn</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">remaining</span> <span class="tok-p">(</span><span class="tok-nf">volatile!</span> <span class="tok-nv">n</span><span class="tok-p">)]</span>
      <span class="tok-p">(</span><span class="tok-nf">fn</span>
        <span class="tok-p">([]</span> <span class="tok-p">(</span><span class="tok-nf">rfn</span><span class="tok-p">))</span>
        <span class="tok-p">([</span><span class="tok-nv">acc</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">rfn</span> <span class="tok-nv">acc</span><span class="tok-p">))</span>
        <span class="tok-p">([</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>
          <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nb">rem </span><span class="tok-o">@</span><span class="tok-nv">remaining</span>
                <span class="tok-nv">nr</span> <span class="tok-p">(</span><span class="tok-nf">vswap!</span> <span class="tok-nv">remaining</span> <span class="tok-nv">dec</span><span class="tok-p">)</span>
                <span class="tok-nv">result</span> <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-nv">rem</span><span class="tok-p">)</span>
                         <span class="tok-p">(</span><span class="tok-nf">rfn</span> <span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">)</span>   <span class="tok-c1">;; we still have items to take</span>
                         <span class="tok-nv">acc</span><span class="tok-p">)]</span>             <span class="tok-c1">;; we&#39;re done, acc becomes the result</span>
            <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">not </span><span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-nv">nr</span><span class="tok-p">))</span>
              <span class="tok-p">(</span><span class="tok-nf">ensure-reduced</span> <span class="tok-nv">result</span><span class="tok-p">)</span>      <span class="tok-c1">;; wrap result in reduced if not already</span>
              <span class="tok-nv">result</span><span class="tok-p">)))))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a simplified version of the <code>take</code> function present in ClojureScript core. There are
a few things to note here so let&#8217;s break it up in pieces to understand it better.</p>
</div>
<div class="paragraph">
<p>The first thing to notice is that we are creating a mutable value inside the transducer. Note
that we don&#8217;t create it until we receive a reducing function to transform. If we created it before
returning the transducer we couldn&#8217;t use <code>my-take</code> more than once. Since the transducer is handed
a reducing function to transform each time it is used, we can use it multiple times and the mutable
variable will be created in every use.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">rfn</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">remaining</span> <span class="tok-p">(</span><span class="tok-nf">volatile!</span> <span class="tok-nv">n</span><span class="tok-p">)]</span> <span class="tok-c1">;; make sure to create mutable variables inside the transducer</span>
    <span class="tok-p">(</span><span class="tok-nf">fn</span>
      <span class="tok-c1">;; ...</span>
<span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">take-five</span> <span class="tok-p">(</span><span class="tok-nf">my-take</span> <span class="tok-mi">5</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">transduce</span> <span class="tok-nv">take-five</span> <span class="tok-nb">conj </span><span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">100</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; [0 1 2 3 4]</span>

<span class="tok-p">(</span><span class="tok-nf">transduce</span> <span class="tok-nv">take-five</span> <span class="tok-nb">conj </span><span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">100</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; [0 1 2 3 4]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s now dig into the reducing function returned from <code>my-take</code>. First of all we <code>deref</code> the volatile
to get the number of elements that remain to be taken and decrement it to get the next remaining value.
If there are still remaining items to take, we call <code>rfn</code> passing the accumulator and input; if not, we
already have the final result.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">([</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nb">rem </span><span class="tok-o">@</span><span class="tok-nv">remaining</span>
        <span class="tok-nv">nr</span> <span class="tok-p">(</span><span class="tok-nf">vswap!</span> <span class="tok-nv">remaining</span> <span class="tok-nv">dec</span><span class="tok-p">)</span>
        <span class="tok-nv">result</span> <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-nv">rem</span><span class="tok-p">)</span>
                 <span class="tok-p">(</span><span class="tok-nf">rfn</span> <span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">)</span>
                 <span class="tok-nv">acc</span><span class="tok-p">)]</span>
    <span class="tok-c1">;; ...</span>
<span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The body of <code>my-take</code> should be obvious by now. We check whether there are still items to be processed
using the next remainder (<code>nr</code>) and, if not, wrap the result in a <code>reduced</code> using the <code>ensure-reduced</code>
function. <code>ensure-reduced</code> will wrap the value in a <code>reduced</code> if it&#8217;s not reduced already or simply return
the value if it&#8217;s already reduced. In case we are not done yet, we return the accumulated <code>result</code> for
further processing.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">not </span><span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-nv">nr</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nf">ensure-reduced</span> <span class="tok-nv">result</span><span class="tok-p">)</span>
  <span class="tok-nv">result</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve seen an example of a stateful transducer but it didn&#8217;t do anything in its completion step. Let&#8217;s
see an example of a transducer that uses the completion step to flush an accumulated value. We&#8217;ll
implement a simplified version of <code>partition-all</code>, which given a <code>n</code> number of elements converts the inputs
in vectors of size <code>n</code>. For understanding its purpose better let&#8217;s see what the arity 2 version gives us when
providing a number and a collection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">partition-all</span> <span class="tok-mi">3</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">10</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; ((0 1 2) (3 4 5) (6 7 8) (9))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The transducer returning function of <code>partition-all</code> will take a number <code>n</code> and return a transducer that groups
inputs in vectors of size <code>n</code>. In the completion step it will check if there is an accumulated result and, if so,
add it to the result. Here&#8217;s a simplified version of ClojureScript core <code>partition-all</code> function, where <code>array-list</code>
is a wrapper for a mutable JavaScript array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-partition-all</span>
  <span class="tok-p">[</span><span class="tok-nv">n</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">rfn</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">array-list</span><span class="tok-p">)]</span>
      <span class="tok-p">(</span><span class="tok-nf">fn</span>
        <span class="tok-p">([]</span> <span class="tok-p">(</span><span class="tok-nf">rfn</span><span class="tok-p">))</span>
        <span class="tok-p">([</span><span class="tok-nv">result</span><span class="tok-p">]</span>
          <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">result</span> <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">.isEmpty</span> <span class="tok-nv">a</span><span class="tok-p">)</span>                  <span class="tok-c1">;; no inputs accumulated, don&#39;t have to modify result</span>
                         <span class="tok-nv">result</span>
                         <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">v</span> <span class="tok-p">(</span><span class="tok-nf">vec</span> <span class="tok-p">(</span><span class="tok-nf">.toArray</span> <span class="tok-nv">a</span><span class="tok-p">))]</span>
                           <span class="tok-p">(</span><span class="tok-nf">.clear</span> <span class="tok-nv">a</span><span class="tok-p">)</span>                    <span class="tok-c1">;; flush array contents for garbage collection</span>
                           <span class="tok-p">(</span><span class="tok-nf">unreduced</span> <span class="tok-p">(</span><span class="tok-nf">rfn</span> <span class="tok-nv">result</span> <span class="tok-nv">v</span><span class="tok-p">))))]</span> <span class="tok-c1">;; pass to `rfn`, removing the reduced wrapper if present</span>
            <span class="tok-p">(</span><span class="tok-nf">rfn</span> <span class="tok-nv">result</span><span class="tok-p">)))</span>
        <span class="tok-p">([</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>
          <span class="tok-p">(</span><span class="tok-nf">.add</span> <span class="tok-nv">a</span> <span class="tok-nv">input</span><span class="tok-p">)</span>
          <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">== </span><span class="tok-nv">n</span> <span class="tok-p">(</span><span class="tok-nf">.size</span> <span class="tok-nv">a</span><span class="tok-p">))</span>                           <span class="tok-c1">;; got enough results for a chunk</span>
            <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">v</span> <span class="tok-p">(</span><span class="tok-nf">vec</span> <span class="tok-p">(</span><span class="tok-nf">.toArray</span> <span class="tok-nv">a</span><span class="tok-p">))]</span>
              <span class="tok-p">(</span><span class="tok-nf">.clear</span> <span class="tok-nv">a</span><span class="tok-p">)</span>
              <span class="tok-p">(</span><span class="tok-nf">rfn</span> <span class="tok-nv">acc</span> <span class="tok-nv">v</span><span class="tok-p">))</span>                               <span class="tok-c1">;; the accumulated chunk becomes input to `rfn`</span>
            <span class="tok-nv">acc</span><span class="tok-p">))))))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">triples</span> <span class="tok-p">(</span><span class="tok-nf">my-partition-all</span> <span class="tok-mi">3</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">transduce</span> <span class="tok-nv">triples</span> <span class="tok-nb">conj </span><span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">10</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; [[0 1 2] [3 4 5] [6 7 8] [9]]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="eductions"><a class="link" href="#eductions">5.1.6. Eductions</a></h4>
<div class="paragraph">
<p>Eductions are a way to combine a collection and one or more transformations that can be reduced and iterated over,
and that apply the transformations every time we do so. If we have a collection that we want to process and a
transformation over it that we want others to extend, we can hand them a eduction, encapsulating the source
collection and our transformation. We can create an eduction with the <code>eduction</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ed</span> <span class="tok-p">(</span><span class="tok-nf">eduction</span> <span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-nv">odd?</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">take </span><span class="tok-mi">5</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">100</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nb">reduce + </span><span class="tok-mi">0</span> <span class="tok-nv">ed</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 25</span>

<span class="tok-p">(</span><span class="tok-nf">transduce</span> <span class="tok-p">(</span><span class="tok-nf">partition-all</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-nb">conj </span><span class="tok-nv">ed</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [[1 3] [5 7] [9]]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="more-transducers-in-clojurescript-core"><a class="link" href="#more-transducers-in-clojurescript-core">5.1.7. More transducers in ClojureScript core</a></h4>
<div class="paragraph">
<p>We learned about <code>map</code>, <code>filter</code>, <code>mapcat</code>, <code>take</code> and <code>partition-all</code>, but there are a lot more transducers
available in ClojureScript. Here is an incomplete list of some other intersting ones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>drop</code> is the dual of <code>take</code>, dropping up to <code>n</code> values before passing inputs to the reducing function</p>
</li>
<li>
<p><code>distinct</code> only allows inputs to occur once</p>
</li>
<li>
<p><code>dedupe</code> removes succesive duplicates in input values</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We encourage you to explore ClojureScript core to see what other transducers are out there.</p>
</div>
</div>
<div class="sect3">
<h4 id="defining-our-own-transducers"><a class="link" href="#defining-our-own-transducers">5.1.8. Defining our own transducers</a></h4>
<div class="paragraph">
<p>There a few things to consider before writing our own transducers so in this section we will learn how to properly
implement one. First of all, we&#8217;ve learned that the general structure of a transducer is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">xf</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">fn</span>
    <span class="tok-p">([]</span>          <span class="tok-c1">;; init</span>
      <span class="tok-nv">...</span><span class="tok-p">)</span>
    <span class="tok-p">([</span><span class="tok-nv">r</span><span class="tok-p">]</span>         <span class="tok-c1">;; completion</span>
      <span class="tok-nv">...</span><span class="tok-p">)</span>
    <span class="tok-p">([</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span> <span class="tok-c1">;; step</span>
      <span class="tok-nv">...</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Usually only the code represented with <code>&#8230;&#8203;</code> changes between transducers, these are the invariants that must
be preserved in each arity of the resulting function:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>arity 0 (init): must call the arity 0 of the nested transform <code>xf</code></p>
</li>
<li>
<p>arity 1 (completion): used to produce a final value and potentially flush state, must call the arity 1 of the nested
transform <code>xf</code> <strong>exactly once</strong></p>
</li>
<li>
<p>arity 2 (step): the resulting reducing function which will call the arity 2 of the nested transform <code>xf</code> zero, one or
more times</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="transducible-processes"><a class="link" href="#transducible-processes">5.1.9. Transducible processes</a></h4>
<div class="paragraph">
<p>A transducible process is any process that is defined in terms of a succession of steps ingesting input values.
The source of input varies from one process to another. Most of our examples dealt with inputs from a collection
or a lazy sequence, but it could be an asynchronous stream of values or a <code>core.async</code> channel. The outputs produced
by each step are also different for every process; <code>into</code> creates a collection with every output of the transducer,
<code>sequence</code> yields a lazy sequence, and asynchronous streams would probably push the outputs to their listeners.</p>
</div>
<div class="paragraph">
<p>In order to improve our understanding of transducible processes, we&#8217;re going to implement an unbounded queue, since adding
values to a queue can be thought in terms of a succession of steps ingesting input. First of all we&#8217;ll define a
protocol and a data type that implements the unbounded queue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defprotocol </span><span class="tok-nv">Queue</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-p">[</span><span class="tok-nv">q</span> <span class="tok-nv">item</span><span class="tok-p">]</span> <span class="tok-s">&quot;put an item into the queue&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-p">[</span><span class="tok-nv">q</span><span class="tok-p">]</span> <span class="tok-s">&quot;take an item from the queue&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">shutdown!</span> <span class="tok-p">[</span><span class="tok-nv">q</span><span class="tok-p">]</span> <span class="tok-s">&quot;stop accepting puts in the queue&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-kd">deftype </span><span class="tok-nv">UnboundedQueue</span> <span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-ss">:mutable</span> <span class="tok-nv">arr</span> <span class="tok-o">^</span><span class="tok-ss">:mutable</span> <span class="tok-nv">closed</span><span class="tok-p">]</span>
  <span class="tok-nv">Queue</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-p">[</span><span class="tok-nv">_</span> <span class="tok-nv">item</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">assert </span><span class="tok-p">(</span><span class="tok-nb">not </span><span class="tok-nv">closed</span><span class="tok-p">))</span>
    <span class="tok-p">(</span><span class="tok-nb">assert </span><span class="tok-p">(</span><span class="tok-nb">not </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">item</span><span class="tok-p">)))</span>
    <span class="tok-p">(</span><span class="tok-nf">.push</span> <span class="tok-nv">arr</span> <span class="tok-nv">item</span><span class="tok-p">)</span>
    <span class="tok-nv">item</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">aget </span><span class="tok-p">(</span><span class="tok-nf">.splice</span> <span class="tok-nv">arr</span> <span class="tok-mi">0</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-mi">0</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nf">shutdown!</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-nv">closed</span> <span class="tok-nv">true</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We defined the <code>Queue</code> protocol and as you may have noticed the implementation of <code>UnboundedQueue</code> doesn&#8217;t
know about transducers at all. It has a <code>put!</code> operation as its step function and we&#8217;re going to implement
the transducible process on top of that interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">unbounded-queue</span>
  <span class="tok-p">([]</span>
   <span class="tok-p">(</span><span class="tok-nf">queue</span> <span class="tok-nv">nil</span><span class="tok-p">))</span>
  <span class="tok-p">([</span><span class="tok-nv">xform</span><span class="tok-p">]</span>
   <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">put!</span> <span class="tok-p">(</span><span class="tok-nf">completing</span> <span class="tok-nv">put!</span><span class="tok-p">)</span>
         <span class="tok-nv">xput!</span> <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-nv">xform</span> <span class="tok-p">(</span><span class="tok-nf">xform</span> <span class="tok-nv">put!</span><span class="tok-p">)</span> <span class="tok-nv">put!</span><span class="tok-p">)</span>
         <span class="tok-nv">q</span> <span class="tok-p">(</span><span class="tok-nf">UnboundedQueue.</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">[]</span> <span class="tok-nv">false</span><span class="tok-p">)]</span>
     <span class="tok-p">(</span><span class="tok-nf">reify</span>
       <span class="tok-nv">Queue</span>
       <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-p">[</span><span class="tok-nv">_</span> <span class="tok-nv">item</span><span class="tok-p">]</span>
         <span class="tok-p">(</span><span class="tok-nb">when-not </span><span class="tok-p">(</span><span class="tok-nf">.-closed</span> <span class="tok-nv">q</span><span class="tok-p">)</span>
           <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nb">val </span><span class="tok-p">(</span><span class="tok-nf">xput!</span> <span class="tok-nv">q</span> <span class="tok-nv">item</span><span class="tok-p">)]</span>
             <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">reduced?</span> <span class="tok-nv">val</span><span class="tok-p">)</span>
               <span class="tok-p">(</span><span class="tok-nf">do</span>
                 <span class="tok-p">(</span><span class="tok-nf">xput!</span> <span class="tok-o">@</span><span class="tok-nv">val</span><span class="tok-p">)</span>  <span class="tok-c1">;; call completion step</span>
                 <span class="tok-p">(</span><span class="tok-nf">shutdown!</span> <span class="tok-nv">q</span><span class="tok-p">)</span> <span class="tok-c1">;; respect reduced</span>
                 <span class="tok-o">@</span><span class="tok-nv">val</span><span class="tok-p">)</span>
               <span class="tok-nv">val</span><span class="tok-p">))))</span>
       <span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
         <span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">q</span><span class="tok-p">))</span>
       <span class="tok-p">(</span><span class="tok-nf">shutdown!</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
         <span class="tok-p">(</span><span class="tok-nf">shutdown!</span> <span class="tok-nv">q</span><span class="tok-p">))))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the <code>unbounded-queue</code> constructor uses an <code>UnboundedQueue</code> instance internally, proxying the
<code>take!</code> and <code>shutdown!</code> calls and implementing the transducible process logic in the <code>put!</code> function. Let&#8217;s
deconstruct it to understand what&#8217;s going on.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">put!</span> <span class="tok-p">(</span><span class="tok-nf">completing</span> <span class="tok-nv">put!</span><span class="tok-p">)</span>
      <span class="tok-nv">xput!</span> <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-nv">xform</span> <span class="tok-p">(</span><span class="tok-nf">xform</span> <span class="tok-nv">put!</span><span class="tok-p">)</span> <span class="tok-nv">put!</span><span class="tok-p">)</span>
      <span class="tok-nv">q</span> <span class="tok-p">(</span><span class="tok-nf">UnboundedQueue.</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">[]</span> <span class="tok-nv">false</span><span class="tok-p">)]</span>
  <span class="tok-c1">;; ...</span>
<span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>First of all, we use <code>completing</code> for adding the arity 0 and arity 1 to the <code>Queue</code> protocol&#8217;s <code>put!</code> function.
This will make it play nicely with transducers in case we give this reducing function to <code>xform</code> to derive another.
After that, if a transducer (<code>xform</code>) was provided, we derive a reducing function applying the transducer to <code>put!</code>.
If we&#8217;re not handed a transducer we will just use <code>put!</code>. <code>q</code> is the internal instance of <code>UnboundedQueue</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">reify</span>
  <span class="tok-nv">Queue</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-p">[</span><span class="tok-nv">_</span> <span class="tok-nv">item</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">when-not </span><span class="tok-p">(</span><span class="tok-nf">.-closed</span> <span class="tok-nv">q</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nb">val </span><span class="tok-p">(</span><span class="tok-nf">xput!</span> <span class="tok-nv">q</span> <span class="tok-nv">item</span><span class="tok-p">)]</span>
        <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">reduced?</span> <span class="tok-nv">val</span><span class="tok-p">)</span>
          <span class="tok-p">(</span><span class="tok-nf">do</span>
            <span class="tok-p">(</span><span class="tok-nf">xput!</span> <span class="tok-o">@</span><span class="tok-nv">val</span><span class="tok-p">)</span>  <span class="tok-c1">;; call completion step</span>
            <span class="tok-p">(</span><span class="tok-nf">shutdown!</span> <span class="tok-nv">q</span><span class="tok-p">)</span> <span class="tok-c1">;; respect reduced</span>
            <span class="tok-o">@</span><span class="tok-nv">val</span><span class="tok-p">)</span>
          <span class="tok-nv">val</span><span class="tok-p">))))</span>
  <span class="tok-c1">;; ...</span>
<span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The exposed <code>put!</code> operation will only be performed if the queue hasn&#8217;t been shut down. Notice that the <code>put!</code>
implementation of <code>UnboundedQueue</code> uses an assert to verify that we can still put values to it and we don&#8217;t
want to break that invariant. If the queue isn&#8217;t closed we can put values into it, we use the possibly transformed
<code>xput!</code> for doing so.</p>
</div>
<div class="paragraph">
<p>If the put operation gives back a reduced value it&#8217;s telling us that we should terminate the transducible process.
In this case that means shutting down the queue to not accept more values. If we didn&#8217;t get a reduced value we can
happily continue accepting puts.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see how our queue behaves without transducers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">q</span> <span class="tok-p">(</span><span class="tok-nf">queue</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;[object Object]&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">q</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">q</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">q</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">q</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">q</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Pretty much what we expected, let&#8217;s now try with a stateless transducer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">incq</span> <span class="tok-p">(</span><span class="tok-nf">queue</span> <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">inc</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; #&lt;[object Object]&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">incq</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">incq</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 3</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">incq</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">incq</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 3</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">incq</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To check that we&#8217;ve implemented the transducible process, let&#8217;s use a stateful transducer. We&#8217;ll use a transducer
that will accept values while they aren&#8217;t equal to 4 and will partition inputs in chunks of 2 elements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">xq</span> <span class="tok-p">(</span><span class="tok-nf">queue</span> <span class="tok-p">(</span><span class="tok-nf">comp</span>
                 <span class="tok-p">(</span><span class="tok-nb">take-while </span><span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">not= </span><span class="tok-nv">%</span> <span class="tok-mi">4</span><span class="tok-p">))</span>
                 <span class="tok-p">(</span><span class="tok-nf">partition-all</span> <span class="tok-mi">2</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">xq</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">xq</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [1 2]</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">xq</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">xq</span> <span class="tok-mi">4</span><span class="tok-p">)</span> <span class="tok-c1">;; shouldn&#39;t accept more values from here on</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">xq</span> <span class="tok-mi">5</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">xq</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [1 2]</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">xq</span><span class="tok-p">)</span> <span class="tok-c1">;; seems like `partition-all` flushed correctly!</span>
<span class="tok-c1">;; =&gt; [3]</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">xq</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The example of the queue was heavily inspired by how <code>core.async</code> channels use transducers in their internal
step. We&#8217;ll discuss channels and their usage with transducers in a later section.</p>
</div>
<div class="paragraph">
<p>Transducible processes must respect <code>reduced</code> as a way for signaling early termination. For example,
building a collection stops when encountering a <code>reduced</code> and <code>core.async</code> channels with transducers are closed.
The <code>reduced</code> value must be unwrapped with <code>deref</code> and passed to the completion step, which must be called exactly
once.</p>
</div>
<div class="paragraph">
<p>Transducible processes shouldn&#8217;t expose the reducing function they generate when calling the transducer with their
own step function since it may be stateful and unsafe to use from elsewhere.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transients"><a class="link" href="#transients">5.2. Transients</a></h3>
<div class="paragraph">
<p>Although ClojureScript&#8217;s immutable and persistent data structures are reasonably performant
there are situations in which we are transforming large data structures using multiple steps
to only share the final result. For example, the core <code>into</code> function takes a collection and eagerly
populates it with the contents of a sequence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">into </span><span class="tok-p">[]</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">100</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; [0 1 2 ... 98 99]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example we are generating a vector of 100 elements <code>conj</code>-ing one at a time. Every
intermediate vector that is not the final result won&#8217;t be seen by anybody except the <code>into</code>
function and the array copying required for persistence is an unnecesary overhead.</p>
</div>
<div class="paragraph">
<p>For these situations ClojureScript provides a special version of some of its persistent data
structures, which are called transients. Maps, vectors and sets have a transient counterpart.
Transients are always derived from a persistent data structure using the <code>transient</code> function,
which creates a transient version in constant time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">tv</span> <span class="tok-p">(</span><span class="tok-nf">transient</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]))</span>
<span class="tok-c1">;; =&gt; #&lt;[object Object]&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Transients support the read API of their persistent counterparts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">tv</span> <span class="tok-p">(</span><span class="tok-nf">transient</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nb">nth </span><span class="tok-nv">tv</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nb">get </span><span class="tok-nv">tv</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 3</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">tm</span> <span class="tok-p">(</span><span class="tok-nf">transient</span> <span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">}))</span>

<span class="tok-p">(</span><span class="tok-ss">:language</span> <span class="tok-nv">tm</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;ClojureScript&quot;</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ts</span> <span class="tok-p">(</span><span class="tok-nf">transient</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-ss">:a</span> <span class="tok-ss">:b</span> <span class="tok-ss">:c</span><span class="tok-p">}))</span>

<span class="tok-p">(</span><span class="tok-nb">contains? </span><span class="tok-nv">ts</span> <span class="tok-ss">:a</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-ss">:a</span> <span class="tok-nv">ts</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; :a</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since transients don&#8217;t have persistent and immutable semantics for updates they can&#8217;t be transformed
using the already familiar <code>conj</code> or <code>assoc</code> functions. Instead, the transforming functions that work
on transients end with a bang. Let&#8217;s look at an example using <code>conj!</code> on a transient:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">tv</span> <span class="tok-p">(</span><span class="tok-nf">transient</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nf">conj!</span> <span class="tok-nv">tv</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;[object Object]&gt;</span>

<span class="tok-p">(</span><span class="tok-nb">nth </span><span class="tok-nv">tv</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 4</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the transient version of the vector is neither immutable or persistent. Instead, the
vector is mutated in place. Although we could transform <code>tv</code> repeatedly using <code>conj!</code> on it we shouldn&#8217;t
abandon the idioms used with the persistent data structures: when transforming a transient, use the
returned version of it for further modifications like in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
  <span class="tok-nv">transient</span>
  <span class="tok-p">(</span><span class="tok-nf">conj!</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">conj!</span> <span class="tok-mi">5</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;[object Object]&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can convert a transient back to a persistent and immutable data structure by calling <code>persistent!</code> on
it. This operation, like deriving a transient from a persistent data structure, is done in constant time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
  <span class="tok-nv">transient</span>
  <span class="tok-p">(</span><span class="tok-nf">conj!</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">conj!</span> <span class="tok-mi">5</span><span class="tok-p">)</span>
  <span class="tok-nv">persistent!</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [1 2 3 4 5]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A peculiarity of transforming transients into persistent structures is that the transient version is
invalidated after being converted to a persistent data structure and we can&#8217;t do further transformations
to it. This happens because the derived persistent data structure uses the transient&#8217;s internal nodes
and mutating them would break the immutability and persistent guarantees:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">tm</span> <span class="tok-p">(</span><span class="tok-nf">transient</span> <span class="tok-p">{}))</span>
<span class="tok-c1">;; =&gt; #&lt;[object Object]&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">assoc!</span> <span class="tok-nv">tm</span> <span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;[object Object]&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">persistent!</span> <span class="tok-nv">tm</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:foo :bar}</span>

<span class="tok-p">(</span><span class="tok-nf">assoc!</span> <span class="tok-nv">tm</span> <span class="tok-ss">:baz</span> <span class="tok-ss">:frob</span><span class="tok-p">)</span>
<span class="tok-c1">;; Error: assoc! after persistent!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Going back to our initial example with <code>into</code>, here&#8217;s a very simplified implementation of it that uses
a transient for performance, returning a persistent data structure and thus exposing a purely functional
interface although it uses mutation internally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-into</span>
  <span class="tok-p">[</span><span class="tok-nv">to</span> <span class="tok-nv">from</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">persistent!</span> <span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-nv">conj!</span> <span class="tok-p">(</span><span class="tok-nf">transient</span> <span class="tok-nv">to</span><span class="tok-p">)</span> <span class="tok-nv">from</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">my-into</span> <span class="tok-p">[]</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">100</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; [0 1 2 ... 98 99]</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="metadata-section"><a class="link" href="#metadata-section">5.3. Metadata</a></h3>
<div class="paragraph">
<p>ClojureScript symbols, vars and persistent collections support attaching metadata to them. Metadata is
a map with information about the entity it&#8217;s attached to. The ClojureScript compiler uses metadata for
several purposes such as type hints, and the metadata system can be used by tooling, library and application
developers too.</p>
</div>
<div class="paragraph">
<p>There may not be many cases in day-to-day ClojureScript programming where you need metadata, but it is a
nice language feature to have and know about; it may come in handy at some point. It makes things like
runtime code introspection and documentation generation very easy. You&#8217;ll see why throughout this section.</p>
</div>
<div class="sect3">
<h4 id="vars-3"><a class="link" href="#vars-3">5.3.1. Vars</a></h4>
<div class="paragraph">
<p>Let&#8217;s define a var and see what metadata is attached to it by default. Note that this code is executed in
a REPL, and thus the metadata of a var defined in a source file may vary. We&#8217;ll use the <code>meta</code> function to
retrieve the metadata of the given value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">answer-to-everything</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 42</span>

<span class="tok-o">#</span><span class="tok-ss">&#39;answer-to-everything</span>
<span class="tok-c1">;; =&gt; #&#39;cljs.user/answer-to-everyhing</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-o">#</span><span class="tok-ss">&#39;answer-to-everything</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:ns cljs.user,</span>
<span class="tok-c1">;;     :name answer-to-everything,</span>
<span class="tok-c1">;;     :file &quot;NO_SOURCE_FILE&quot;,</span>
<span class="tok-c1">;;     :source &quot;answer-to-everything&quot;,</span>
<span class="tok-c1">;;     :column 6,</span>
<span class="tok-c1">;;     :end-column 26,</span>
<span class="tok-c1">;;     :line 1,</span>
<span class="tok-c1">;;     :end-line 1,</span>
<span class="tok-c1">;;     :arglists (),</span>
<span class="tok-c1">;;     :doc nil,</span>
<span class="tok-c1">;;     :test nil}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Few things to note here. First of all, <code>#'answer-to-everything</code> gives us a reference to the <code>Var</code> that holds
the value of the <code>answer-to-everything</code> symbol. We see that it includes information about the namespace (<code>:ns</code>) in
which it was defined, its name, file (although, since it was defined at a REPL doesn&#8217;t have a source file),
source, position in the file where it was defined, argument list (which only makes sense for functions),
documentation string and test function.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at a function var&#8217;s metadata:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">add</span>
  <span class="tok-s">&quot;A function that adds two numbers.&quot;</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-o">#</span><span class="tok-ss">&#39;add</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:ns cljs.user,</span>
<span class="tok-c1">;;     :name add,</span>
<span class="tok-c1">;;     :file &quot;NO_SOURCE_FILE&quot;,</span>
<span class="tok-c1">;;     :source &quot;add&quot;,</span>
<span class="tok-c1">;;     :column 7,</span>
<span class="tok-c1">;;     :end-column 10,</span>
<span class="tok-c1">;;     :line 1,</span>
<span class="tok-c1">;;     :end-line 1,</span>
<span class="tok-c1">;;     :arglists (quote ([x y])),</span>
<span class="tok-c1">;;     :doc &quot;A function that adds two numbers.&quot;,</span>
<span class="tok-c1">;;     :test nil}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We see that the argument lists are stored in the <code>:arglists</code> field of the var&#8217;s metadata and its documentation
in the <code>:doc</code> field. We&#8217;ll now define a test function to learn about what <code>:test</code> is used for:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.test</span> <span class="tok-ss">:as</span> <span class="tok-nv">t</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">t/deftest</span> <span class="tok-nv">i-pass</span>
  <span class="tok-p">(</span><span class="tok-nf">t/is</span> <span class="tok-nv">true</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-o">#</span><span class="tok-ss">&#39;i-pass</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:ns cljs.user,</span>
<span class="tok-c1">;;     :name i-pass,</span>
<span class="tok-c1">;;     :file &quot;NO_SOURCE_FILE&quot;,</span>
<span class="tok-c1">;;     :source &quot;i-pass&quot;,</span>
<span class="tok-c1">;;     :column 12,</span>
<span class="tok-c1">;;     :end-column 18,</span>
<span class="tok-c1">;;     :line 1,</span>
<span class="tok-c1">;;     :end-line 1,</span>
<span class="tok-c1">;;     :arglists (),</span>
<span class="tok-c1">;;     :doc &quot;A function that adds two numbers.&quot;,</span>
<span class="tok-c1">;;     :test #&lt;function (){ ... }&gt;}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>:test</code> attribute (truncated for brevity) in the <code>i-pass</code> var&#8217;s metadata is a test function. This is used
by the <code>cljs.test</code> library for discovering and running tests in the namespaces you tell it to.</p>
</div>
</div>
<div class="sect3">
<h4 id="values"><a class="link" href="#values">5.3.2. Values</a></h4>
<div class="paragraph">
<p>We learned that vars can have metadata and what kind of metadata is added to them for consumption by the
compiler and the <code>cljs.test</code> testing library. Persistent collections can have metadata too, although they don&#8217;t
have any by default. We can use the <code>with-meta</code> function to derive an object with the same value and type with
the given metadata attached. Let&#8217;s see how:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">map-without-metadata</span> <span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; {:language &quot;ClojureScript&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">map-without-metadata</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">map-with-metadata</span> <span class="tok-p">(</span><span class="tok-nb">with-meta </span><span class="tok-nv">map-without-metadata</span>
                                  <span class="tok-p">{</span><span class="tok-ss">:answer-to-everything</span> <span class="tok-mi">42</span><span class="tok-p">}))</span>
<span class="tok-c1">;; =&gt; {:language &quot;ClojureScript&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">map-with-metadata</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:answer-to-everything 42}</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">map-with-metadata</span>
   <span class="tok-nv">map-without-metadata</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">identical? </span><span class="tok-nv">map-with-metadata</span>
            <span class="tok-nv">map-without-metadata</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It shouldn&#8217;t come as a surprise that metadata doesn&#8217;t affect equality between two data structures since
equality in ClojureScript is based on value. Another interesting thing is that <code>with-meta</code> creates another
object of the same type and value as the given one and attaches the given metadata to it.</p>
</div>
<div class="paragraph">
<p>Another open question is what happens with metadata when deriving new values from a persistent data structure.
Let&#8217;s find out:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">derived-map</span> <span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-nv">map-with-metadata</span> <span class="tok-ss">:language</span> <span class="tok-s">&quot;Clojure&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; {:language &quot;Clojure&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">derived-map</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:answer-to-everything 42}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see in the example above, metadata is preserved in derived versions of persistent data structures. There
are some subtleties, though. As long as the functions that derive new data structures return collections with the
same type, metadata will be preserved; this is not true if the types change due to the transformation. To
ilustrate this point, let&#8217;s see what happens when we derive a seq or a subvector from a vector:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">v</span> <span class="tok-p">(</span><span class="tok-nb">with-meta </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span> <span class="tok-p">{</span><span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span><span class="tok-p">}))</span>
<span class="tok-c1">;; =&gt; [0 1 2 3]</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">sv</span> <span class="tok-p">(</span><span class="tok-nb">subvec </span><span class="tok-nv">v</span> <span class="tok-mi">0</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; [0 1]</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">sv</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-p">(</span><span class="tok-nb">seq </span><span class="tok-nv">v</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="syntax-for-metadata"><a class="link" href="#syntax-for-metadata">5.3.3. Syntax for metadata</a></h4>
<div class="paragraph">
<p>The ClojureScript reader has syntactic support for metadata annotations, which can be written in different ways. We
can prepend var definitions or collections with a caret (<code>^</code>) followed by a map for annotating it with the given
metadata map:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-o">^</span><span class="tok-p">{</span><span class="tok-ss">:doc</span> <span class="tok-s">&quot;The answer to Life, Universe and Everything.&quot;</span><span class="tok-p">}</span> <span class="tok-nv">answer-to-everything</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 42</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-o">#</span><span class="tok-ss">&#39;answer-to-everything</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:ns cljs.user,</span>
<span class="tok-c1">;;     :name answer-to-everything,</span>
<span class="tok-c1">;;     :file &quot;NO_SOURCE_FILE&quot;,</span>
<span class="tok-c1">;;     :source &quot;answer-to-everything&quot;,</span>
<span class="tok-c1">;;     :column 6,</span>
<span class="tok-c1">;;     :end-column 26,</span>
<span class="tok-c1">;;     :line 1,</span>
<span class="tok-c1">;;     :end-line 1,</span>
<span class="tok-c1">;;     :arglists (),</span>
<span class="tok-c1">;;     :doc &quot;The answer to Life, Universe and Everything.&quot;,</span>
<span class="tok-c1">;;     :test nil}</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">map-with-metadata</span> <span class="tok-o">^</span><span class="tok-p">{</span><span class="tok-ss">:answer-to-everything</span> <span class="tok-mi">42</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; {:language &quot;ClojureScript&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">map-with-metadata</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:answer-to-everything 42}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how the metadata given in the <code>answer-to-everything</code> var definition is merged with the var metadata.</p>
</div>
<div class="paragraph">
<p>A very common use of metadata is to set certain keys to a <code>true</code> value. For example we may want to add to a
var&#8217;s metadata that the variable is dynamic or a constant. For such cases, we have a shorthand notation that
uses a caret followed by a keyword. Here are some examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-o">^</span><span class="tok-ss">:dynamic</span> <span class="tok-nv">*foo*</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 42</span>

<span class="tok-p">(</span><span class="tok-ss">:dynamic</span> <span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-o">#</span><span class="tok-ss">&#39;*foo*</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-o">^</span><span class="tok-ss">:foo</span> <span class="tok-o">^</span><span class="tok-ss">:bar</span> <span class="tok-nv">answer</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 42</span>

<span class="tok-p">(</span><span class="tok-nb">select-keys </span><span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-o">#</span><span class="tok-ss">&#39;answer</span><span class="tok-p">)</span> <span class="tok-p">[</span><span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; {:foo true, :bar true}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There is another shorthand notation for attaching metadata. If we use a caret followed by a symbol it will
be added to the metadata map under the <code>:tag</code> key. Using tags such as <code>^boolean</code> gives the ClojureScript
compiler hints about the type of expressions or function return types.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-o">^</span><span class="tok-nb">boolean </span><span class="tok-nv">will-it-blend?</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span> <span class="tok-nv">true</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;function ... &gt;</span>

<span class="tok-p">(</span><span class="tok-ss">:tag</span> <span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-o">#</span><span class="tok-ss">&#39;will-it-blend?</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; boolean</span>

<span class="tok-p">(</span><span class="tok-nb">not </span><span class="tok-o">^</span><span class="tok-nb">boolean </span><span class="tok-p">(</span><span class="tok-nf">js/isNaN</span> <span class="tok-nv">js/NaN</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="functions-for-working-with-metadata"><a class="link" href="#functions-for-working-with-metadata">5.3.4. Functions for working with metadata</a></h4>
<div class="paragraph">
<p>We&#8217;ve learned about <code>meta</code> and <code>with-meta</code> so far but ClojureScript offers a few functions for transforming
metadata. There is <code>vary-meta</code> which is similar to <code>with-meta</code> in that it derives a new object with the same
type and value as the original but it doesn&#8217;t take the metadata to attach directly. Instead, it takes a function
to apply to the metadata of the given object to transform it for deriving new metadata. This is how it works:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">map-with-metadata</span> <span class="tok-o">^</span><span class="tok-p">{</span><span class="tok-ss">:foo</span> <span class="tok-mi">40</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; {:language &quot;ClojureScript&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">map-with-metadata</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:foo 40}</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">derived-map</span> <span class="tok-p">(</span><span class="tok-nf">vary-meta</span> <span class="tok-nv">map-with-metadata</span> <span class="tok-nv">update</span> <span class="tok-ss">:foo</span> <span class="tok-nb">+ </span><span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; {:language &quot;ClojureScript&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">derived-map</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:foo 42}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If instead we want to change the metadata of an existing var or value we can use <code>alter-meta!</code> for changing it
by applying a function or <code>reset-meta!</code> for replacing it with another map:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">map-with-metadata</span> <span class="tok-o">^</span><span class="tok-p">{</span><span class="tok-ss">:foo</span> <span class="tok-mi">40</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; {:language &quot;ClojureScript&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">map-with-metadata</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:foo 40}</span>

<span class="tok-p">(</span><span class="tok-nf">alter-meta!</span> <span class="tok-nv">map-with-metadata</span> <span class="tok-nv">update</span> <span class="tok-ss">:foo</span> <span class="tok-nb">+ </span><span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:foo 42}</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">map-with-metadata</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:foo 42}</span>

<span class="tok-p">(</span><span class="tok-nf">reset-meta!</span> <span class="tok-nv">map-with-metadata</span> <span class="tok-p">{</span><span class="tok-ss">:foo</span> <span class="tok-mi">40</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; {:foo 40}</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">map-with-metadata</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:foo 40}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="core-protocols-section"><a class="link" href="#core-protocols-section">5.4. Core protocols</a></h3>
<div class="paragraph">
<p>One of the greatest qualities of the core ClojureScript functions is that they are
implemented around protocols. This makes them open to work on any type that we
extend with such protocols, be it defined by us or a third party.</p>
</div>
<div class="sect3">
<h4 id="functions"><a class="link" href="#functions">5.4.1. Functions</a></h4>
<div class="paragraph">
<p>As we&#8217;ve learned in previous chapters not only functions can be invoked. Vectors are
functions of their indexes, maps are functions of their keys and sets are functions
of their values.</p>
</div>
<div class="paragraph">
<p>We can extend types to be callable as functions implementing the <code>IFn</code> protocol. A
collection that doesn&#8217;t support calling it as a function is the queue, let&#8217;s
implement <code>IFn</code> for the <code>PersistentQueue</code> type so we&#8217;re able to call queues as functions
of their indexes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">PersistentQueue</span>
  <span class="tok-nv">IFn</span>
  <span class="tok-p">(</span><span class="tok-nf">-invoke</span>
    <span class="tok-p">([</span><span class="tok-nv">this</span> <span class="tok-nv">idx</span><span class="tok-p">]</span>
      <span class="tok-p">(</span><span class="tok-nb">nth </span><span class="tok-nv">this</span> <span class="tok-nv">idx</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">q</span> <span class="tok-o">#</span><span class="tok-nv">queue</span><span class="tok-p">[</span><span class="tok-ss">:a</span> <span class="tok-ss">:b</span> <span class="tok-ss">:c</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; #queue [:a :b :c]</span>

<span class="tok-p">(</span><span class="tok-nf">q</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; :a</span>

<span class="tok-p">(</span><span class="tok-nf">q</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; :b</span>

<span class="tok-p">(</span><span class="tok-nf">q</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; :c</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="printing"><a class="link" href="#printing">5.4.2. Printing</a></h4>
<div class="paragraph">
<p>For learning about some of the core protocols we&#8217;ll define a <code>Pair</code> type, which will hold a pair
of values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">deftype </span><span class="tok-nv">Pair</span> <span class="tok-p">[</span><span class="tok-nv">fst</span> <span class="tok-nv">snd</span><span class="tok-p">])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If we want to customize how types are printed we can implement the <code>IPrintWithWriter</code>
protocol. It defines a function called <code>-pr-writer</code> that receives the value to print, a writer
object and options; this function uses the writer object&#8217;s <code>-write</code> function to write the desired
<code>Pair</code> string representation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">Pair</span>
  <span class="tok-nv">IPrintWithWriter</span>
  <span class="tok-p">(</span><span class="tok-nf">-pr-writer</span> <span class="tok-p">[</span><span class="tok-nv">p</span> <span class="tok-nv">writer</span> <span class="tok-nv">_</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">-write</span> <span class="tok-nv">writer</span> <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">&quot;#&lt;Pair &quot;</span> <span class="tok-p">(</span><span class="tok-nf">.-fst</span> <span class="tok-nv">p</span><span class="tok-p">)</span> <span class="tok-s">&quot;,&quot;</span> <span class="tok-p">(</span><span class="tok-nf">.-snd</span> <span class="tok-nv">p</span><span class="tok-p">)</span> <span class="tok-s">&quot;&gt;&quot;</span><span class="tok-p">))))</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sequences"><a class="link" href="#sequences">5.4.3. Sequences</a></h4>
<div class="paragraph">
<p>In a <a href="#the-sequence-abstraction">previous section</a> we learned about sequences, one of
ClojureScript&#8217;s main abstractions. Remember the <code>first</code> and <code>rest</code> functions for working
with sequences? They are defined in the <code>ISeq</code> protocol, so we can extend types for
responding to such functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">Pair</span>
  <span class="tok-nv">ISeq</span>
  <span class="tok-p">(</span><span class="tok-nf">-first</span> <span class="tok-p">[</span><span class="tok-nv">p</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">.-fst</span> <span class="tok-nv">p</span><span class="tok-p">))</span>

  <span class="tok-p">(</span><span class="tok-nf">-rest</span> <span class="tok-p">[</span><span class="tok-nv">p</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-p">(</span><span class="tok-nf">.-snd</span> <span class="tok-nv">p</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">p</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Pair 1,2&gt;</span>

<span class="tok-p">(</span><span class="tok-nb">first </span><span class="tok-nv">p</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nb">rest </span><span class="tok-nv">p</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (2)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Another handy function for working with sequences is <code>next</code>. Although <code>next</code> works as long
as the given argument is a sequence, we can implement it explicitly with the <code>INext</code> protocol:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">p</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">next </span><span class="tok-nv">p</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (2)</span>

<span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">Pair</span>
  <span class="tok-nv">INext</span>
  <span class="tok-p">(</span><span class="tok-nf">-next</span> <span class="tok-p">[</span><span class="tok-nv">p</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Our next&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-p">(</span><span class="tok-nf">.-snd</span> <span class="tok-nv">p</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nb">next </span><span class="tok-nv">p</span><span class="tok-p">)</span>
<span class="tok-c1">;; Our next</span>
<span class="tok-c1">;; =&gt; (2)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, we can make our own types seqable implementing the <code>ISeqable</code> protocol. This means we
can pass them to <code>seq</code> for getting a sequence back.</p>
</div>
<div class="paragraph">
<p>ISeqable</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">p</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">Pair</span>
  <span class="tok-nv">ISeqable</span>
  <span class="tok-p">(</span><span class="tok-nf">-seq</span> <span class="tok-p">[</span><span class="tok-nv">p</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-p">(</span><span class="tok-nf">.-fst</span> <span class="tok-nv">p</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">.-snd</span> <span class="tok-nv">p</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nb">seq </span><span class="tok-nv">p</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (1 2)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now our <code>Pair</code> type works with the plethora of ClojureScript functions for working with sequences:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">p</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Pair 1,2&gt;</span>

<span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-nv">p</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (2 3)</span>

<span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-nv">odd?</span> <span class="tok-nv">p</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (1)</span>

<span class="tok-p">(</span><span class="tok-nb">reduce + </span><span class="tok-nv">p</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 3</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="collections-2"><a class="link" href="#collections-2">5.4.4. Collections</a></h4>
<div class="paragraph">
<p>Collection functions are also defined in terms of protocols. For this section examples we will make
the native JavaScript string act like a collection.</p>
</div>
<div class="paragraph">
<p>The most important function for working with collection is <code>conj</code>, defined in the <code>ICollection</code> protocol.
Strings are the only type which makes sense to <code>conj</code> to a string, so the <code>conj</code> operation for strings
will be simply a concatenation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">string</span>
  <span class="tok-nv">ICollection</span>
  <span class="tok-p">(</span><span class="tok-nf">-conj</span> <span class="tok-p">[</span><span class="tok-nv">this</span> <span class="tok-nv">o</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-nv">this</span> <span class="tok-nv">o</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-s">&quot;foo&quot;</span> <span class="tok-s">&quot;bar&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;foobar&quot;</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-s">&quot;foo&quot;</span> <span class="tok-s">&quot;bar&quot;</span> <span class="tok-s">&quot;baz&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;foobarbaz&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Another handy function for working with collections is <code>empty</code>, which is part of the <code>IEmptyableCollection</code>
protocol. Let&#8217;s implement it for the string type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">string</span>
  <span class="tok-nv">IEmptyableCollection</span>
  <span class="tok-p">(</span><span class="tok-nf">-empty</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
    <span class="tok-s">&quot;&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">empty</span> <span class="tok-s">&quot;foo&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We used the <code>string</code> special symbol for extending the native JavaScript string. If you want to learn more about
it check the <a href="#extending-javascript-types">section about extending JavaScript types</a>.</p>
</div>
<div class="sect4">
<h5 id="collection-traits"><a class="link" href="#collection-traits">Collection traits</a></h5>
<div class="paragraph">
<p>There are some qualities that not all collections have, such as being countable in constant time or being
reversible. These traits are splitted into different protocols since not all of them make sense for every
collection. For illustrating these protocols we&#8217;ll use the <code>Pair</code> type we defined earlier.</p>
</div>
<div class="paragraph">
<p>For collections that can be counted in constant time using the <code>count</code> function we can implement the <code>ICounted</code>
protocol. It should be easy to implement it for the <code>Pair</code> type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">Pair</span>
  <span class="tok-nv">ICounted</span>
  <span class="tok-p">(</span><span class="tok-nf">-count</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
    <span class="tok-mi">2</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">p</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-nv">p</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Some collection types such as vectors and lists can be indexed by a number using the <code>nth</code> function. If our
types are indexed we can implement the <code>IIndexed</code> protocol:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">Pair</span>
  <span class="tok-nv">IIndexed</span>
  <span class="tok-p">(</span><span class="tok-nf">-nth</span>
    <span class="tok-p">([</span><span class="tok-nv">p</span> <span class="tok-nv">idx</span><span class="tok-p">]</span>
      <span class="tok-p">(</span><span class="tok-nf">case</span> <span class="tok-nv">idx</span>
        <span class="tok-mi">0</span> <span class="tok-p">(</span><span class="tok-nf">.-fst</span> <span class="tok-nv">p</span><span class="tok-p">)</span>
        <span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-nf">.-snd</span> <span class="tok-nv">p</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-nf">throw</span> <span class="tok-p">(</span><span class="tok-nf">js/Error.</span> <span class="tok-s">&quot;Index out of bounds&quot;</span><span class="tok-p">))))</span>
    <span class="tok-p">([</span><span class="tok-nv">p</span> <span class="tok-nv">idx</span> <span class="tok-nv">default</span><span class="tok-p">]</span>
      <span class="tok-p">(</span><span class="tok-nf">case</span> <span class="tok-nv">idx</span>
        <span class="tok-mi">0</span> <span class="tok-p">(</span><span class="tok-nf">.-fst</span> <span class="tok-nv">p</span><span class="tok-p">)</span>
        <span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-nf">.-snd</span> <span class="tok-nv">p</span><span class="tok-p">)</span>
        <span class="tok-nv">default</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nb">nth </span><span class="tok-nv">p</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nb">nth </span><span class="tok-nv">p</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>

<span class="tok-p">(</span><span class="tok-nb">nth </span><span class="tok-nv">p</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; Error: Index out of bounds</span>

<span class="tok-p">(</span><span class="tok-nb">nth </span><span class="tok-nv">p</span> <span class="tok-mi">2</span> <span class="tok-ss">:default</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; :default</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="associative"><a class="link" href="#associative">5.4.5. Associative</a></h4>
<div class="paragraph">
<p>There are many data structures that are associative: they map keys to values. We&#8217;ve encountered a few of them
already and we know many functions for working with them like <code>get</code>, <code>assoc</code> or <code>dissoc</code>. Let&#8217;s explore the
protocols that these functions build upon.</p>
</div>
<div class="paragraph">
<p>First of all, we need a way to look up keys on an associative data structure. The <code>ILookup</code> protocol defines
a function for doing so, let&#8217;s add the ability to look up keys in our <code>Pair</code> type since is an associative data
structure that maps the indices 0 and 1 to values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">Pair</span>
  <span class="tok-nv">ILookup</span>
  <span class="tok-p">(</span><span class="tok-nf">-lookup</span>
    <span class="tok-p">([</span><span class="tok-nv">p</span> <span class="tok-nv">k</span><span class="tok-p">]</span>
      <span class="tok-p">(</span><span class="tok-nf">-lookup</span> <span class="tok-nv">p</span> <span class="tok-nv">k</span> <span class="tok-nv">nil</span><span class="tok-p">))</span>
    <span class="tok-p">([</span><span class="tok-nv">p</span> <span class="tok-nv">k</span> <span class="tok-nv">default</span><span class="tok-p">]</span>
      <span class="tok-p">(</span><span class="tok-nf">case</span> <span class="tok-nv">k</span>
        <span class="tok-mi">0</span> <span class="tok-p">(</span><span class="tok-nf">.-fst</span> <span class="tok-nv">p</span><span class="tok-p">)</span>
        <span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-nf">.-snd</span> <span class="tok-nv">p</span><span class="tok-p">)</span>
        <span class="tok-nv">default</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nb">get </span><span class="tok-nv">p</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nb">get </span><span class="tok-nv">p</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>

<span class="tok-p">(</span><span class="tok-nb">get </span><span class="tok-nv">p</span> <span class="tok-ss">:foo</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nb">get </span><span class="tok-nv">p</span> <span class="tok-mi">2</span> <span class="tok-ss">:default</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; :default</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For using <code>assoc</code> on a data structure it must implement the <code>IAssociative</code> protocol. For our <code>Pair</code> type only
0 and 1 will be allowed as keys for associating values. <code>IAssociative</code> also has a function for asking whether
a key is present or not.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">Pair</span>
  <span class="tok-nv">IAssociative</span>
  <span class="tok-p">(</span><span class="tok-nf">-contains-key?</span> <span class="tok-p">[</span><span class="tok-nv">_</span> <span class="tok-nv">k</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">contains? </span><span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">0</span> <span class="tok-mi">1</span><span class="tok-p">}</span> <span class="tok-nv">k</span><span class="tok-p">))</span>

  <span class="tok-p">(</span><span class="tok-nf">-assoc</span> <span class="tok-p">[</span><span class="tok-nv">p</span> <span class="tok-nv">k</span> <span class="tok-nv">v</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">case</span> <span class="tok-nv">k</span>
      <span class="tok-mi">0</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-nv">v</span> <span class="tok-p">(</span><span class="tok-nf">.-snd</span> <span class="tok-nv">p</span><span class="tok-p">))</span>
      <span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-p">(</span><span class="tok-nf">.-fst</span> <span class="tok-nv">p</span><span class="tok-p">)</span> <span class="tok-nv">v</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">throw</span> <span class="tok-p">(</span><span class="tok-nf">js/Error.</span> <span class="tok-s">&quot;Can only assoc to 0 and 1 keys&quot;</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">p</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Pair 1,2&gt;</span>

<span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-nv">p</span> <span class="tok-mi">0</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Pair 2,2&gt;</span>

<span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-nv">p</span> <span class="tok-mi">1</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Pair 1,1&gt;</span>

<span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-nv">p</span> <span class="tok-mi">0</span> <span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Pair 0,1&gt;</span>

<span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-nv">p</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; Error: Can only assoc to 0 and 1 keys</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The complementary function for <code>assoc</code> is <code>dissoc</code> and it&#8217;s part of the <code>IMap</code> protocol. It doesn&#8217;t make much
sense for our <code>Pair</code> type but we&#8217;ll implement it nonetheless. Dissociating 0 or 1 will mean putting a <code>nil</code>
in such position and invalid keys will be ignored.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">Pair</span>
  <span class="tok-nv">IMap</span>
  <span class="tok-p">(</span><span class="tok-nf">-dissoc</span> <span class="tok-p">[</span><span class="tok-nv">p</span> <span class="tok-nv">k</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">case</span> <span class="tok-nv">k</span>
      <span class="tok-mi">0</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-nv">nil</span> <span class="tok-p">(</span><span class="tok-nf">.-snd</span> <span class="tok-nv">p</span><span class="tok-p">))</span>
      <span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-p">(</span><span class="tok-nf">.-fst</span> <span class="tok-nv">p</span><span class="tok-p">)</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
      <span class="tok-nv">p</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">p</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Pair 1,2&gt;</span>

<span class="tok-p">(</span><span class="tok-nb">dissoc </span><span class="tok-nv">p</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Pair ,2&gt;</span>

<span class="tok-p">(</span><span class="tok-nb">dissoc </span><span class="tok-nv">p</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Pair 1,&gt;</span>

<span class="tok-p">(</span><span class="tok-nb">dissoc </span><span class="tok-nv">p</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Pair 1,2&gt;</span>

<span class="tok-p">(</span><span class="tok-nb">dissoc </span><span class="tok-nv">p</span> <span class="tok-mi">0</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Pair ,&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Associative data structures are made of key and value pairs we can call entries. The <code>key</code> and <code>val</code> functions allow
us to query the key and value of such entries and they are built upon the <code>IMapEntry</code> protocol. Let&#8217;s see a few examples
of <code>key</code> and <code>val</code> and how map entries can be used to build up maps:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">key </span><span class="tok-p">[</span><span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; :foo</span>

<span class="tok-p">(</span><span class="tok-nb">val </span><span class="tok-p">[</span><span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; :bar</span>

<span class="tok-p">(</span><span class="tok-nb">into </span><span class="tok-p">{}</span> <span class="tok-p">[[</span><span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-ss">:baz</span> <span class="tok-ss">:xyz</span><span class="tok-p">]])</span>
<span class="tok-c1">;; =&gt; {:foo :bar, :baz :xyz}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Pairs can be map entries too, we treat their first element as the key and the second as the value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">Pair</span>
  <span class="tok-nv">IMapEntry</span>
  <span class="tok-p">(</span><span class="tok-nf">-key</span> <span class="tok-p">[</span><span class="tok-nv">p</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">.-fst</span> <span class="tok-nv">p</span><span class="tok-p">))</span>

  <span class="tok-p">(</span><span class="tok-nf">-val</span> <span class="tok-p">[</span><span class="tok-nv">p</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">.-snd</span> <span class="tok-nv">p</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">p</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Pair 1,2&gt;</span>

<span class="tok-p">(</span><span class="tok-nb">key </span><span class="tok-nv">p</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nb">val </span><span class="tok-nv">p</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>

<span class="tok-p">(</span><span class="tok-nb">into </span><span class="tok-p">{}</span> <span class="tok-p">[</span><span class="tok-nv">p</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; {1 2}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="comparison"><a class="link" href="#comparison">5.4.6. Comparison</a></h4>
<div class="paragraph">
<p>For checking whether two or more values are equivalent with <code>=</code> we must implement the <code>IEquiv</code>
protocol. Let&#8217;s do it for our <code>Pair</code> type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">p</span>  <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">p</span><span class="tok-o">&#39;</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">p</span><span class="tok-o">&#39;&#39;</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">p</span> <span class="tok-nv">p</span><span class="tok-o">&#39;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">p</span> <span class="tok-nv">p</span><span class="tok-o">&#39;</span> <span class="tok-nv">p</span><span class="tok-o">&#39;&#39;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>

<span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">Pair</span>
  <span class="tok-nv">IEquiv</span>
  <span class="tok-p">(</span><span class="tok-nf">-equiv</span> <span class="tok-p">[</span><span class="tok-nv">p</span> <span class="tok-nv">other</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">and </span><span class="tok-p">(</span><span class="tok-nb">instance? </span><span class="tok-nv">Pair</span> <span class="tok-nv">other</span><span class="tok-p">)</span>
         <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-p">(</span><span class="tok-nf">.-fst</span> <span class="tok-nv">p</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">.-fst</span> <span class="tok-nv">other</span><span class="tok-p">))</span>
         <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-p">(</span><span class="tok-nf">.-snd</span> <span class="tok-nv">p</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">.-snd</span> <span class="tok-nv">other</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">p</span> <span class="tok-nv">p</span><span class="tok-o">&#39;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">p</span> <span class="tok-nv">p</span><span class="tok-o">&#39;</span> <span class="tok-nv">p</span><span class="tok-o">&#39;&#39;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also make types comparable. The function <code>compare</code> takes two values and returns a negative
number if the first is less than the second, 0 if both are equal and 1 if the first is greater than
the second. For making our types comparable we must implement the <code>IComparable</code> protocol.</p>
</div>
<div class="paragraph">
<p>For pairs, comparison will mean checking if the two first values are equal. If they are, the result
will be the comparison of the second values. If not, we will return the result of the first comparison:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">Pair</span>
  <span class="tok-nv">IComparable</span>
  <span class="tok-p">(</span><span class="tok-nf">-compare</span> <span class="tok-p">[</span><span class="tok-nv">p</span> <span class="tok-nv">other</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">fc</span> <span class="tok-p">(</span><span class="tok-nf">compare</span> <span class="tok-p">(</span><span class="tok-nf">.-fst</span> <span class="tok-nv">p</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">.-fst</span> <span class="tok-nv">other</span><span class="tok-p">))]</span>
      <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">zero? </span><span class="tok-nv">fc</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-nf">compare</span> <span class="tok-p">(</span><span class="tok-nf">.-snd</span> <span class="tok-nv">p</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">.-snd</span> <span class="tok-nv">other</span><span class="tok-p">))</span>
        <span class="tok-nv">fc</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">compare</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">0</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">0</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; 0</span>

<span class="tok-p">(</span><span class="tok-nf">compare</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">0</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">0</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; -1</span>

<span class="tok-p">(</span><span class="tok-nf">compare</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">1</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">0</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nb">sort </span><span class="tok-p">[(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">1</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">0</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">0</span> <span class="tok-mi">1</span><span class="tok-p">)])</span>
<span class="tok-c1">;; =&gt; (#&lt;Pair 0,1&gt; #&lt;Pair 0,2&gt; #&lt;Pair 1,1&gt;)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="metadata"><a class="link" href="#metadata">5.4.7. Metadata</a></h4>
<div class="paragraph">
<p>The <code>meta</code> and <code>with-meta</code> functions are also based upon two protocols: <code>IMeta</code> and <code>IWithMeta</code> respectively.
We can make our own types capable of carrying metadata adding an extra field for holding the metadata and
implementing both protocols.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s implement a version of <code>Pair</code> that can have metadata:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">deftype </span><span class="tok-nv">Pair</span> <span class="tok-p">[</span><span class="tok-nv">fst</span> <span class="tok-nv">snd</span> <span class="tok-nv">meta</span><span class="tok-p">]</span>
  <span class="tok-nv">IMeta</span>
  <span class="tok-p">(</span><span class="tok-nf">-meta</span> <span class="tok-p">[</span><span class="tok-nv">p</span><span class="tok-p">]</span> <span class="tok-nv">meta</span><span class="tok-p">)</span>

  <span class="tok-nv">IWithMeta</span>
  <span class="tok-p">(</span><span class="tok-nf">-with-meta</span> <span class="tok-p">[</span><span class="tok-nv">p</span> <span class="tok-nv">new-meta</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-nv">fst</span> <span class="tok-nv">snd</span> <span class="tok-nv">new-meta</span><span class="tok-p">)))</span>


<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">p</span> <span class="tok-p">(</span><span class="tok-nf">Pair.</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-p">{</span><span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span><span class="tok-p">}))</span>
<span class="tok-c1">;; =&gt; #&lt;Pair 1,2&gt;</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">p</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:foo :bar}</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">p</span><span class="tok-o">&#39;</span> <span class="tok-p">(</span><span class="tok-nb">with-meta </span><span class="tok-nv">p</span> <span class="tok-p">{</span><span class="tok-ss">:bar</span> <span class="tok-ss">:baz</span><span class="tok-p">}))</span>
<span class="tok-c1">;; =&gt; #&lt;Pair 1,2&gt;</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">p</span><span class="tok-o">&#39;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:bar :baz}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="interoperability-with-javascript"><a class="link" href="#interoperability-with-javascript">5.4.8. Interoperability with JavaScript</a></h4>
<div class="paragraph">
<p>Since ClojureScript is hosted in a JavaScript VM we often need to convert ClojureScript
data structures to JavaScript ones and viceversa. We also may want to make native JS
types participate in an abstraction represented by a protocol.</p>
</div>
<div class="sect4">
<h5 id="extending-javascript-types"><a class="link" href="#extending-javascript-types">Extending JavaScript types</a></h5>
<div class="paragraph">
<p>When extending JavaScript objects instead of using JS globals like <code>js/String</code>, <code>js/Date</code>
and such, special symbols are used. This is done for avoiding mutating global JS objects.</p>
</div>
<div class="paragraph">
<p>The symbols for extending JS types are: <code>object</code>, <code>array</code>, <code>number</code>, <code>string</code>,
<code>function</code>, <code>boolean</code> and <code>nil</code> is used for the null object. The dispatch of the
protocol to native objects uses Google Closure&#8217;s
<a href="https://google.github.io/closure-library/api/namespace_goog.html#typeOf">goog.typeOf</a>
function. There&#8217;s a special <code>default</code> symbol that can be used for making a default
implementation of a protocol for every type.</p>
</div>
<div class="paragraph">
<p>For illustrating the extension of JS types we are going to define a <code>MaybeMutable</code> protocol
that&#8217;ll have a <code>mutable?</code> predicate as its only function. Since in JavaScript mutability
is the default we&#8217;ll extend the default JS type returning true from <code>mutable?</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defprotocol </span><span class="tok-nv">MaybeMutable</span>
  <span class="tok-p">(</span><span class="tok-nf">mutable?</span> <span class="tok-p">[</span><span class="tok-nv">this</span><span class="tok-p">]</span> <span class="tok-s">&quot;Returns true if the value is mutable.&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">default</span>
  <span class="tok-nv">MaybeMutable</span>
  <span class="tok-p">(</span><span class="tok-nf">mutable?</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span> <span class="tok-nv">true</span><span class="tok-p">))</span>

<span class="tok-c1">;; object</span>
<span class="tok-p">(</span><span class="tok-nf">mutable?</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">{})</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-c1">;; array</span>
<span class="tok-p">(</span><span class="tok-nf">mutable?</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">[])</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-c1">;; string</span>
<span class="tok-p">(</span><span class="tok-nf">mutable?</span> <span class="tok-s">&quot;&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-c1">;; function</span>
<span class="tok-p">(</span><span class="tok-nf">mutable?</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-nv">x</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since fortunately not all JS object&#8217;s values are mutable we can refine the implementation of
<code>MaybeMutable</code> for returning <code>false</code> for strings and functions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-protocol</span> <span class="tok-nv">MaybeMutable</span>
  <span class="tok-nv">string</span>
  <span class="tok-p">(</span><span class="tok-nf">mutable?</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span> <span class="tok-nv">false</span><span class="tok-p">)</span>

  <span class="tok-nv">function</span>
  <span class="tok-p">(</span><span class="tok-nf">mutable?</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span> <span class="tok-nv">false</span><span class="tok-p">))</span>


<span class="tok-c1">;; object</span>
<span class="tok-p">(</span><span class="tok-nf">mutable?</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">{})</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-c1">;; array</span>
<span class="tok-p">(</span><span class="tok-nf">mutable?</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">[])</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-c1">;; string</span>
<span class="tok-p">(</span><span class="tok-nf">mutable?</span> <span class="tok-s">&quot;&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>

<span class="tok-c1">;; function</span>
<span class="tok-p">(</span><span class="tok-nf">mutable?</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-nv">x</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There is no special symbol for JavaScript dates so we have to extend <code>js/Date</code> directly. The same
applies to the rest of the types found in the global <code>js</code> namespace.</p>
</div>
</div>
<div class="sect4">
<h5 id="converting-data"><a class="link" href="#converting-data">Converting data</a></h5>
<div class="paragraph">
<p>For converting values from ClojureScript types to JavaScript ones and viceversa we use the <code>clj&#8594;js</code>
and <code>js&#8594;clj</code> functions, which are based in the <code>IEncodeJS</code> and <code>IEncodeClojure</code> protocols respectively.</p>
</div>
<div class="paragraph">
<p>For the examples we&#8217;ll use the Set type introduced in ES6. Note that is not available in every JS runtime.</p>
</div>
<div class="sect5">
<h6 id="from-clojurescript-to-js"><a class="link" href="#from-clojurescript-to-js">From ClojureScript to JS</a></h6>
<div class="paragraph">
<p>First of all we&#8217;ll extend ClojureScript&#8217;s set type for being able to convert it to JS. By default sets
are converted to JavaScript arrays:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">clj-&gt;js</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; #js [1 3 2]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s fix it, <code>clj&#8594;js</code> is supposed to convert values recursively so we&#8217;ll make sure to convert all the
set contents to JS and creating the set with the converted values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">PersistentHashSet</span>
  <span class="tok-nv">IEncodeJS</span>
  <span class="tok-p">(</span><span class="tok-nf">-clj-&gt;js</span> <span class="tok-p">[</span><span class="tok-nv">s</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">js/Set.</span> <span class="tok-p">(</span><span class="tok-nb">into-array </span><span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">clj-&gt;js</span> <span class="tok-nv">s</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">s</span> <span class="tok-p">(</span><span class="tok-nf">clj-&gt;js</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">}))</span>
<span class="tok-p">(</span><span class="tok-nf">es6-iterator-seq</span> <span class="tok-p">(</span><span class="tok-nf">.values</span> <span class="tok-nv">s</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; (1 3 2)</span>

<span class="tok-p">(</span><span class="tok-nb">instance? </span><span class="tok-nv">js/Set</span> <span class="tok-nv">s</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">.has</span> <span class="tok-nv">s</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">.has</span> <span class="tok-nv">s</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">.has</span> <span class="tok-nv">s</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">.has</span> <span class="tok-nv">s</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>es6-iterator-seq</code> is an experimental function in ClojureScript core for obtaining a seq from an ES6
iterable.</p>
</div>
</div>
<div class="sect5">
<h6 id="from-js-to-clojurescript"><a class="link" href="#from-js-to-clojurescript">From JS to ClojureScript</a></h6>
<div class="paragraph">
<p>Now it&#8217;s time to extend the JS set to convert to ClojureScript. As with <code>clj&#8594;js</code>, <code>js&#8594;clj</code> recursively converts
the value of the data structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">js/Set</span>
  <span class="tok-nv">IEncodeClojure</span>
  <span class="tok-p">(</span><span class="tok-nf">-js-&gt;clj</span> <span class="tok-p">[</span><span class="tok-nv">s</span> <span class="tok-nv">options</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">into </span><span class="tok-o">#</span><span class="tok-p">{}</span> <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">js-&gt;clj</span> <span class="tok-p">(</span><span class="tok-nf">es6-iterator-seq</span> <span class="tok-p">(</span><span class="tok-nf">.values</span> <span class="tok-nv">s</span><span class="tok-p">))))))</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">}</span>
   <span class="tok-p">(</span><span class="tok-nf">js-&gt;clj</span> <span class="tok-p">(</span><span class="tok-nf">clj-&gt;js</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">})))</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-o">#</span><span class="tok-p">{[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">6</span><span class="tok-p">]}</span>
   <span class="tok-p">(</span><span class="tok-nf">js-&gt;clj</span> <span class="tok-p">(</span><span class="tok-nf">clj-&gt;js</span> <span class="tok-o">#</span><span class="tok-p">{[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">6</span><span class="tok-p">]})))</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that there is no one-to-one mapping between ClojureScript and JavaScript values. For example, ClojureScript
keywords are converted to JavaScript strings when passed to <code>clj&#8594;js</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reductions"><a class="link" href="#reductions">5.4.9. Reductions</a></h4>
<div class="paragraph">
<p>The <code>reduce</code> function is based on the <code>IReduce</code> protocol, which enables us to make our own or third-party types
reducible. Apart from using them with <code>reduce</code> they will automatically work with <code>transduce</code> too, which will allow
us to make a reduction with a transducer.</p>
</div>
<div class="paragraph">
<p>The JS array is already reducible in ClojureScript:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">reduce + </span><span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 6</span>

<span class="tok-p">(</span><span class="tok-nf">transduce</span> <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">inc</span><span class="tok-p">)</span> <span class="tok-nb">conj </span><span class="tok-p">[]</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [2 3 4]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, the new ES6 Set type isn&#8217;t so let&#8217;s implement the <code>IReduce</code> protocol. We&#8217;ll get an iterator using the
Set&#8217;s <code>values</code> method and convert it to a seq with the <code>es6-iterator-seq</code> function; after that we&#8217;ll delegate to
the original <code>reduce</code> function to reduce the obtained sequence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">js/Set</span>
  <span class="tok-nv">IReduce</span>
  <span class="tok-p">(</span><span class="tok-nf">-reduce</span>
   <span class="tok-p">([</span><span class="tok-nv">s</span> <span class="tok-nv">f</span><span class="tok-p">]</span>
     <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">it</span> <span class="tok-p">(</span><span class="tok-nf">.values</span> <span class="tok-nv">s</span><span class="tok-p">)]</span>
       <span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-nv">f</span> <span class="tok-p">(</span><span class="tok-nf">es6-iterator-seq</span> <span class="tok-nv">it</span><span class="tok-p">))))</span>
   <span class="tok-p">([</span><span class="tok-nv">s</span> <span class="tok-nv">f</span> <span class="tok-nv">init</span><span class="tok-p">]</span>
     <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">it</span> <span class="tok-p">(</span><span class="tok-nf">.values</span> <span class="tok-nv">s</span><span class="tok-p">)]</span>
       <span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-nv">f</span> <span class="tok-nv">init</span> <span class="tok-p">(</span><span class="tok-nf">es6-iterator-seq</span> <span class="tok-nv">it</span><span class="tok-p">))))))</span>

<span class="tok-p">(</span><span class="tok-nb">reduce + </span><span class="tok-p">(</span><span class="tok-nf">js/Set.</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]))</span>
<span class="tok-c1">;; =&gt; 6</span>

<span class="tok-p">(</span><span class="tok-nf">transduce</span> <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">inc</span><span class="tok-p">)</span> <span class="tok-nb">conj </span><span class="tok-p">[]</span> <span class="tok-p">(</span><span class="tok-nf">js/Set.</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]))</span>
<span class="tok-c1">;; =&gt; [2 3 4]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Associative data structures can be reduced with the <code>reduce-kv</code> function, which is based in the <code>IKVReduce</code>
protocol. The main difference between <code>reduce</code> and <code>reduce-kv</code> is that the latter uses a three-argument function
as a reducer, receiving the accumulator, key and value for each item.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at an example, we will reduce a map to a vector of pairs. Note that, since vectors associate indexes to
values, they can also be reduced with <code>reduce-kv</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">reduce-kv</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">k</span> <span class="tok-nv">v</span><span class="tok-p">]</span>
             <span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">acc</span> <span class="tok-p">[</span><span class="tok-nv">k</span> <span class="tok-nv">v</span><span class="tok-p">]))</span>
           <span class="tok-p">[]</span>
           <span class="tok-p">{</span><span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span>
            <span class="tok-ss">:baz</span> <span class="tok-ss">:xyz</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; [[:foo :bar] [:baz :xyz]]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ll extend the new ES6 map type to support <code>reduce-kv</code>, we&#8217;ll do this by getting a sequence of key-value pairs
and calling the reducing function with the accumulator, key and value as positional arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">js/Map</span>
  <span class="tok-nv">IKVReduce</span>
  <span class="tok-p">(</span><span class="tok-nf">-kv-reduce</span> <span class="tok-p">[</span><span class="tok-nv">m</span> <span class="tok-nv">f</span> <span class="tok-nv">init</span><span class="tok-p">]</span>
   <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">it</span> <span class="tok-p">(</span><span class="tok-nf">.entries</span> <span class="tok-nv">m</span><span class="tok-p">)]</span>
     <span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-p">[</span><span class="tok-nv">k</span> <span class="tok-nv">v</span><span class="tok-p">]]</span>
               <span class="tok-p">(</span><span class="tok-nf">f</span> <span class="tok-nv">acc</span> <span class="tok-nv">k</span> <span class="tok-nv">v</span><span class="tok-p">))</span>
             <span class="tok-nv">init</span>
             <span class="tok-p">(</span><span class="tok-nf">es6-iterator-seq</span> <span class="tok-nv">it</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">m</span> <span class="tok-p">(</span><span class="tok-nf">js/Map.</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-nf">.set</span> <span class="tok-nv">m</span> <span class="tok-s">&quot;foo&quot;</span> <span class="tok-s">&quot;bar&quot;</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">.set</span> <span class="tok-nv">m</span> <span class="tok-s">&quot;baz&quot;</span> <span class="tok-s">&quot;xyz&quot;</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">reduce-kv</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">k</span> <span class="tok-nv">v</span><span class="tok-p">]</span>
             <span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">acc</span> <span class="tok-p">[</span><span class="tok-nv">k</span> <span class="tok-nv">v</span><span class="tok-p">]))</span>
           <span class="tok-p">[]</span>
           <span class="tok-nv">m</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [[&quot;foo&quot; &quot;bar&quot;] [&quot;baz&quot; &quot;xyz&quot;]]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In both examples we ended up delegating to the <code>reduce</code> function, which is aware of reduced values and terminates
when encountering one. Take into account that if you don&#8217;t implement these protocols in terms of <code>reduce</code> you will
have to check for reduced values for early termination.</p>
</div>
</div>
<div class="sect3">
<h4 id="asynchrony"><a class="link" href="#asynchrony">5.4.10. Asynchrony</a></h4>
<div class="paragraph">
<p>There are some types that have the notion of asynchronous computation, the value they represent may not
be realized yet. We can ask whether a value is realized using the <code>realized?</code> predicate.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s ilustrate it with the <code>Delay</code> type, which takes a computation and executes it when the result is needed.
When we dereference a delay the computation is run and the delay is realized:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">computation</span> <span class="tok-p">[]</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;running!&quot;</span><span class="tok-p">)</span>
  <span class="tok-mi">42</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">d</span> <span class="tok-p">(</span><span class="tok-nf">Delay.</span> <span class="tok-nv">computation</span> <span class="tok-nv">nil</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">realized?</span> <span class="tok-nv">d</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>

<span class="tok-p">(</span><span class="tok-nb">deref </span><span class="tok-nv">d</span><span class="tok-p">)</span>
<span class="tok-c1">;; running!</span>
<span class="tok-c1">;; =&gt; 42</span>

<span class="tok-p">(</span><span class="tok-nf">realized?</span> <span class="tok-nv">d</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-o">@</span><span class="tok-nv">d</span>
<span class="tok-c1">;; =&gt; 42</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Both <code>realized?</code> and <code>deref</code> sit atop two protocols: <code>IPending</code> and <code>IDeref</code>.</p>
</div>
<div class="paragraph">
<p>ES6 introduced a type that captures the notion of an asynchronous computation that might fail: the Promise.
A Promise represents an eventual value and can be in one of three states:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>pending: there is still no value available for this computation.</p>
</li>
<li>
<p>rejected: an error occurred and the promise contains a value that indicates the error.</p>
</li>
<li>
<p>resolved: the computation succesfully executed and the promise contains a value with the result.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Since the ES6 defined interface for promises doesn&#8217;t support querying its state we&#8217;ll use Bluebird
library&#8217;s Promise type for the examples. You can use Bluebird&#8217;s promise type with the <a href="https://github.com/funcool/promesa">Promesa</a>
library.</p>
</div>
<div class="paragraph">
<p>First of all we&#8217;ll add the ability to check if a promise is realized (either resolved or rejected) using the
<code>realized?</code> predicate. We just have to implement the <code>IPending</code> protocol:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">promesa.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">pro</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">js/Promise</span>
  <span class="tok-nv">IPending</span>
  <span class="tok-p">(</span><span class="tok-nf">-realized?</span> <span class="tok-p">[</span><span class="tok-nv">p</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">not </span><span class="tok-p">(</span><span class="tok-nf">.isPending</span> <span class="tok-nv">p</span><span class="tok-p">))))</span>


<span class="tok-p">(</span><span class="tok-nf">pro/promise</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nb">resolve </span><span class="tok-nv">reject</span><span class="tok-p">]))</span>
<span class="tok-c1">;; =&gt; #&lt;Promise {:status :pending}&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">realized?</span> <span class="tok-p">(</span><span class="tok-nf">pro/promise</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nb">resolve </span><span class="tok-nv">reject</span><span class="tok-p">])))</span>
<span class="tok-c1">;; =&gt; false</span>

<span class="tok-p">(</span><span class="tok-nf">pro/resolved</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Promise {:status :resolved, :value 42}&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">realized?</span> <span class="tok-p">(</span><span class="tok-nf">pro/resolved</span> <span class="tok-mi">42</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">pro/rejected</span> <span class="tok-p">(</span><span class="tok-nf">js/Error.</span> <span class="tok-s">&quot;OH NO&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Promise {:status :rejected, :error #object[Error Error: OH NO]}&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">realized?</span> <span class="tok-p">(</span><span class="tok-nf">pro/rejected</span> <span class="tok-p">(</span><span class="tok-nf">js/Error.</span> <span class="tok-s">&quot;OH NO&quot;</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we&#8217;ll extend promises to be derefable. When a promise that is still pending is dereferenced we will return
a special keyword: <code>:promise/pending</code>. If it&#8217;s not we&#8217;ll just return the value it contains, be it an error or a
result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">promesa.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">pro</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">js/Promise</span>
  <span class="tok-nv">IDeref</span>
  <span class="tok-p">(</span><span class="tok-nf">-deref</span> <span class="tok-p">[</span><span class="tok-nv">p</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">cond</span>
      <span class="tok-p">(</span><span class="tok-nf">.isPending</span> <span class="tok-nv">p</span><span class="tok-p">)</span>
      <span class="tok-ss">:promise/pending</span>

      <span class="tok-p">(</span><span class="tok-nf">.isRejected</span> <span class="tok-nv">p</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">.reason</span> <span class="tok-nv">p</span><span class="tok-p">)</span>

      <span class="tok-ss">:else</span>
      <span class="tok-p">(</span><span class="tok-nf">.value</span> <span class="tok-nv">p</span><span class="tok-p">))))</span>

<span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">pro/promise</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nb">resolve </span><span class="tok-nv">reject</span><span class="tok-p">]))</span>
<span class="tok-c1">;; =&gt; :promise/pending</span>

<span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">pro/resolved</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 42</span>

<span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">pro/rejected</span> <span class="tok-p">(</span><span class="tok-nf">js/Error.</span> <span class="tok-s">&quot;OH NO&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #object[Error Error: OH NO]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="state"><a class="link" href="#state">5.4.11. State</a></h4>
<div class="paragraph">
<p>The ClojureScript state constructs such as the Atom and the Volatile have different characteristics and semantics,
and the operations on them like <code>add-watch</code>, <code>reset!</code> or <code>swap!</code> are backed by protocols.</p>
</div>
<div class="sect4">
<h5 id="atom"><a class="link" href="#atom">Atom</a></h5>
<div class="paragraph">
<p>For ilustrating such protocols we will implement our own simplified version of an <code>Atom</code>. It won&#8217;t support validators
nor metadata, but we will be able to:
- <code>deref</code> the atom for getting its current value
- <code>reset!</code> the value contained in the atom
- <code>swap!</code> the atom with a function for transforming its state</p>
</div>
<div class="paragraph">
<p><code>deref</code> is based on the <code>IDeref</code> protocol. <code>reset!</code> is based on the <code>IReset</code> protocol and <code>swap!</code> on
<code>ISwap</code>. We&#8217;ll start by defining a data type and a constructor for our atom implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">deftype </span><span class="tok-nv">MyAtom</span> <span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-ss">:mutable</span> <span class="tok-nv">state</span> <span class="tok-o">^</span><span class="tok-ss">:mutable</span> <span class="tok-nv">watches</span><span class="tok-p">]</span>
  <span class="tok-nv">IPrintWithWriter</span>
  <span class="tok-p">(</span><span class="tok-nf">-pr-writer</span> <span class="tok-p">[</span><span class="tok-nv">p</span> <span class="tok-nv">writer</span> <span class="tok-nv">_</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">-write</span> <span class="tok-nv">writer</span> <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">&quot;#&lt;MyAtom &quot;</span> <span class="tok-p">(</span><span class="tok-nb">pr-str </span><span class="tok-nv">state</span><span class="tok-p">)</span> <span class="tok-s">&quot;&gt;&quot;</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-atom</span>
  <span class="tok-p">([]</span>
    <span class="tok-p">(</span><span class="tok-nf">my-atom</span> <span class="tok-nv">nil</span><span class="tok-p">))</span>
  <span class="tok-p">([</span><span class="tok-nv">init</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">MyAtom.</span> <span class="tok-nv">init</span> <span class="tok-p">{})))</span>

<span class="tok-p">(</span><span class="tok-nf">my-atom</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;MyAtom nil&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">my-atom</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;MyAtom 42&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that we&#8217;ve marked both the current state of the atom (<code>state</code>) and the map of watchers (<code>watches</code>) with the
<code>{:mutable true}</code> metadata. We&#8217;ll be modifying them and we&#8217;re making this explicit with the annotations.</p>
</div>
<div class="paragraph">
<p>Our <code>MyAtom</code> type is not very useful yet, we&#8217;ll start by implementing the <code>IDeref</code> protocol so we can dereference
its current value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">MyAtom</span>
  <span class="tok-nv">IDeref</span>
  <span class="tok-p">(</span><span class="tok-nf">-deref</span> <span class="tok-p">[</span><span class="tok-nv">a</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">.-state</span> <span class="tok-nv">a</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">my-atom</span> <span class="tok-mi">42</span><span class="tok-p">))</span>

<span class="tok-o">@</span><span class="tok-nv">a</span>
<span class="tok-c1">;; =&gt; 42</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that we can dereference it we&#8217;ll implement the <code>IWatchable</code> protocol, which will let us add and remove watches
to our custom atom. We&#8217;ll store the watches in the <code>watches</code> map of <code>MyAtom</code>, associating keys to callbacks.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">MyAtom</span>
  <span class="tok-nv">IWatchable</span>
  <span class="tok-p">(</span><span class="tok-nf">-add-watch</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-nb">key </span><span class="tok-nv">f</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">ws</span> <span class="tok-p">(</span><span class="tok-nf">.-watches</span> <span class="tok-nv">a</span><span class="tok-p">)]</span>
      <span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-p">(</span><span class="tok-nf">.-watches</span> <span class="tok-nv">a</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-nv">ws</span> <span class="tok-nb">key </span><span class="tok-nv">f</span><span class="tok-p">))))</span>

  <span class="tok-p">(</span><span class="tok-nf">-remove-watch</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-nv">key</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">ws</span> <span class="tok-p">(</span><span class="tok-nf">.-watches</span> <span class="tok-nv">a</span><span class="tok-p">)]</span>
      <span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-p">(</span><span class="tok-nf">.-watches</span> <span class="tok-nv">a</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">dissoc </span><span class="tok-nv">ws</span> <span class="tok-nv">key</span><span class="tok-p">))))</span>

  <span class="tok-p">(</span><span class="tok-nf">-notify-watches</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-nv">oldval</span> <span class="tok-nv">newval</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">doseq </span><span class="tok-p">[[</span><span class="tok-nb">key </span><span class="tok-nv">f</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">.-watches</span> <span class="tok-nv">a</span><span class="tok-p">)]</span>
      <span class="tok-p">(</span><span class="tok-nf">f</span> <span class="tok-nb">key </span><span class="tok-nv">a</span> <span class="tok-nv">oldval</span> <span class="tok-nv">newval</span><span class="tok-p">))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can now add watches to our atom but is not very useful since we still can&#8217;t change it. For incorporating change
we have to implement the <code>IReset</code> protocol and make sure we notify the watches every time we reset the atom&#8217;s value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">MyAtom</span>
  <span class="tok-nv">IReset</span>
  <span class="tok-p">(</span><span class="tok-nf">-reset!</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-nv">newval</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">oldval</span> <span class="tok-p">(</span><span class="tok-nf">.-state</span> <span class="tok-nv">a</span><span class="tok-p">)]</span>
      <span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-p">(</span><span class="tok-nf">.-state</span> <span class="tok-nv">a</span><span class="tok-p">)</span> <span class="tok-nv">newval</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">-notify-watches</span> <span class="tok-nv">a</span> <span class="tok-nv">oldval</span> <span class="tok-nv">newval</span><span class="tok-p">)</span>
      <span class="tok-nv">newval</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s check that we got it right. We&#8217;ll add a watch, change the atom&#8217;s value  making sure the watch gets called
and then remove it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">my-atom</span> <span class="tok-mi">41</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;MyAtom 41&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">add-watch</span> <span class="tok-nv">a</span> <span class="tok-ss">:log</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nb">key </span><span class="tok-nv">a</span> <span class="tok-nv">oldval</span> <span class="tok-nv">newval</span><span class="tok-p">]</span>
                    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">{</span><span class="tok-ss">:key</span> <span class="tok-nv">key</span>
                              <span class="tok-ss">:old</span> <span class="tok-nv">oldval</span>
                              <span class="tok-ss">:new</span> <span class="tok-nv">newval</span><span class="tok-p">})))</span>
<span class="tok-c1">;; =&gt; #&lt;MyAtom 41&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">reset!</span> <span class="tok-nv">a</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; {:key :log, :old 41, :new 42}</span>
<span class="tok-c1">;; =&gt; 42</span>

<span class="tok-p">(</span><span class="tok-nf">remove-watch</span> <span class="tok-nv">a</span> <span class="tok-ss">:log</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;MyAtom 42&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">reset!</span> <span class="tok-nv">a</span> <span class="tok-mi">43</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 43</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Our atom is still missing the swapping functionality so we&#8217;ll add that now, let&#8217;s implement the <code>ISwap</code> protocol. There
are four arities for the <code>-swap!</code> method of the protocol since the function passed to <code>swap!</code> may take one, two, three or
more arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">MyAtom</span>
  <span class="tok-nv">ISwap</span>
  <span class="tok-p">(</span><span class="tok-nf">-swap!</span>
   <span class="tok-p">([</span><span class="tok-nv">a</span> <span class="tok-nv">f</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">oldval</span> <span class="tok-p">(</span><span class="tok-nf">.-state</span> <span class="tok-nv">a</span><span class="tok-p">)</span>
          <span class="tok-nv">newval</span> <span class="tok-p">(</span><span class="tok-nf">f</span> <span class="tok-nv">oldval</span><span class="tok-p">)]</span>
      <span class="tok-p">(</span><span class="tok-nf">reset!</span> <span class="tok-nv">a</span> <span class="tok-nv">newval</span><span class="tok-p">)))</span>

   <span class="tok-p">([</span><span class="tok-nv">a</span> <span class="tok-nv">f</span> <span class="tok-nv">x</span><span class="tok-p">]</span>
     <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">oldval</span> <span class="tok-p">(</span><span class="tok-nf">.-state</span> <span class="tok-nv">a</span><span class="tok-p">)</span>
           <span class="tok-nv">newval</span> <span class="tok-p">(</span><span class="tok-nf">f</span> <span class="tok-nv">oldval</span> <span class="tok-nv">x</span><span class="tok-p">)]</span>
       <span class="tok-p">(</span><span class="tok-nf">reset!</span> <span class="tok-nv">a</span> <span class="tok-nv">newval</span><span class="tok-p">)))</span>

   <span class="tok-p">([</span><span class="tok-nv">a</span> <span class="tok-nv">f</span> <span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">]</span>
     <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">oldval</span> <span class="tok-p">(</span><span class="tok-nf">.-state</span> <span class="tok-nv">a</span><span class="tok-p">)</span>
           <span class="tok-nv">newval</span> <span class="tok-p">(</span><span class="tok-nf">f</span> <span class="tok-nv">oldval</span> <span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)]</span>
       <span class="tok-p">(</span><span class="tok-nf">reset!</span> <span class="tok-nv">a</span> <span class="tok-nv">newval</span><span class="tok-p">)))</span>

   <span class="tok-p">([</span><span class="tok-nv">a</span> <span class="tok-nv">f</span> <span class="tok-nv">x</span> <span class="tok-nv">y</span> <span class="tok-nv">more</span><span class="tok-p">]</span>
     <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">oldval</span> <span class="tok-p">(</span><span class="tok-nf">.-state</span> <span class="tok-nv">a</span><span class="tok-p">)</span>
           <span class="tok-nv">newval</span> <span class="tok-p">(</span><span class="tok-nb">apply </span><span class="tok-nv">f</span> <span class="tok-nv">oldval</span> <span class="tok-nv">x</span> <span class="tok-nv">y</span> <span class="tok-nv">more</span><span class="tok-p">)]</span>
       <span class="tok-p">(</span><span class="tok-nf">reset!</span> <span class="tok-nv">a</span> <span class="tok-nv">newval</span><span class="tok-p">)))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We now have a custom implementation of the atom abstraction, let&#8217;s test it in the REPL and see if it behaves like we expect:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">my-atom</span> <span class="tok-mi">0</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;MyAtom 0&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">add-watch</span> <span class="tok-nv">a</span> <span class="tok-ss">:log</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nb">key </span><span class="tok-nv">a</span> <span class="tok-nv">oldval</span> <span class="tok-nv">newval</span><span class="tok-p">]</span>
                    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">{</span><span class="tok-ss">:key</span> <span class="tok-nv">key</span>
                              <span class="tok-ss">:old</span> <span class="tok-nv">oldval</span>
                              <span class="tok-ss">:new</span> <span class="tok-nv">newval</span><span class="tok-p">})))</span>
<span class="tok-c1">;; =&gt; #&lt;MyAtom 0&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">swap!</span> <span class="tok-nv">a</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
<span class="tok-c1">;; {:key :log, :old 0, :new 1}</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nf">swap!</span> <span class="tok-nv">a</span> <span class="tok-nb">+ </span><span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; {:key :log, :old 1, :new 3}</span>
<span class="tok-c1">;; =&gt; 3</span>

<span class="tok-p">(</span><span class="tok-nf">swap!</span> <span class="tok-nv">a</span> <span class="tok-nb">- </span><span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; {:key :log, :old 3, :new 1}</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nf">swap!</span> <span class="tok-nv">a</span> <span class="tok-nb">+ </span><span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; {:key :log, :old 1, :new 6}</span>
<span class="tok-c1">;; =&gt; 6</span>


<span class="tok-p">(</span><span class="tok-nf">swap!</span> <span class="tok-nv">a</span> <span class="tok-nb">+ </span><span class="tok-mi">4</span> <span class="tok-mi">5</span> <span class="tok-mi">6</span><span class="tok-p">)</span>
<span class="tok-c1">;; {:key :log, :old 6, :new 21}</span>
<span class="tok-c1">;; =&gt; 21</span>

<span class="tok-p">(</span><span class="tok-nf">swap!</span> <span class="tok-nv">a</span> <span class="tok-nb">* </span><span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; {:key :log, :old 21, :new 42}</span>
<span class="tok-c1">;; =&gt; 42</span>

<span class="tok-p">(</span><span class="tok-nf">remove-watch</span> <span class="tok-nv">a</span> <span class="tok-ss">:log</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;MyAtom 42&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We did it! We implemented a version of ClojureScript Atom without support for metadata nor validators, extending it
to support such features is left as an exercise for the reader. Note that you&#8217;ll need to modify the <code>MyAtom</code> type for
being able to store metadata and a validator.</p>
</div>
</div>
<div class="sect4">
<h5 id="volatile"><a class="link" href="#volatile">Volatile</a></h5>
<div class="paragraph">
<p>Volatiles are simpler than atoms in that they don&#8217;t support watching for changes. All changes override the previous
value much like the mutable variables present in almost every programming language. Volatiles are based on the
<code>IVolatile</code> protocol that only defines a method for <code>vreset!</code>, since <code>vswap!</code> is implemented as a macro.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start by creating our own volatile type and constructor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">deftype </span><span class="tok-nv">MyVolatile</span> <span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-ss">:mutable</span> <span class="tok-nv">state</span><span class="tok-p">]</span>
  <span class="tok-nv">IPrintWithWriter</span>
  <span class="tok-p">(</span><span class="tok-nf">-pr-writer</span> <span class="tok-p">[</span><span class="tok-nv">p</span> <span class="tok-nv">writer</span> <span class="tok-nv">_</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">-write</span> <span class="tok-nv">writer</span> <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">&quot;#&lt;MyVolatile &quot;</span> <span class="tok-p">(</span><span class="tok-nb">pr-str </span><span class="tok-nv">state</span><span class="tok-p">)</span> <span class="tok-s">&quot;&gt;&quot;</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-volatile</span>
  <span class="tok-p">([]</span>
    <span class="tok-p">(</span><span class="tok-nf">my-volatile</span> <span class="tok-nv">nil</span><span class="tok-p">))</span>
  <span class="tok-p">([</span><span class="tok-nv">v</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">MyVolatile.</span> <span class="tok-nv">v</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">my-volatile</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;MyVolatile nil&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">my-volatile</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;MyVolatile 42&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Our <code>MyVolatile</code> still needs to support dereferencing and reseting it, let&#8217;s implement <code>IDeref</code> and <code>IVolatile</code>, which
will enable use to use <code>deref</code>, <code>vreset!</code> and <code>vswap!</code> in our custom volatile:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">MyVolatile</span>
  <span class="tok-nv">IDeref</span>
  <span class="tok-p">(</span><span class="tok-nf">-deref</span> <span class="tok-p">[</span><span class="tok-nv">v</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">.-state</span> <span class="tok-nv">v</span><span class="tok-p">))</span>

  <span class="tok-nv">IVolatile</span>
  <span class="tok-p">(</span><span class="tok-nf">-vreset!</span> <span class="tok-p">[</span><span class="tok-nv">v</span> <span class="tok-nv">newval</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-p">(</span><span class="tok-nf">.-state</span> <span class="tok-nv">v</span><span class="tok-p">)</span> <span class="tok-nv">newval</span><span class="tok-p">)</span>
    <span class="tok-nv">newval</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">v</span> <span class="tok-p">(</span><span class="tok-nf">my-volatile</span> <span class="tok-mi">0</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;MyVolatile 42&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">vreset!</span> <span class="tok-nv">v</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-o">@</span><span class="tok-nv">v</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nf">vswap!</span> <span class="tok-nv">v</span> <span class="tok-nb">+ </span><span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 6</span>

<span class="tok-o">@</span><span class="tok-nv">v</span>
<span class="tok-c1">;; =&gt; 6</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mutation"><a class="link" href="#mutation">5.4.12. Mutation</a></h4>
<div class="paragraph">
<p>In the <a href="#transients">section about transients</a> we learned about the mutable counterparts of the immutable
and persistent data structures that ClojureScript provides. These data structures are mutable, and the operations
on them end with a bang (<code>!</code>) to make that explicit. As you may have guessed every operation on transients
is based on protocols.</p>
</div>
<div class="sect4">
<h5 id="from-persistent-to-transient-and-viceversa"><a class="link" href="#from-persistent-to-transient-and-viceversa">From persistent to transient and viceversa</a></h5>
<div class="paragraph">
<p>We&#8217;ve learned that we can transform a persistent data structure with the <code>transient</code> function, which is based
on the <code>IEditableCollection</code> protocol; for transforming a transient data structure to a persistent one we
use <code>persistent!</code>, based on <code>ITransientCollection</code>.</p>
</div>
<div class="paragraph">
<p>Implementing immutable and persistent data structures and their transient counterparts is out of the scope of
this book but we recommend taking a look at ClojureScript&#8217;s data structure implementation if you are curious.</p>
</div>
</div>
<div class="sect4">
<h5 id="case-study-the-hodgepodge-library"><a class="link" href="#case-study-the-hodgepodge-library">Case study: the hodgepodge library</a></h5>
<div class="paragraph">
<p><a href="https://github.com/funcool/hodgepodge">Hodgepodge</a> is a ClojureScript library for treating the browser&#8217;s local
and session storage as if it were a transient data structure. It allows you to insert, read and delete ClojureScript
data structures without worrying about encoding and decoding them.</p>
</div>
<div class="paragraph">
<p>Browser&#8217;s storage is a simple key-value store that only supports strings. Since all of ClojureScript data structures
can be dumped into a string and reified from a string using <a href="#the-reader">the reader</a> we can store arbitrary ClojureScript
data in storage. We can also extend the reader for being able to read custom data types so we&#8217;re able to put our
types in storage and <code>hodgepodge</code> will handle the encoding and decoding for us.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll start by wrapping the low-level storage methods with functions. The following operations are supported by the storage:
- getting the value corresponding to a key
- seting a key to a certain value
- removing a value given its key
- counting the number of entries
- clearing the storage</p>
</div>
<div class="paragraph">
<p>Let&#8217;s wrap them in a more idiomatic API for ClojureScript:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">contains-key?</span>
  <span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-nv">js/Storage</span> <span class="tok-nv">storage</span> <span class="tok-o">^</span><span class="tok-nv">string</span> <span class="tok-nv">key</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">ks</span> <span class="tok-p">(</span><span class="tok-nf">.keys</span> <span class="tok-nv">js/Object</span> <span class="tok-nv">storage</span><span class="tok-p">)</span>
        <span class="tok-nv">idx</span> <span class="tok-p">(</span><span class="tok-nf">.indexOf</span> <span class="tok-nv">ks</span> <span class="tok-nv">key</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-nb">&gt;= </span><span class="tok-nv">idx</span> <span class="tok-mi">0</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">get-item</span>
  <span class="tok-p">([</span><span class="tok-o">^</span><span class="tok-nv">js/Storage</span> <span class="tok-nv">storage</span> <span class="tok-o">^</span><span class="tok-nv">string</span> <span class="tok-nv">key</span><span class="tok-p">]</span>
     <span class="tok-p">(</span><span class="tok-nf">get-item</span> <span class="tok-nv">storage</span> <span class="tok-nb">key </span><span class="tok-nv">nil</span><span class="tok-p">))</span>
  <span class="tok-p">([</span><span class="tok-o">^</span><span class="tok-nv">js/Storage</span> <span class="tok-nv">storage</span> <span class="tok-o">^</span><span class="tok-nv">string</span> <span class="tok-nb">key </span><span class="tok-o">^</span><span class="tok-nv">string</span> <span class="tok-nv">default</span><span class="tok-p">]</span>
     <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">contains-key?</span> <span class="tok-nv">storage</span> <span class="tok-nv">key</span><span class="tok-p">)</span>
       <span class="tok-p">(</span><span class="tok-nf">.getItem</span> <span class="tok-nv">storage</span> <span class="tok-nv">key</span><span class="tok-p">)</span>
       <span class="tok-nv">default</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">set-item</span>
  <span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-nv">js/Storage</span> <span class="tok-nv">storage</span> <span class="tok-o">^</span><span class="tok-nv">string</span> <span class="tok-nb">key </span><span class="tok-o">^</span><span class="tok-nv">string</span> <span class="tok-nv">val</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">.setItem</span> <span class="tok-nv">storage</span> <span class="tok-nb">key </span><span class="tok-nv">val</span><span class="tok-p">)</span>
  <span class="tok-nv">storage</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">remove-item</span>
  <span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-nv">js/Storage</span> <span class="tok-nv">storage</span> <span class="tok-o">^</span><span class="tok-nv">string</span> <span class="tok-nv">key</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">.removeItem</span> <span class="tok-nv">storage</span> <span class="tok-nv">key</span><span class="tok-p">)</span>
  <span class="tok-nv">storage</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">length</span>
  <span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-nv">js/Storage</span> <span class="tok-nv">storage</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">.-length</span> <span class="tok-nv">storage</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">clear!</span>
  <span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-nv">js/Storage</span> <span class="tok-nv">storage</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">.clear</span> <span class="tok-nv">storage</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Nothing too interesting going on there, we just wrapped the storage methods in a nicer API. Now we will define a couple
functions for serializing and deserializing ClojureScript data structures to strings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.reader</span> <span class="tok-ss">:as</span> <span class="tok-nv">reader</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">serialize</span> <span class="tok-p">[</span><span class="tok-nv">v</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">binding </span><span class="tok-p">[</span><span class="tok-nv">*print-dup*</span> <span class="tok-nv">true</span>
            <span class="tok-nv">*print-readably*</span> <span class="tok-nv">true</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">pr-str </span><span class="tok-nv">v</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">deserialize</span>
  <span class="tok-p">(</span><span class="tok-nf">memoize</span> <span class="tok-nv">reader/read-string</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>serialize</code> function is used for converting a ClojureScript data structure into a string using the <code>pr-str</code>
function, configuring a couple dynamic variables for obtaining the desired behaviour:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><strong>print-dup</strong></code> is set to <code>true</code> for a printed object to preserve its type when read later</p>
</li>
<li>
<p><code><strong>print-readably</strong></code> is set to <code>true</code> for not converting non-alphanumeric characters to their escape sequences</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>deserialize</code> function simply invokes the reader&#8217;s function for reading a string into a ClojureScript data
structure: <code>read-string</code>. It&#8217;s memoized for not having to call the reader each time we deserialize a string since
we can assume that a repeated string always corresponds to the same data structure.</p>
</div>
<div class="paragraph">
<p>Now we can start extending the browser&#8217;s <code>Storage</code> type for acting like a transient data structure. Take into
account that the <code>Storage</code> type is only available in browsers. We&#8217;ll start by implementing the <code>ICounted</code> protocol
for counting the items in the storage, we&#8217;ll simply delegate to our previously defined <code>length</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">js/Storage</span>
  <span class="tok-nv">ICounted</span>
  <span class="tok-p">(</span><span class="tok-nf">-count</span> <span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-nv">js/Storage</span> <span class="tok-nv">s</span><span class="tok-p">]</span>
   <span class="tok-p">(</span><span class="tok-nf">length</span> <span class="tok-nv">s</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We want to be able to use <code>assoc!</code> and <code>dissoc!</code> for inserting and deleting key-value pairs in the storage, as well
as the ability to read from it. We&#8217;ll implement the <code>ITransientAssociative</code> protocol for <code>assoc!</code>, <code>ITransientMap</code> for
<code>dissoc!</code> and <code>ILookup</code> for reading storage keys.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">js/Storage</span>
  <span class="tok-nv">ITransientAssociative</span>
  <span class="tok-p">(</span><span class="tok-nf">-assoc!</span> <span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-nv">js/Storage</span> <span class="tok-nv">s</span> <span class="tok-nb">key </span><span class="tok-nv">val</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">set-item</span> <span class="tok-nv">s</span> <span class="tok-p">(</span><span class="tok-nf">serialize</span> <span class="tok-nv">key</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">serialize</span> <span class="tok-nv">val</span><span class="tok-p">))</span>
    <span class="tok-nv">s</span><span class="tok-p">)</span>

  <span class="tok-nv">ITransientMap</span>
  <span class="tok-p">(</span><span class="tok-nf">-dissoc!</span> <span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-nv">js/Storage</span> <span class="tok-nv">s</span> <span class="tok-nv">key</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">remove-item</span> <span class="tok-nv">s</span> <span class="tok-p">(</span><span class="tok-nf">serialize</span> <span class="tok-nv">key</span><span class="tok-p">))</span>
    <span class="tok-nv">s</span><span class="tok-p">)</span>

  <span class="tok-nv">ILookup</span>
  <span class="tok-p">(</span><span class="tok-nf">-lookup</span>
    <span class="tok-p">([</span><span class="tok-o">^</span><span class="tok-nv">js/Storage</span> <span class="tok-nv">s</span> <span class="tok-nv">key</span><span class="tok-p">]</span>
       <span class="tok-p">(</span><span class="tok-nf">-lookup</span> <span class="tok-nv">s</span> <span class="tok-nb">key </span><span class="tok-nv">nil</span><span class="tok-p">))</span>
    <span class="tok-p">([</span><span class="tok-o">^</span><span class="tok-nv">js/Storage</span> <span class="tok-nv">s</span> <span class="tok-nb">key </span><span class="tok-nv">not-found</span><span class="tok-p">]</span>
       <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">sk</span> <span class="tok-p">(</span><span class="tok-nf">serialize</span> <span class="tok-nv">key</span><span class="tok-p">)]</span>
         <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">contains-key?</span> <span class="tok-nv">s</span> <span class="tok-nv">sk</span><span class="tok-p">)</span>
           <span class="tok-p">(</span><span class="tok-nf">deserialize</span> <span class="tok-p">(</span><span class="tok-nf">get-item</span> <span class="tok-nv">s</span> <span class="tok-nv">sk</span><span class="tok-p">))</span>
           <span class="tok-nv">not-found</span><span class="tok-p">)))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we&#8217;re able to perform some operations on either session or local storage, let&#8217;s give them a try:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">local-storage</span> <span class="tok-nv">js/localStorage</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">session-storage</span> <span class="tok-nv">js/sessionStorage</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">assoc!</span> <span class="tok-nv">local-storage</span> <span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-ss">:foo</span> <span class="tok-nv">local-storage</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; :bar</span>

<span class="tok-p">(</span><span class="tok-nf">dissoc!</span> <span class="tok-nv">local-storage</span> <span class="tok-ss">:foo</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nb">get </span><span class="tok-nv">local-storage</span> <span class="tok-ss">:foo</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nb">get </span><span class="tok-nv">local-storage</span> <span class="tok-ss">:foo</span> <span class="tok-ss">:default</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; :default</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, we want to be able to use <code>conj!</code> and <code>persistent!</code> on local storage so we must implement the <code>ITransientCollection</code>
protocol, let&#8217;s give it a go:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">js/Storage</span>
  <span class="tok-nv">ITransientCollection</span>
  <span class="tok-p">(</span><span class="tok-nf">-conj!</span> <span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-nv">js/Storage</span> <span class="tok-nv">s</span> <span class="tok-o">^</span><span class="tok-nv">IMapEntry</span> <span class="tok-nv">kv</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">assoc!</span> <span class="tok-nv">s</span> <span class="tok-p">(</span><span class="tok-nb">key </span><span class="tok-nv">kv</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">val </span><span class="tok-nv">kv</span><span class="tok-p">))</span>
    <span class="tok-nv">s</span><span class="tok-p">)</span>

  <span class="tok-p">(</span><span class="tok-nf">-persistent!</span> <span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-nv">js/Storage</span> <span class="tok-nv">s</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">into </span><span class="tok-p">{}</span>
          <span class="tok-p">(</span><span class="tok-nb">for </span><span class="tok-p">[</span><span class="tok-nv">i</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-nv">s</span><span class="tok-p">))</span>
                <span class="tok-ss">:let</span> <span class="tok-p">[</span><span class="tok-nv">k</span> <span class="tok-p">(</span><span class="tok-nf">.key</span> <span class="tok-nv">s</span> <span class="tok-nv">i</span><span class="tok-p">)</span>
                      <span class="tok-nv">v</span> <span class="tok-p">(</span><span class="tok-nf">get-item</span> <span class="tok-nv">s</span> <span class="tok-nv">k</span><span class="tok-p">)]]</span>
            <span class="tok-p">[(</span><span class="tok-nf">deserialize</span> <span class="tok-nv">k</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">deserialize</span> <span class="tok-nv">v</span><span class="tok-p">)]))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>conj!</code> simply obtains the key and value from the map entry and delegates to <code>assoc!</code>. <code>persistent!</code> deserializes every key-value
pair in the storage and returns an immutable snapshot of the storage as a ClojureScript map. Let&#8217;s try it out:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">clear!</span> <span class="tok-nv">local-storage</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">persistent!</span> <span class="tok-nv">local-storage</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {}</span>

<span class="tok-p">(</span><span class="tok-nf">conj!</span> <span class="tok-nv">local-storage</span> <span class="tok-p">[</span><span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">conj!</span> <span class="tok-nv">local-storage</span> <span class="tok-p">[</span><span class="tok-ss">:baz</span> <span class="tok-ss">:xyz</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">persistent!</span> <span class="tok-nv">local-storage</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:foo :bar, :baz :xyz}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="transient-vectors-and-sets"><a class="link" href="#transient-vectors-and-sets">Transient vectors and sets</a></h5>
<div class="paragraph">
<p>We&#8217;ve learned about most of the protocols for transient data structures but we&#8217;re missing two: <code>ITransientVector</code> for
using <code>assoc!</code> on transient vectors and <code>ITransientSet</code> for using <code>disj!</code> on transient sets.</p>
</div>
<div class="paragraph">
<p>For illustrating the <code>ITransientVector</code> protocol we&#8217;ll extend the JavaScript array type for making it an associative
transient data structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">array</span>
  <span class="tok-nv">ITransientAssociative</span>
  <span class="tok-p">(</span><span class="tok-nf">-assoc!</span> <span class="tok-p">[</span><span class="tok-nv">arr</span> <span class="tok-nb">key </span><span class="tok-nv">val</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">number?</span> <span class="tok-nv">key</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">-assoc-n!</span> <span class="tok-nv">arr</span> <span class="tok-nb">key </span><span class="tok-nv">val</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">throw</span> <span class="tok-p">(</span><span class="tok-nf">js/Error.</span> <span class="tok-s">&quot;Array&#39;s key for assoc! must be a number.&quot;</span><span class="tok-p">))))</span>

  <span class="tok-nv">ITransientVector</span>
  <span class="tok-p">(</span><span class="tok-nf">-assoc-n!</span> <span class="tok-p">[</span><span class="tok-nv">arr</span> <span class="tok-nv">n</span> <span class="tok-nv">val</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">.splice</span> <span class="tok-nv">arr</span> <span class="tok-nv">n</span> <span class="tok-mi">1</span> <span class="tok-nv">val</span><span class="tok-p">)</span>
    <span class="tok-nv">arr</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; #js [1 2 3]</span>

<span class="tok-p">(</span><span class="tok-nf">assoc!</span> <span class="tok-nv">a</span> <span class="tok-mi">0</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #js [42 2 3]</span>

<span class="tok-p">(</span><span class="tok-nf">assoc!</span> <span class="tok-nv">a</span> <span class="tok-mi">1</span> <span class="tok-mi">43</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #js [42 43 3]</span>

<span class="tok-p">(</span><span class="tok-nf">assoc!</span> <span class="tok-nv">a</span> <span class="tok-mi">2</span> <span class="tok-mi">44</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #js [42 43 44]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For illustrating the <code>ITransientSet</code> protocol we&#8217;ll extend the ES6 Set type for making it a transient set, supporting
the <code>conj!</code>, <code>disj!</code> and <code>persistent!</code> operations. Note that we&#8217;ve extended the Set type previously for being able to convert
it to ClojureScript and we&#8217;ll take advantage of that fact.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">js/Set</span>
  <span class="tok-nv">ITransientCollection</span>
  <span class="tok-p">(</span><span class="tok-nf">-conj!</span> <span class="tok-p">[</span><span class="tok-nv">s</span> <span class="tok-nv">v</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">.add</span> <span class="tok-nv">s</span> <span class="tok-nv">v</span><span class="tok-p">)</span>
    <span class="tok-nv">s</span><span class="tok-p">)</span>

  <span class="tok-p">(</span><span class="tok-nf">-persistent!</span> <span class="tok-p">[</span><span class="tok-nv">s</span><span class="tok-p">]</span>
   <span class="tok-p">(</span><span class="tok-nf">js-&gt;clj</span> <span class="tok-nv">s</span><span class="tok-p">))</span>

  <span class="tok-nv">ITransientSet</span>
  <span class="tok-p">(</span><span class="tok-nf">-disjoin!</span> <span class="tok-p">[</span><span class="tok-nv">s</span> <span class="tok-nv">v</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">.delete</span> <span class="tok-nv">s</span> <span class="tok-nv">v</span><span class="tok-p">)</span>
    <span class="tok-nv">s</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">s</span> <span class="tok-p">(</span><span class="tok-nf">js/Set.</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">conj!</span> <span class="tok-nv">s</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">conj!</span> <span class="tok-nv">s</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">conj!</span> <span class="tok-nv">s</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">conj!</span> <span class="tok-nv">s</span> <span class="tok-mi">2</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">persistent!</span> <span class="tok-nv">s</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{1 2}</span>

<span class="tok-p">(</span><span class="tok-nf">disj!</span> <span class="tok-nv">s</span> <span class="tok-mi">1</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">persistent!</span> <span class="tok-nv">s</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{2}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="the-reader"><a class="link" href="#the-reader">5.5. The Reader</a></h3>

</div>
<div class="sect2">
<h3 id="macros-section"><a class="link" href="#macros-section">5.6. Macros</a></h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix"><a class="link" href="#appendix">6. Appendix</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="appendix-a-interactive-development-with-figwheel"><a class="link" href="#appendix-a-interactive-development-with-figwheel">6.1. Appendix A: Interactive development with Figwheel</a></h3>
<div class="sect3">
<h4 id="introduction-3"><a class="link" href="#introduction-3">6.1.1. Introduction</a></h4>
<div class="paragraph">
<p>In this project, we will <strong>not</strong> do “Hello World”&#8212; that has been done to death.
Instead, this project will be a web page that asks you for your age in years and
tells you how many days that is, using an approximation of 365 days per year.</p>
</div>
<div class="paragraph">
<p>And for it, we will use the figwheel leiningen plugin. That plugin enables a fully
interactive, repl based and autoreloading experience.</p>
</div>
</div>
<div class="sect3">
<h4 id="first-steps-2"><a class="link" href="#first-steps-2">6.1.2. First steps</a></h4>
<div class="paragraph">
<p>In this project, we will use the <em>figwheel</em> template to build the project structure.
Let’s call the project <code>age</code> and create it by typing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>lein new figwheel age
Retrieving figwheel/lein-template/0.3.5/lein-template-0.3.5.pom from clojars
Retrieving figwheel/lein-template/0.3.5/lein-template-0.3.5.jar from clojars
Generating fresh <span class="tok-s1">&#39;lein new&#39;</span> figwheel project.
<span class="tok-nv">$ </span><span class="tok-nb">cd </span>age <span class="tok-c"># move into newly created project directory</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The project has the following structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>age
├── .gitignore
├── project.clj
├── README.md
├── resources
│   └── public
│       ├── css
│       │   └── style.css
│       └── index.html
└── src
    └── age
        └── core.cljs</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>project.clj</code> file contains information that Leiningen uses to download
dependencies and build the project. For now, just trust that everything in that
file is exactly as it should be.</p>
</div>
<div class="paragraph">
<p>Open the <code>index.html</code> file and add the <code>&lt;meta&gt;</code> element to the head of the document,
and modify the body as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="html"><span class="tok-cp">&lt;!DOCTYPE html&gt;</span>
<span class="tok-nt">&lt;html&gt;</span>
  <span class="tok-nt">&lt;head&gt;</span>
    <span class="tok-nt">&lt;link</span> <span class="tok-na">href=</span><span class="tok-s">&quot;css/style.css&quot;</span> <span class="tok-na">rel=</span><span class="tok-s">&quot;stylesheet&quot;</span> <span class="tok-na">type=</span><span class="tok-s">&quot;text/css&quot;</span><span class="tok-nt">&gt;</span>
    <span class="tok-nt">&lt;meta</span> <span class="tok-na">http-equiv=</span><span class="tok-s">&quot;Content-Type&quot;</span> <span class="tok-na">content=</span><span class="tok-s">&quot;text/html;charset=utf-8&quot;</span> <span class="tok-nt">/&gt;</span>
  <span class="tok-nt">&lt;/head&gt;</span>
  <span class="tok-nt">&lt;body&gt;</span>
    <span class="tok-nt">&lt;div</span> <span class="tok-na">id=</span><span class="tok-s">&quot;app&quot;</span><span class="tok-nt">&gt;</span>
      <span class="tok-nt">&lt;h1&gt;</span>Age in Days<span class="tok-nt">&lt;/h1&gt;</span>
      <span class="tok-nt">&lt;p&gt;</span>
        Enter your age in years:
        <span class="tok-nt">&lt;input</span> <span class="tok-na">type=</span><span class="tok-s">&quot;text&quot;</span> <span class="tok-na">size=</span><span class="tok-s">&quot;5&quot;</span> <span class="tok-na">id=</span><span class="tok-s">&quot;years&quot;</span><span class="tok-nt">&gt;</span>
        <span class="tok-nt">&lt;button</span> <span class="tok-na">id=</span><span class="tok-s">&quot;calculate&quot;</span><span class="tok-nt">&gt;</span>Calculate<span class="tok-nt">&lt;/button&gt;</span>
      <span class="tok-nt">&lt;/p&gt;</span>
      <span class="tok-nt">&lt;p</span> <span class="tok-na">id=</span><span class="tok-s">&quot;feedback&quot;</span><span class="tok-nt">&gt;&lt;/p&gt;</span>
    <span class="tok-nt">&lt;/div&gt;</span>
    <span class="tok-nt">&lt;script </span><span class="tok-na">src=</span><span class="tok-s">&quot;js/compiled/age.js&quot;</span> <span class="tok-na">type=</span><span class="tok-s">&quot;text/javascript&quot;</span><span class="tok-nt">&gt;&lt;/script&gt;</span>
  <span class="tok-nt">&lt;/body&gt;</span>
<span class="tok-nt">&lt;/html&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>core.cljs</code> file is where all the action takes place. For now, leave it exactly
as it is, and start the figwheel environment, which will load a large number of
dependencies and start a server.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>lein figwheel
<span class="tok-c"># much output</span>
Prompt will show when figwheel connects to your application</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are using Linux or Mac OS X, type the command as <code>rlwrap lein figwheel</code>.
In your browser, go to URL <code><a href="http://localhost:3449" class="bare">http://localhost:3449</a></code>, and you will see something
like the following screenshot if you open up the web console.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/localhost1.png" alt="Screenshot of web page and console"/>
</div>
</div>
<div class="paragraph">
<p>The terminal will then give you a REPL prompt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>rlwrap lein figwheel
To quit, <span class="tok-nb">type</span>: :cljs/quit
cljs.user<span class="tok-o">=</span>&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For now, do what it says in the <code>core.cljs</code> file&#8201;&#8212;&#8201;change the <code>(println&#8230;&#8203;)</code> and
then save the file. When you do so, you will see the change reflected immediately
in the browser.</p>
</div>
<div class="paragraph">
<p>Then make an error by adding an extra closing parenthesis to the <code>println</code>. When
you save the file, will see a compile error in the browser window.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/localhost2.png" alt="Screenshot of browser error message"/>
</div>
</div>
</div>
<div class="sect3">
<h4 id="interacting-with-javascript"><a class="link" href="#interacting-with-javascript">6.1.3. Interacting with JavaScript</a></h4>
<div class="paragraph">
<p>In the REPL window, type the following to invoke JavaScript’s <code>window.alert()</code>
function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">.alert</span> <span class="tok-nv">js/window</span> <span class="tok-s">&quot;It works!&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The general format for invoking a JavaScript function from ClojureScript is to
give the function name (preceded by a dot), the object that “owns” the function,
and any parameters to that function. You should see an alert appear in your
browser winodw; when you dismiss the alert, the REPL will print <code>nil</code> and give
you another prompt. You can also do it this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">js/alert</span> <span class="tok-s">&quot;It works!&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, the first version always works, so, for consistency, we will use that
notation throughout. You can create objects by using their class name followed by
a dot, and you can call methods on any JavaScript objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">d</span> <span class="tok-p">(</span><span class="tok-nf">js/Date.</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #inst &quot;2015-06-30T01:38:21.764-00:00&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">.getFullYear</span> <span class="tok-nv">d</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2015</span>

<span class="tok-p">(</span><span class="tok-nf">.toUpperCase</span> <span class="tok-s">&quot;abc&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;ABC&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">.getElementById</span> <span class="tok-nv">js/document</span> <span class="tok-s">&quot;years&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;[object HTMLInputElement]&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>From that last example, you can see where we’re going. To retrieve an object’s
property, use a <code>.-</code> before the property name. In the browser window, type a number
into the input field (in the example, we typed <code>24</code>), then do this in the REPL.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-c1">;; for convenience define a variable</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">year-field</span> <span class="tok-p">(</span><span class="tok-nf">.getElementById</span> <span class="tok-nv">js/document</span> <span class="tok-s">&quot;years&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;[object HTMLInputElement]&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">.-value</span> <span class="tok-nv">year-field</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;24&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-p">(</span><span class="tok-nf">.-value</span> <span class="tok-nv">year-field</span><span class="tok-p">)</span> <span class="tok-s">&quot;25&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;25&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This works, but it is little more than direct translation of JavaScript to
ClojureScript. The next step is to add event handling to the button. Event handling
is loaded with all sorts of cross-platform compatibility issues, so we’d like one
step up from plain ClojureScript.</p>
</div>
<div class="paragraph">
<p>The solution is the Google Closure library. To use it, you have to modify the
<code>:require</code> clause at the beginning of <code>core.cljs</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-o">^</span><span class="tok-ss">:figwheel-always</span> <span class="tok-nv">age.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">goog.dom</span> <span class="tok-ss">:as</span> <span class="tok-nv">dom</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">goog.events</span> <span class="tok-ss">:as</span> <span class="tok-nv">events</span><span class="tok-p">]))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Getting an element and setting its value is slightly easier. Do this in the REPL
and see the results in the browser window.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">in-ns </span><span class="tok-ss">&#39;age.core</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">y</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;years&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;[object HTMLInputElement]&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-p">(</span><span class="tok-nf">.-value</span> <span class="tok-nv">y</span><span class="tok-p">)</span> <span class="tok-s">&quot;26&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;26&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">dom/setTextContent</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;feedback&quot;</span><span class="tok-p">)</span> <span class="tok-s">&quot;This works!&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To add an event, you define a function that takes a single argument (the event to
be handled), and then tell the appropriate HTML element to listen for it. the
<code>events/listen</code> function takes three arguments: the element to listen to, the
event to listen for, and the function that will handle the event.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">testing</span> <span class="tok-p">[</span><span class="tok-nv">evt</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">js/alert</span> <span class="tok-s">&quot;Responding to click&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">events/listen</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;calculate&quot;</span><span class="tok-p">)</span> <span class="tok-s">&quot;click&quot;</span> <span class="tok-nv">testing</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;[object Object]&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>After doing this, the browser should respond to a click on the button.
If you would like to remove the listener, use <code>unlisten</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">events/unlisten</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;calculate&quot;</span><span class="tok-p">)</span> <span class="tok-s">&quot;click&quot;</span> <span class="tok-nv">testing</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, put that all together in the <code>core.cljs</code> file as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-o">^</span><span class="tok-ss">:figwheel-always</span> <span class="tok-nv">age.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">goog.dom</span> <span class="tok-ss">:as</span> <span class="tok-nv">dom</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">goog.events</span> <span class="tok-ss">:as</span> <span class="tok-nv">events</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">calculate</span>
  <span class="tok-p">[</span><span class="tok-nv">event</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">years</span> <span class="tok-p">(</span><span class="tok-nf">.parseInt</span> <span class="tok-nv">js/window</span> <span class="tok-p">(</span><span class="tok-nf">.-value</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;years&quot;</span><span class="tok-p">)))</span>
        <span class="tok-nv">days</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-mi">365</span> <span class="tok-nv">years</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-nf">dom/setTextContent</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;feedback&quot;</span><span class="tok-p">)</span>
                        <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">&quot;That is &quot;</span> <span class="tok-nv">days</span> <span class="tok-s">&quot; days old.&quot;</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">on-js-reload</span> <span class="tok-p">[])</span>

<span class="tok-p">(</span><span class="tok-nf">events/listen</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;calculate&quot;</span><span class="tok-p">)</span> <span class="tok-s">&quot;click&quot;</span> <span class="tok-nv">calculate</span><span class="tok-p">)</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="appendix-b-csp-and-core-async"><a class="link" href="#appendix-b-csp-and-core-async">6.2. Appendix B: CSP and core.async</a></h3>
<div class="paragraph">
<p>CSP stands for Communicating Sequential Processes, which is a formalism for describing
concurrent systems pioneered by C. A. R. Hoare in 1978. It is a concurrency model based
on message passing and synchronization through channels. An in-depth look at the
theoretical model behind CSP is out of the scope of this book, instead we&#8217;ll focus on
presenting the concurrency primitives that <code>core.async</code> offers.</p>
</div>
<div class="paragraph">
<p><code>core.async</code> is not part of ClojureScript core but it&#8217;s implemented as a library. Even
though is not part of the core language it&#8217;s widely used and many libraries build on top
of its primitives so we think is worth covering in the book. It&#8217;s also a good example of
the syntactic abstractions that can be achieved transforming code with ClojureScript
macros, so let&#8217;s jump right in. You&#8217;ll need to have <code>core.async</code> installed to run the
examples presented in this section.</p>
</div>
<div class="sect3">
<h4 id="channels"><a class="link" href="#channels">6.2.1. Channels</a></h4>
<div class="paragraph">
<p>Channels are like conveyor belts, we can put and take a single value at a time from them.
They can have multiple readers and writers and are the message-passing primitive of
<code>core.async</code>. Let&#8217;s create a channel do some operations on it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got a value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-c1">;; there is a now a pending take operation, let&#39;s put something on the channel</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; Got a value: 42</span>
<span class="tok-c1">;; =&gt; 42</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example we created a channel (<code>ch</code>) using the <code>chan</code> constructor. After that
we performed a take operation on the channel, providing a callback that will be invoked
when the take operation succeeds. After using <code>put!</code> to put a value on the channel the
take operation completed and the <code>"Got a value: 42"</code> string was printed. Note that <code>put!</code>
returned the value that was just put to the channel.</p>
</div>
<div class="paragraph">
<p>The <code>put!</code> function also accepts a callback like <code>take!</code> does but we didn&#8217;t provide any in
the last example. For puts the callback will be called whenever the value we provided has
been taken. Puts and takes can happen in any order, let&#8217;s do a few puts followed by
takes to illustrate the point:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Just put 42&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">43</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Just put 43&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; Got 42</span>
<span class="tok-c1">;; Just put 42</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; Got 43</span>
<span class="tok-c1">;; Just put 43</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You may be asking yourself why the <code>put!</code> operations return <code>true</code>. It signals that the
put operation could be performed, even though the value hasn&#8217;t yet been taken. Channels
can be closed, which will cause the put operations to not succeed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">close!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">ch</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The above example was the simplest possible situation but what happens with pending
operations when a channel is closed? Let&#8217;s do a few takes and close the channel and see
what happens:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span> <span class="tok-nv">close!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">ch</span><span class="tok-p">)</span>
<span class="tok-c1">;; Got value: nil</span>
<span class="tok-c1">;; Got value: nil</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We see that if the channel is closed all the <code>take!</code> operations receive a <code>nil</code> value.
<code>nil</code> in channels is a sentinel value that signals to takers that the channel has been
closed. Because of that, putting a <code>nil</code> value on a channel is not allowed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; Error: Assert failed: Can&#39;t put nil in on a channel</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="buffers"><a class="link" href="#buffers">Buffers</a></h5>
<div class="paragraph">
<p>We&#8217;ve seen that pending take and put operations are enqueued in a channel but, what
happens when there are many pending take or put operations? Let&#8217;s find out by hammering a
channel with many puts and takes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">dotimes </span><span class="tok-p">[</span><span class="tok-nv">n</span> <span class="tok-mi">1025</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-nv">n</span><span class="tok-p">))</span>
<span class="tok-c1">;; Error: Assert failed: No more than 1024 pending puts are allowed on a single channel.</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">dotimes </span><span class="tok-p">[</span><span class="tok-nv">n</span> <span class="tok-mi">1025</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)))</span>
<span class="tok-c1">;; Error: Assert failed: No more than 1024 pending takes are allowed on a single channel.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As the example above shows there&#8217;s a limit of pending puts or takes on a channel, it&#8217;s
currently 1024 but that is an implementation detail that may change. Note that there can&#8217;t
be both pending puts and pending takes on a channel since puts will immediately succeed
if there are pending takes and viceversa.</p>
</div>
<div class="paragraph">
<p>Channels support buffering of put operations. If we create a channel with a buffer the put
operations will succeed immediately if there&#8217;s room in the buffer and be enqueued
otherwise. Let&#8217;s illustrate the point creating a channel with a buffer of one element. The
<code>chan</code> constructors accepts a number as its first argument which will cause it to have
a buffer with the given size:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span> <span class="tok-mi">1</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Put succeeded!&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; Put succeeded!</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">dotimes </span><span class="tok-p">[</span><span class="tok-nv">n</span> <span class="tok-mi">1024</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-nv">n</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; Error: Assert failed: No more than 1024 pending puts are allowed on a single channel.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>What happened in the example above? We created a channel with a buffer of size 1 and
performed a put operation on it that succeeded immediately because the value was buffered.
After that we did another 1024 puts to fill the pending put queue and, when trying to put
one value more the channel complained about not being able to enqueue more puts.</p>
</div>
<div class="paragraph">
<p>Now that we know about how channels work and what are buffers used for let&#8217;s explore the
different buffers that <code>core.async</code> implements. Different buffers have different policies
and it&#8217;s interesting to know all of them to know when to use what. Channels are unbuffered
by default.</p>
</div>
<div class="sect5">
<h6 id="fixed"><a class="link" href="#fixed">Fixed</a></h6>
<div class="paragraph">
<p>The fixed size buffer is the one that is created when we give the <code>chan</code> constructor a
number and it will have the size specified by the given number. It is the simplest
possible buffer: when full, puts will be enqueued.</p>
</div>
<div class="paragraph">
<p>The <code>chan</code> constructor accepts either a number or a buffer as its first argument. The two
channels created in the following example both use a fixed buffer of size 32:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">buffer</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span> <span class="tok-mi">32</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">another-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span> <span class="tok-p">(</span><span class="tok-nf">buffer</span> <span class="tok-mi">32</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="dropping"><a class="link" href="#dropping">Dropping</a></h6>
<div class="paragraph">
<p>The fixed buffer allows put operations to be enqueued. However, as we saw before, puts
are still queued when the fixed buffer is full. If we wan&#8217;t to discard the put operations
that happen when the buffer is full we can use a dropping buffer.</p>
</div>
<div class="paragraph">
<p>Dropping buffers have a fixed size and, when they are full puts will complete but their
value will be discarded. Let&#8217;s illustrate the point with an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">dropping-buffer</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span> <span class="tok-p">(</span><span class="tok-nf">dropping-buffer</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">40</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">41</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; Got 40</span>
<span class="tok-c1">;; =&gt; nil</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; Got 41</span>
<span class="tok-c1">;; =&gt; nil</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We performed three put operations and the three of them succeded but, since the dropping
buffer of the channel has size 2, only the first two values were delivered to the takers.
As you can observe the third take is enqueued since there is no value available, the third
put&#8217;s value (42) was discarded.</p>
</div>
</div>
<div class="sect5">
<h6 id="sliding"><a class="link" href="#sliding">Sliding</a></h6>
<div class="paragraph">
<p>The sliding buffer has the opposite policy than the dropping buffer. When full puts will
complete and the oldest value will be discarded in favor of the new one. The sliding
buffer is useful when we are interested in processing the last puts only and we can afford
discarding old values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">sliding-buffer</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span> <span class="tok-p">(</span><span class="tok-nf">sliding-buffer</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">40</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">41</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; Got 41</span>
<span class="tok-c1">;; =&gt; nil</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; Got 42</span>
<span class="tok-c1">;; =&gt; nil</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We performed three put operations and the three of them succeded but, since the sliding
buffer of the channel has size 2, only the last two values were delivered to the takers.
As you can observe the third take is enqueued since there is no value available since the
first put&#8217;s value was discarded.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="transducers-2"><a class="link" href="#transducers-2">Transducers</a></h5>
<div class="paragraph">
<p>As mentioned in the section about transducers, putting values in a channel can be thought
as a transducible process. This means that we can create channels and hand them a
transducer, giving us the ability to transform the input values before being put in the
channel.</p>
</div>
<div class="paragraph">
<p>If we want to use a transducer with a channel we must supply a buffer since the reducing
function that will be modified by the transducer will be the buffer&#8217;s add function.
A buffer&#8217;s add function is a reducing function since it takes a buffer and an input and
returns a buffer with such input incorporated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span> <span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">inc</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">41</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; Got 42</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You may be wondering what happens to a channel when the reducing function returns a
reduced value. It turns out that the notion of termination for channels is being closed,
so channels will be closed when a reduced value is encountered:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span> <span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-nb">take </span><span class="tok-mi">2</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">41</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; Got 41</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">43</span><span class="tok-p">)</span>
<span class="tok-c1">;; Got 42</span>
<span class="tok-c1">;; Got nil</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We used the <code>take</code> stateful transducer to allow maximum 2 puts into the channel. We then
performed three take operations on the channel and we expect only two to receive a value.
As you can see in the above example the third take got the sentinel <code>nil</code> value which
indicates that the channel was closed. Also, the third put operation returned <code>false</code>
indicating that it didn&#8217;t take place.</p>
</div>
</div>
<div class="sect4">
<h5 id="handling-exceptions"><a class="link" href="#handling-exceptions">Handling exceptions</a></h5>
<div class="paragraph">
<p>If adding a value to a buffer throws an exception <code>core.async</code> the operation will fail and
the exception will be logged to the console. However, channel constructors accept a third
argument: a function for handling exceptions.</p>
</div>
<div class="paragraph">
<p>When creating a channel with an exception handler it will be called with the exception
whenever an exception occurs. If the handler returns <code>nil</code> the operation will fail
silently and if it returns another value the add operation will be retried with such
value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">exception-xform</span>
  <span class="tok-p">[</span><span class="tok-nv">rfn</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">throw</span> <span class="tok-p">(</span><span class="tok-nf">js/Error.</span> <span class="tok-s">&quot;I fail!&quot;</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">handle-exception</span>
  <span class="tok-p">[</span><span class="tok-nv">ex</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Exception message:&quot;</span> <span class="tok-p">(</span><span class="tok-nf">.-message</span> <span class="tok-nv">ex</span><span class="tok-p">))</span>
  <span class="tok-mi">42</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span> <span class="tok-mi">1</span> <span class="tok-nv">exception-xform</span> <span class="tok-nv">handle-exception</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; Exception message: I fail!</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; Got: 42</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="processes"><a class="link" href="#processes">6.2.2. Processes</a></h4>
<div class="paragraph">
<p>We learned all about channels but there is still a missing piece in the puzzle: processes.
Processes are pieces of logic that run independently and use channels for communication
and coordination. Puts and takes inside a process will stop the process until the
operation completes. Stopping a process doesn&#8217;t block the only thread we have in the
environments where ClojureScript runs. Instead, it will be resumed at a later time when
the operation is waiting for being performed.</p>
</div>
<div class="paragraph">
<p>Processes are launched using the <code>go</code> macro and puts and takes use the <code>&lt;!</code> and <code>&gt;!</code>
placeholders. The <code>go</code> macro rewrites your code to use callbacks but inside <code>go</code>
everything looks like synchronous code, which makes understanding it straightforward:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">&gt;!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Gonna take from channel&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">ch</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Gonna put on channel&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">&gt;!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Just put 42&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; [:a] Gonna take from channel</span>
<span class="tok-c1">;; [:b] Gonna put on channel</span>
<span class="tok-c1">;; [:b] Just put 42</span>
<span class="tok-c1">;; [:a] Got 42</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example we are launching a process with <code>go</code> that takes a value from <code>ch</code> and
prints it to the console. Since the value isn&#8217;t immediately available it will park until
it can resume. After that we launch another process that puts a value on the channel.
Since there is a pending take the put operation succeeds and the value is delivered to
the first process, then both processes terminate.</p>
</div>
<div class="paragraph">
<p>Both <code>go</code> blocks run independently and, even though they are executed asynchronously, they
look like synchronous code. The above go blocks are fairly simple but being able to
write concurrent processes that coordinate via channels is a very powerful tool for
implementing complex asynchronous workflows. Channels also offer a great decoupling of
producers and consumers.</p>
</div>
<div class="paragraph">
<p>Processes can wait for an arbitrary amount of time too, there is a <code>timeout</code> function
that return a channel that will be closed after the given amount of miliseconds. Combining
a timeout channel with a take operation inside a go block gives us the ability to sleep:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">&lt;!</span> <span class="tok-nv">timeout</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">seconds</span>
  <span class="tok-p">[]</span>
  <span class="tok-p">(</span><span class="tok-nf">.getSeconds</span> <span class="tok-p">(</span><span class="tok-nf">js/Date.</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Launching go block&quot;</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Gonna take a nap&quot;</span> <span class="tok-p">(</span><span class="tok-nf">seconds</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-p">(</span><span class="tok-nf">timeout</span> <span class="tok-mi">1000</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I slept one second, bye!&quot;</span> <span class="tok-p">(</span><span class="tok-nf">seconds</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Block launched&quot;</span><span class="tok-p">)</span>

<span class="tok-c1">;; Launching go block</span>
<span class="tok-c1">;; Block launched</span>
<span class="tok-c1">;; [:a] Gonna take a nap 9</span>
<span class="tok-c1">;; [:a] I slept one second, bye! 10</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As we can see in the messages printed, the process does nothing for one second when it
blocks in the take operation of the timeout channel. The program continues and after one
second the process resumes and terminates.</p>
</div>
<div class="sect4">
<h5 id="choice"><a class="link" href="#choice">Choice</a></h5>
<div class="paragraph">
<p>Apart from putting and taking one value at a time inside a go block we can also make a
non-deterministic choice on multiple channel operations using <code>alts!</code>. <code>alts!</code> is given
a series of channel put or take operations (note that we can also try to put and take in
a channel at the same time) and only performs one as soon as is ready; if multiple
operations can be performed when calling <code>alts!</code> it will do a pseudo random choice by
default.</p>
</div>
<div class="paragraph">
<p>We can easily try an operation on a channel and cancel it after a certain amount of time
combining the <code>timeout</code> function and <code>alts!</code>. Let&#8217;s see how:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">timeout</span> <span class="tok-nv">alts!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Gonna take a nap&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-p">(</span><span class="tok-nf">timeout</span> <span class="tok-mi">1000</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I slept one second, trying to put a value on channel&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">&gt;!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Gonna try taking from channel&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">cancel</span> <span class="tok-p">(</span><span class="tok-nf">timeout</span> <span class="tok-mi">300</span><span class="tok-p">)</span>
        <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-nv">ch</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">alts!</span> <span class="tok-p">[</span><span class="tok-nv">ch</span> <span class="tok-nv">cancel</span><span class="tok-p">])]</span>
    <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">ch</span> <span class="tok-nv">cancel</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Too slow, take from channel cancelled&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">))))</span>

<span class="tok-c1">;; [:a] Gonna take a nap</span>
<span class="tok-c1">;; [:b] Gonna try taking from channel</span>
<span class="tok-c1">;; [:b] Too slow, take from channel cancelled</span>
<span class="tok-c1">;; [:a] I slept one second, trying to put a value on channel</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above we launched a go block that, after waiting for a second, puts a value
in the <code>ch</code> channel. The other go block creates a <code>cancel</code> channel, which will be closed
after 300 miliseconds. After that, it tries to read from both <code>ch</code> and <code>cancel</code> at the same
time using <code>alts!</code>, which will succeed whenever it can take a value from either of those
channels. Since <code>cancel</code> is closed after 300 miliseconds, <code>alts!</code> will succeed since takes
from closed channel return the <code>nil</code> sentinel. Note that <code>alts!</code> returns a two-element
vector with the returned value of the operation and the channel where it was performed.
This is why we are able to detect whether the read operation was performed in the <code>cancel</code>
channel or in <code>ch</code>. I suggest you copy this example and set the first process timeout to
100 miliseconds to see how the read operation on <code>ch</code> succeeds.</p>
</div>
<div class="paragraph">
<p>We&#8217;ve learned how to choose between read operations so let&#8217;s look at how to express a
conditional write operation in <code>alts!</code>. Since we need to provide the channel and a value
to try to put on it, we&#8217;ll use a two element vector with the channel and the value for
representing write operations. Let&#8217;s see an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">alts!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">another-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Take a value from `a-ch`&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">a-ch</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Take a value from `another-ch`&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">another-ch</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:c</span><span class="tok-p">]</span> <span class="tok-s">&quot;Gonna try putting in both channels simultaneously&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[[</span><span class="tok-nv">value</span> <span class="tok-nv">ch</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">alts!</span> <span class="tok-p">[[</span><span class="tok-nv">a-ch</span> <span class="tok-mi">42</span><span class="tok-p">]</span>
                           <span class="tok-p">[</span><span class="tok-nv">another-ch</span> <span class="tok-mi">99</span><span class="tok-p">]])]</span>
    <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">ch</span> <span class="tok-nv">a-ch</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:c</span><span class="tok-p">]</span> <span class="tok-s">&quot;Put a value in `a-ch`&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:c</span><span class="tok-p">]</span> <span class="tok-s">&quot;Put a value in `another-ch`&quot;</span><span class="tok-p">))))</span>

<span class="tok-c1">;; [:a] Take a value from `a-ch`</span>
<span class="tok-c1">;; [:b] Take a value from `another-ch`</span>
<span class="tok-c1">;; [:c] Gonna try putting in both channels simultaneously</span>
<span class="tok-c1">;; [:c] Put a value in `a-ch`</span>
<span class="tok-c1">;; [:a] Got 42</span>
<span class="tok-c1">;; [:a] I&#39;m done!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When running the above example only the put operation on the <code>a-ch</code> channel has succeeded.
Since both channels are ready to take a value when the <code>alts!</code> occurs you may get
different results when running this code.</p>
</div>
</div>
<div class="sect4">
<h5 id="priority"><a class="link" href="#priority">Priority</a></h5>
<div class="paragraph">
<p><code>alts!</code> default is to make a non-deterministic choice whenever several operations are
ready to be performed. We can instead give priority to the operations passing the
<code>:priority</code> option to <code>alts!</code>. Whenever <code>:priority</code> is <code>true</code>, if more than one operation
is ready they will be tried in order.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">&gt;!</span> <span class="tok-nv">alts!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">another-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Put a value on `a-ch`&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">&gt;!</span> <span class="tok-nv">a-ch</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Put a value on `another-ch`&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">&gt;!</span> <span class="tok-nv">another-ch</span> <span class="tok-mi">99</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:c</span><span class="tok-p">]</span> <span class="tok-s">&quot;Gonna try taking from both channels with priority&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[[</span><span class="tok-nv">value</span> <span class="tok-nv">ch</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">alts!</span> <span class="tok-p">[</span><span class="tok-nv">a-ch</span> <span class="tok-nv">another-ch</span><span class="tok-p">]</span> <span class="tok-ss">:priority</span> <span class="tok-nv">true</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">ch</span> <span class="tok-nv">a-ch</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:c</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span> <span class="tok-s">&quot;from `a-ch`&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:c</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span> <span class="tok-s">&quot;from `another-ch`&quot;</span><span class="tok-p">))))</span>

<span class="tok-c1">;; [:a] Put a value on `a-ch`</span>
<span class="tok-c1">;; [:a] I&#39;m done!</span>
<span class="tok-c1">;; [:b] Put a value on `another-ch`</span>
<span class="tok-c1">;; [:b] I&#39;m done!</span>
<span class="tok-c1">;; [:c] Gonna try taking from both channels with priority</span>
<span class="tok-c1">;; [:c] Got 42 from `a-ch`</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since both <code>a-ch</code> and <code>another-ch</code> had a value to read when the <code>alts!</code> was executed and
we set the <code>:priority</code> option to true, <code>a-ch</code> has preference. You can try deleting the
<code>:priority</code> option and running the example multiple times to see that, without priority,
<code>alts!</code> makes a non-deterministic choice.</p>
</div>
</div>
<div class="sect4">
<h5 id="defaults"><a class="link" href="#defaults">Defaults</a></h5>
<div class="paragraph">
<p>Another interesting bit of <code>alts!</code> is that it can return immediately if no operation is
ready and we provide a default value. We can conditionally do a choice on the operations
if and only if any of them is ready, returning a default value if it&#8217;s not.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">alts!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">another-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Gonna try taking from any of the channels without blocking&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[[</span><span class="tok-nv">value</span> <span class="tok-nv">ch</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">alts!</span> <span class="tok-p">[</span><span class="tok-nv">a-ch</span> <span class="tok-nv">another-ch</span><span class="tok-p">]</span> <span class="tok-ss">:default</span> <span class="tok-ss">:not-ready</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">and </span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">value</span> <span class="tok-ss">:not-ready</span><span class="tok-p">)</span>
             <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">ch</span> <span class="tok-ss">:default</span><span class="tok-p">))</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;No operation is ready, aborting&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">))))</span>

<span class="tok-c1">;; [:a] Gonna try taking from any of the channels without blocking</span>
<span class="tok-c1">;; [:a] No operation is ready, aborting</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see in the above example, if no operation is ready the value returned by
<code>alts!</code> is the one we supplied after the <code>:default</code> key when calling it and the channel is
the <code>:default</code> keyword itself.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="combinators"><a class="link" href="#combinators">6.2.3. Combinators</a></h4>
<div class="paragraph">
<p>Now that we&#8217;re acquainted with channels and processes it&#8217;s time to explore some interesting
combinators for working with channels that are present in <code>core.async</code>. This section
includes a brief description of all of them together with a simple example of their usage.</p>
</div>
<div class="sect4">
<h5 id="pipe"><a class="link" href="#pipe">pipe</a></h5>
<div class="paragraph">
<p><code>pipe</code> takes an input and output channels and pipes all the values put on the input channel
to the output one. The output channel is closed whenever the source is closed unless we
provide a <code>false</code> third argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">pipe</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go-loop</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">out</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">pipe</span> <span class="tok-nv">in</span> <span class="tok-nv">out</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Waiting for a value&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">in</span><span class="tok-p">)</span>

<span class="tok-c1">;; [:a] Got 0</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] Got 1</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] I&#39;m done!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example we used the <code>go-loop</code> macro for reading values recursively until the
<code>out</code> channel is closed. Notice that when we close the <code>in</code> channel the <code>out</code> channel is
closed too, making the <code>go-loop</code> terminate.</p>
</div>
</div>
<div class="sect4">
<h5 id="pipeline-async"><a class="link" href="#pipeline-async">pipeline-async</a></h5>
<div class="paragraph">
<p><code>pipeline-async</code> takes a number for controlling parallelism, an output channel, an
asynchronous function and an input channel. The asynchronous function has two arguments:
the value put in the input channel and a channel where it should put the result of its
asynchronous operation, closing the result channel after finishing. The number controls
the number of concurrent go blocks that will be used for calling the asynchronous function
with the inputs.</p>
</div>
<div class="paragraph">
<p>The output channel will receive outputs in an order relative to the input channel,
regardless the time each asynchronous function call takes to complete. It has an optional
last parameter that controls whether the output channel will be closed when the input
channel is closed, which defaults to <code>true</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">pipeline-async</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go-loop</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">out</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">parallelism</span> <span class="tok-mi">3</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">wait-and-put</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-nv">ch</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">wait</span> <span class="tok-p">(</span><span class="tok-nb">rand-int </span><span class="tok-mi">1000</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-nf">js/setTimeout</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[]</span>
                     <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Waiting&quot;</span> <span class="tok-nv">wait</span> <span class="tok-s">&quot;miliseconds for value&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
                     <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-nv">wait</span><span class="tok-p">)</span>
                     <span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">ch</span><span class="tok-p">))</span>
                   <span class="tok-nv">wait</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">pipeline-async</span> <span class="tok-nv">parallelism</span> <span class="tok-nv">out</span> <span class="tok-nv">wait-and-put</span> <span class="tok-nv">in</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Waiting for a value&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">in</span><span class="tok-p">)</span>

<span class="tok-c1">;; Waiting 164 miliseconds for value 3</span>
<span class="tok-c1">;; Waiting 304 miliseconds for value 2</span>
<span class="tok-c1">;; Waiting 908 miliseconds for value 1</span>
<span class="tok-c1">;; [:a] Got 908</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] Got 304</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] Got 164</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] I&#39;m done!</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pipeline"><a class="link" href="#pipeline">pipeline</a></h5>
<div class="paragraph">
<p><code>pipeline</code> is similar to <code>pipeline-async</code> but instead of taking and asynchronous function
it takes a transducer instead. The transducer will be applied independently to each input.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">pipeline</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go-loop</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">out</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">parallelism</span> <span class="tok-mi">3</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">pipeline</span> <span class="tok-nv">parallelism</span> <span class="tok-nv">out</span> <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">inc</span><span class="tok-p">)</span> <span class="tok-nv">in</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Waiting for a value&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">in</span><span class="tok-p">)</span>

<span class="tok-c1">;; [:a] Got 2</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] Got 3</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] Got 4</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] I&#39;m done!</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="split"><a class="link" href="#split">split</a></h5>
<div class="paragraph">
<p><code>split</code> takes a predicate and a channel and returns a vector with two channels, the first
of which will receive the values for which the predicate is true, the second will receive
those for which the predicate is false. We can optionally pass a buffer or number for the
channels with the third (true channel) and fourth (false channel) arguments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">split</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go-loop</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">chans</span> <span class="tok-p">(</span><span class="tok-nf">split</span> <span class="tok-nv">even?</span> <span class="tok-nv">in</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">even-ch</span> <span class="tok-p">(</span><span class="tok-nb">first </span><span class="tok-nv">chans</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">odd-ch</span> <span class="tok-p">(</span><span class="tok-nb">second </span><span class="tok-nv">chans</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">even-ch</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:evens</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:evens</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:evens</span><span class="tok-p">]</span> <span class="tok-s">&quot;Waiting for a value&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">even-ch</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">odd-ch</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:odds</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:odds</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:odds</span><span class="tok-p">]</span> <span class="tok-s">&quot;Waiting for a value&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">odd-ch</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">in</span><span class="tok-p">)</span>

<span class="tok-c1">;; [:evens] Got 0</span>
<span class="tok-c1">;; [:evens] Waiting for a value</span>
<span class="tok-c1">;; [:odds] Got 1</span>
<span class="tok-c1">;; [:odds] Waiting for a value</span>
<span class="tok-c1">;; [:odds] Got 3</span>
<span class="tok-c1">;; [:odds] Waiting for a value</span>
<span class="tok-c1">;; [:evens] Got 2</span>
<span class="tok-c1">;; [:evens] Waiting for a value</span>
<span class="tok-c1">;; [:evens] I&#39;m done!</span>
<span class="tok-c1">;; [:odds] I&#39;m done!</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reduce"><a class="link" href="#reduce">reduce</a></h5>
<div class="paragraph">
<p><code>reduce</code> takes a reducing function, initial value and an input channel. It returns a
channel with the result of reducing over all the values put on the input channel before
closing it using the given initial value as the seed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:as</span> <span class="tok-nv">async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Result&quot;</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-p">(</span><span class="tok-nf">async/reduce</span> <span class="tok-nb">+ </span><span class="tok-p">(</span><span class="tok-nf">+</span><span class="tok-p">)</span> <span class="tok-nv">in</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">in</span><span class="tok-p">)</span>

<span class="tok-c1">;; Result: 6</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="onto-chan"><a class="link" href="#onto-chan">onto-chan</a></h5>
<div class="paragraph">
<p><code>onto-chan</code> takes a channel and a collection and puts the contents of the collection into
the channel. It closes the channel after finishing although it accepts a third argument for
specifying if it should close it or not. Let&#8217;s rewrite the <code>reduce</code> example using
<code>onto-chan</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:as</span> <span class="tok-nv">async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span> <span class="tok-nv">onto-chan</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Result&quot;</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-p">(</span><span class="tok-nf">async/reduce</span> <span class="tok-nb">+ </span><span class="tok-p">(</span><span class="tok-nf">+</span><span class="tok-p">)</span> <span class="tok-nv">in</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">onto-chan</span> <span class="tok-nv">in</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>

<span class="tok-c1">;; Result: 6</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="to-chan"><a class="link" href="#to-chan">to-chan</a></h5>
<div class="paragraph">
<p><code>to-chan</code> takes a collection and returns a channel where it will put every value in the
collection, closing the channel afterwards.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span> <span class="tok-nv">to-chan</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go-loop</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">to-chan</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">3</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">ch</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Waiting for a value&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">ch</span><span class="tok-p">)))))</span>

<span class="tok-c1">;; [:a] Got 0</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] Got 1</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] Got 2</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] I&#39;m done!</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="merge"><a class="link" href="#merge">merge</a></h5>
<div class="paragraph">
<p><code>merge</code> takes a collection of input channels and returns a channel where it will put every
value that is put on the input channels. The returned channel will be closed when all the
input channels have been closed. The returned channel will be unbuffered by default but a
number or buffer can be provided as the last argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span> <span class="tok-nv">merge</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go-loop</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in1</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in2</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in3</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">out</span> <span class="tok-p">(</span><span class="tok-nb">merge </span><span class="tok-p">[</span><span class="tok-nv">in1</span> <span class="tok-nv">in2</span> <span class="tok-nv">in3</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Waiting for a value&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in1</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">in1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in2</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">in2</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in3</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">in3</span><span class="tok-p">)</span>

<span class="tok-c1">;; [:a] Got 3</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] Got 2</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] Got 1</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] I&#39;m done!</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="higher-level-abstractions"><a class="link" href="#higher-level-abstractions">6.2.4. Higher-level abstractions</a></h4>
<div class="paragraph">
<p>We&#8217;ve learned the about the low-level primitives of <code>core.async</code> and the combinators that it offers
for working with channels. <code>core.async</code> also offers some useful, higher-level abstractions on top of
channels that can serve as building blocks for more advanced functionality.</p>
</div>
<div class="sect4">
<h5 id="mult"><a class="link" href="#mult">Mult</a></h5>
<div class="paragraph">
<p>Whenever we have a channel whose values have to be broadcasted to many others, we can use <code>mult</code> for
creating a multiple of the supplied channel. Once we have a mult, we can attach channels to it using
<code>tap</code> and dettach them using <code>untap</code>. Mults also support removing all tapped channels at once with
<code>untap-all</code>.</p>
</div>
<div class="paragraph">
<p>Every value put in the source channel of a mult is broadcasted to all the tapped channels, and all of
them must accept it before the next item is broadcasted. For preventing slow takers from blocking the
mult&#8217;s values we must use buffering on the tapped channels judiciously.</p>
</div>
<div class="paragraph">
<p>Closed tapped channels are removed automatically from the mult. When putting a value in the source
channels when there are still no taps such value will be dropped.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span> <span class="tok-nv">timeout</span> <span class="tok-nv">mult</span> <span class="tok-nv">tap</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go-loop</span><span class="tok-p">]])</span>

<span class="tok-c1">;; Source channel and mult</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">m-in</span> <span class="tok-p">(</span><span class="tok-nf">mult</span> <span class="tok-nv">in</span><span class="tok-p">))</span>

<span class="tok-c1">;; Sink channels</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">another-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-c1">;; Taker for `a-ch`</span>
<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">a-ch</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">a-ch</span><span class="tok-p">)))))</span>

<span class="tok-c1">;; Taker for `another-ch`, which sleeps for 3 seconds between takes</span>
<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">another-ch</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Resting 3 seconds&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-p">(</span><span class="tok-nf">timeout</span> <span class="tok-mi">3000</span><span class="tok-p">))</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">another-ch</span><span class="tok-p">)))))</span>

<span class="tok-c1">;; Tap the two channels to the mult</span>
<span class="tok-p">(</span><span class="tok-nf">tap</span> <span class="tok-nv">m-in</span> <span class="tok-nv">a-ch</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">tap</span> <span class="tok-nv">m-in</span> <span class="tok-nv">another-ch</span><span class="tok-p">)</span>

<span class="tok-c1">;; See how the values are delivered to `a-ch` and `another-ch`</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">2</span><span class="tok-p">)</span>

<span class="tok-c1">;; [:a] Got 1</span>
<span class="tok-c1">;; [:b] Got 1</span>
<span class="tok-c1">;; [:b] Resting for 3 seconds</span>
<span class="tok-c1">;; [:a] Got 2</span>
<span class="tok-c1">;; [:b] Got 2</span>
<span class="tok-c1">;; [:b] Resting for 3 seconds</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pub-sub"><a class="link" href="#pub-sub">Pub-sub</a></h5>
<div class="paragraph">
<p>After learning about mults you could imagine how to implement a pub-sub abstraction on top of <code>mult</code>, <code>tap</code> and
<code>untap</code> but since it&#8217;s a widely used communication mechanism <code>core.async</code> already implements this functionality.
Instead of creating a mult from a source channel, we create a publication with <code>pub</code> giving it a channel and a
function that will be used for extracting the topic of the messages.</p>
</div>
<div class="paragraph">
<p>We can subscribe to a publication with <code>sub</code>, giving it the publication we want to subscribe to, the topic we
are interested in and a channel to put the messages that have the given topic. Note that we can subscribe a
channel to multiple topics.</p>
</div>
<div class="paragraph">
<p><code>unsub</code> can be given a publication, topic and channel for unsubscribing such channel from the topic.
<code>unsub-all</code> can be given a publication and a topic to unsubscribe every channel from the given topic.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span> <span class="tok-nv">pub</span> <span class="tok-nv">sub</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go-loop</span><span class="tok-p">]])</span>

<span class="tok-c1">;; Source channel and publication</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">publication</span> <span class="tok-p">(</span><span class="tok-nf">pub</span> <span class="tok-nv">in</span> <span class="tok-ss">:action</span><span class="tok-p">))</span>

<span class="tok-c1">;; Sink channels</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">another-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-c1">;; Channel with `:increment` action</span>
<span class="tok-p">(</span><span class="tok-nf">sub</span> <span class="tok-nv">publication</span> <span class="tok-ss">:increment</span> <span class="tok-nv">a-ch</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">a-ch</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Increment:&quot;</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-p">(</span><span class="tok-ss">:value</span> <span class="tok-nv">value</span><span class="tok-p">)))</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">a-ch</span><span class="tok-p">)))))</span>

<span class="tok-c1">;; Channel with `:double` action</span>
<span class="tok-p">(</span><span class="tok-nf">sub</span> <span class="tok-nv">publication</span> <span class="tok-ss">:double</span> <span class="tok-nv">another-ch</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">another-ch</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Double:&quot;</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-mi">2</span> <span class="tok-p">(</span><span class="tok-ss">:value</span> <span class="tok-nv">value</span><span class="tok-p">)))</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">another-ch</span><span class="tok-p">)))))</span>

<span class="tok-c1">;; See how values are delivered to `a-ch` and `another-ch` depending on their action</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-p">{</span><span class="tok-ss">:action</span> <span class="tok-ss">:increment</span> <span class="tok-ss">:value</span> <span class="tok-mi">98</span><span class="tok-p">})</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-p">{</span><span class="tok-ss">:action</span> <span class="tok-ss">:double</span> <span class="tok-ss">:value</span> <span class="tok-mi">21</span><span class="tok-p">})</span>

<span class="tok-c1">;; [:a] Increment: 99</span>
<span class="tok-c1">;; [:b] Double: 42</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mixer"><a class="link" href="#mixer">Mixer</a></h5>
<div class="paragraph">
<p>As we learned in the section about <code>core.async</code> combinators, we can use the <code>merge</code> function for combining
multiple channels into one. When merging multiple channels, every value put in the input channels will end up
in the merged channel. However, we may want more finer-grained control over which values put in the input
channels end up in the output channel, that&#8217;s where mixers come in handy.</p>
</div>
<div class="paragraph">
<p><code>core.async</code> gives us the mixer abstraction, which we can use to combine multiple input channnels into an output
channel. The interesting part of the mixer is that we can mute, pause and listen exclusively to certain input
channels.</p>
</div>
<div class="paragraph">
<p>We can create a mixer given an output channel with <code>mix</code>. Once we have a mixer we can add input channels into the
mix using <code>admix</code>, remove it using <code>unmix</code> or remove every input channel with <code>unmix-all</code>.</p>
</div>
<div class="paragraph">
<p>For controlling the state of the input channel we use the <code>toggle</code> function giving it the mixer and a map from
channels to their states. Note that we can add channels to the mix using <code>toggle</code>, since the map will be merged
with the current state of the mix. The state of a channel is a map which can have the keys <code>:mute</code>, <code>:pause</code> and
<code>:solo</code> mapped to a boolean.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see what muting, pausing and soloing channels means:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A muted input channel means that, while still taking values from it, they won&#8217;t be forwarded to the output channel.
Thus, while a channel is muted, all the values put in it will be discarded.</p>
</li>
<li>
<p>A paused input channel means that no values will be taken from it. This means that values put in the channel won&#8217;t
be forwarded to the output channel nor discarded.</p>
</li>
<li>
<p>When soloing one or more channels the output channel will only receive the values put in soloed channels. By default
non-soloed channels are muted but we can use <code>solo-mode</code> to decide between muting or pausing non-soloed channels.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That was a lot of information so let&#8217;s see an example to improve our understanding. First of all, we&#8217;ll set up a mixer
with an <code>out</code> channel and add three input channels to the mix. After that, we&#8217;ll be printing all the values received
on the <code>out</code> channel to illustrate the control over input channels:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span> <span class="tok-nv">mix</span> <span class="tok-nv">admix</span> <span class="tok-nv">unmix</span> <span class="tok-nv">toggle</span> <span class="tok-nv">solo-mode</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go-loop</span><span class="tok-p">]])</span>

<span class="tok-c1">;; Output channel and mixer</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">out</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">mixer</span> <span class="tok-p">(</span><span class="tok-nf">mix</span> <span class="tok-nv">out</span><span class="tok-p">))</span>

<span class="tok-c1">;; Input channels</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in-1</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in-2</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in-3</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">admix</span> <span class="tok-nv">mixer</span> <span class="tok-nv">in-1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">admix</span> <span class="tok-nv">mixer</span> <span class="tok-nv">in-2</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">admix</span> <span class="tok-nv">mixer</span> <span class="tok-nv">in-3</span><span class="tok-p">)</span>

<span class="tok-c1">;; Let&#39;s listen to the `out` channel and print what we get from it</span>
<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, every value put in the input channels will be put in the <code>out</code> channel:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">do</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-1</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-2</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-3</span> <span class="tok-mi">3</span><span class="tok-p">))</span>

<span class="tok-c1">;; [:a] Got 1</span>
<span class="tok-c1">;; [:a] Got 2</span>
<span class="tok-c1">;; [:a] Got 3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s pause the <code>in-2</code> channel, put a value in every input channel and resume <code>in-2</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">toggle</span> <span class="tok-nv">mixer</span> <span class="tok-p">{</span><span class="tok-nv">in-2</span> <span class="tok-p">{</span><span class="tok-ss">:pause</span> <span class="tok-nv">true</span><span class="tok-p">}})</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">do</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-1</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-2</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-3</span> <span class="tok-mi">3</span><span class="tok-p">))</span>

<span class="tok-c1">;; [:a] Got 1</span>
<span class="tok-c1">;; [:a] Got 3</span>

<span class="tok-p">(</span><span class="tok-nf">toggle</span> <span class="tok-nv">mixer</span> <span class="tok-p">{</span><span class="tok-nv">in-2</span> <span class="tok-p">{</span><span class="tok-ss">:pause</span> <span class="tok-nv">false</span><span class="tok-p">}})</span>

<span class="tok-c1">;; [:a] Got 2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see in the example above, the values put in the paused channels aren&#8217;t discarded.
For discarding values put in an input channel we have to mute it, let&#8217;s see an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">toggle</span> <span class="tok-nv">mixer</span> <span class="tok-p">{</span><span class="tok-nv">in-2</span> <span class="tok-p">{</span><span class="tok-ss">:mute</span> <span class="tok-nv">true</span><span class="tok-p">}})</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">do</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-1</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-2</span> <span class="tok-mi">2</span><span class="tok-p">)</span>  <span class="tok-c1">;; `out` will never get this value since it&#39;s discarded</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-3</span> <span class="tok-mi">3</span><span class="tok-p">))</span>

<span class="tok-c1">;; [:a] Got 1</span>
<span class="tok-c1">;; [:a] Got 3</span>

<span class="tok-p">(</span><span class="tok-nf">toggle</span> <span class="tok-nv">mixer</span> <span class="tok-p">{</span><span class="tok-nv">in-2</span> <span class="tok-p">{</span><span class="tok-ss">:mute</span> <span class="tok-nv">false</span><span class="tok-p">}})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We put a value (<code>2</code>) in the <code>in-2</code> channel and, since the channel was muted at the time, the value
is discarded and never put into <code>out</code>. Let&#8217;s look at the third state a channel can be inside a mixer:
solo.</p>
</div>
<div class="paragraph">
<p>As we mentioned before, soloing channels of a mixer implies muting the rest of them by default:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">toggle</span> <span class="tok-nv">mixer</span> <span class="tok-p">{</span><span class="tok-nv">in-1</span> <span class="tok-p">{</span><span class="tok-ss">:solo</span> <span class="tok-nv">true</span><span class="tok-p">}</span>
               <span class="tok-nv">in-2</span> <span class="tok-p">{</span><span class="tok-ss">:solo</span> <span class="tok-nv">true</span><span class="tok-p">}})</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">do</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-1</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-2</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-3</span> <span class="tok-mi">3</span><span class="tok-p">))</span> <span class="tok-c1">;; `out` will never get this value since it&#39;s discarded</span>

<span class="tok-c1">;; [:a] Got 1</span>
<span class="tok-c1">;; [:a] Got 2</span>

<span class="tok-p">(</span><span class="tok-nf">toggle</span> <span class="tok-nv">mixer</span> <span class="tok-p">{</span><span class="tok-nv">in-1</span> <span class="tok-p">{</span><span class="tok-ss">:solo</span> <span class="tok-nv">false</span><span class="tok-p">}</span>
               <span class="tok-nv">in-2</span> <span class="tok-p">{</span><span class="tok-ss">:solo</span> <span class="tok-nv">false</span><span class="tok-p">}})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, we can set the mode the non-soloed channels will be in while there are soloed channels.
Let&#8217;s set the default non-solo mode to pause instead of the default mute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">solo-mode</span> <span class="tok-nv">mixer</span> <span class="tok-ss">:pause</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">toggle</span> <span class="tok-nv">mixer</span> <span class="tok-p">{</span><span class="tok-nv">in-1</span> <span class="tok-p">{</span><span class="tok-ss">:solo</span> <span class="tok-nv">true</span><span class="tok-p">}</span>
               <span class="tok-nv">in-2</span> <span class="tok-p">{</span><span class="tok-ss">:solo</span> <span class="tok-nv">true</span><span class="tok-p">}})</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">do</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-1</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-2</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-3</span> <span class="tok-mi">3</span><span class="tok-p">))</span>

<span class="tok-c1">;; [:a] Got 1</span>
<span class="tok-c1">;; [:a] Got 2</span>

<span class="tok-p">(</span><span class="tok-nf">toggle</span> <span class="tok-nv">mixer</span> <span class="tok-p">{</span><span class="tok-nv">in-1</span> <span class="tok-p">{</span><span class="tok-ss">:solo</span> <span class="tok-nv">false</span><span class="tok-p">}</span>
               <span class="tok-nv">in-2</span> <span class="tok-p">{</span><span class="tok-ss">:solo</span> <span class="tok-nv">false</span><span class="tok-p">}})</span>

<span class="tok-c1">;; [:a] Got 3</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="appendix-c-setting-up-a-clojurescript-development-environment"><a class="link" href="#appendix-c-setting-up-a-clojurescript-development-environment">6.3. Appendix C: Setting up a ClojureScript development environment</a></h3>
<div class="sect3">
<h4 id="cursive"><a class="link" href="#cursive">6.3.1. Cursive</a></h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="emacs"><a class="link" href="#emacs">6.3.2. Emacs</a></h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="vim"><a class="link" href="#vim">6.3.3. Vim</a></h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="acknowledgments"><a class="link" href="#acknowledgments">7. Acknowledgments</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Special thanks to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>J David Eisenberg</strong>: For the huge amount of time spend in fixing all kind of errors and
writing entire sections of the book, as well as making very valuable suggestions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And here is an inevitably incomplete list of MUCH-APPRECIATED CONTRIBUTORS&#8201;&#8212;&#8201;people who have submitted corrections, new ideas and generally made the
<em>ClojureScript Unraveled</em> book much better:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Anler Hernández Peral (@anler)</p>
</li>
<li>
<p>Diego Sevilla Ruiz (@dsevilla)</p>
</li>
<li>
<p>Eduardo Ferro Aldama (@eferro)</p>
</li>
<li>
<p>Tyler Anderson (@Tyler-Anderson)</p>
</li>
<li>
<p>Chris Ulrich (@chrisulrich)</p>
</li>
<li>
<p>Jean Hadrien Chabran (@jhchabran)</p>
</li>
<li>
<p>Tienson Qin (@tiensonqin)</p>
</li>
<li>
<p>FungusHumungus (@FungusHumungus),</p>
</li>
<li>
<p>Chris Charles (@ccharles)</p>
</li>
<li>
<p>Jearvon Dharrie (@iamjarvo)</p>
</li>
<li>
<p>Shaun LeBron (@shaunlebron)</p>
</li>
<li>
<p>Wodin (@wodin)</p>
</li>
<li>
<p>Crocket (@crocket)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="further-reading"><a class="link" href="#further-reading">8. Further Reading</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Here is a list of more resources about ClojureScript.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/clojure/clojurescript/wiki">ClojureScript wiki</a>: a community-mantained wiki about ClojureScript.</p>
</li>
<li>
<p><a href="https://github.com/cljsinfo/cljs-api-docs/blob/catalog/INDEX.md">API Reference</a>: a community-maintained complete language api reference.</p>
</li>
<li>
<p><a href="http://cljs.info/cheatsheet/">ClojureScript Cheatsheet</a>: a comprehensive reference of the ClojureScript language.</p>
</li>
<li>
<p><a href="http://catcode.com/etudes-for-clojurescript/toc01.html">Études for ClojureScript</a>: a collection of exercises for learning ClojureScript.</p>
</li>
<li>
<p><a href="http://clojurescriptmadeeasy.com/">ClojureScript made easy</a>: a collection of short articles about solving common problems in ClojureScript.</p>
</li>
<li>
<p><a href="http://google.github.io/closure-library/api/">The Google Closure Library API reference</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 5<br/>
Last updated 2016-01-06 21:07:22 EET
</div>
</div>
</body>
</html>