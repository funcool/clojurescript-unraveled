<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta charset="UTF-8"/>
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"/><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="generator" content="Asciidoctor 1.5.2"/>
<meta name="author" content="Andrey Antukh, Alejandro Gomez"/>
<title>ClojureScript Unraveled</title>
<style>
/*! normalize.css v2.1.2 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video { display: inline-block; }

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) { display: none; height: 0; }

/** Address `[hidden]` styling not present in IE 8/9. Hide the `template` element in IE, Safari, and Firefox < 22. */
[hidden], template { display: none; }

script { display: none !important; }

/* ========================================================================== Base ========================================================================== */
/** 1. Set default font family to sans-serif. 2. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html { font-family: sans-serif; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ }

/** Remove default margin. */
body { margin: 0; }

/* ========================================================================== Links ========================================================================== */
/** Remove the gray background color from active links in IE 10. */
a { background: transparent; }

/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus { outline: thin dotted; }

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover { outline: 0; }

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 { font-size: 2em; margin: 0.67em 0; }

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] { border-bottom: 1px dotted; }

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong { font-weight: bold; }

/** Address styling not present in Safari 5 and Chrome. */
dfn { font-style: italic; }

/** Address differences between Firefox and other browsers. */
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }

/** Address styling not present in IE 8/9. */
mark { background: #ff0; color: #000; }

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }

/** Improve readability of pre-formatted text in all browsers. */
pre { white-space: pre-wrap; }

/** Set consistent quote types. */
q { quotes: "\201C" "\201D" "\2018" "\2019"; }

/** Address inconsistent and variable font size in all browsers. */
small { font-size: 80%; }

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }

sup { top: -0.5em; }

sub { bottom: -0.25em; }

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img { border: 0; }

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) { overflow: hidden; }

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure { margin: 0; }

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend { border: 0; /* 1 */ padding: 0; /* 2 */ }

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 2 */ margin: 0; /* 3 */ }

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input { line-height: normal; }

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select { text-transform: none; }

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; /* 2 */ cursor: pointer; /* 3 */ }

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] { cursor: default; }

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ }

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] { -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box; }

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea { overflow: auto; /* 1 */ vertical-align: top; /* 2 */ }

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table { border-collapse: collapse; border-spacing: 0; }

meta.foundation-mq-small { font-family: "only screen and (min-width: 768px)"; width: 768px; }

meta.foundation-mq-medium { font-family: "only screen and (min-width:1280px)"; width: 1280px; }

meta.foundation-mq-large { font-family: "only screen and (min-width:1440px)"; width: 1440px; }

*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }

html, body { font-size: 100%; }

body { background: white;
       color: rgba(0, 0, 0, 0.8);
       padding: 0;
       margin: 0;
       font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica,Arial,sans-serif;
       font-weight: normal;
       font-style: normal;
       line-height: 1;
       position: relative;
       cursor: auto; }

a:hover { cursor: pointer; }

img, object, embed { max-width: 100%; height: auto; }

object, embed { height: 100%; }

img { -ms-interpolation-mode: bicubic; }

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }

.left { float: left !important; }

.right { float: right !important; }

.text-left { text-align: left !important; }

.text-right { text-align: right !important; }

.text-center { text-align: center !important; }

.text-justify { text-align: justify !important; }

.hide { display: none; }

.antialiased, body { -webkit-font-smoothing: antialiased; }

img { display: inline-block; vertical-align: middle; }

textarea { height: auto; min-height: 50px; }

select { width: 100%; }

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }

.subheader, .admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { line-height: 1.45; color: #7a2518; font-weight: normal; margin-top: 0; margin-bottom: 0.25em; }

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }

/* Default Link Styles */
a { color: #2156a5; text-decoration: none; line-height: inherit; }
a:hover, a:focus { color: #1d4b8f; }
a img { border: none; }

/* Default paragraph styles */
p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 {
    font-weight: 300;
    font-style: normal;

    font-family: "Roboto Slab", "ff-tisa-web-pro","Georgia",Arial,sans-serif;
    color: #3E4349;

    text-rendering: optimizeLegibility;
    margin-top: 1em;
    margin-bottom: 0.5em;
    line-height: 1.0125em;
}
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small {
    font-size: 60%;
    color: #527bbd;
    line-height: 0;
}

h1 { font-size: 2.125em; }

h2 { font-size: 1.6875em; }

h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }

h4 { font-size: 1.125em; }

h5 { font-size: 1.125em; }

h6 { font-size: 1em; }

hr { border: solid #ddddd8; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }

/* Helpful Typography Defaults */
em, i { font-style: italic; line-height: inherit; }

strong, b { font-weight: bold; line-height: inherit; }

small { font-size: 60%; line-height: inherit; }

code {
    font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace;
    font-family: "Liberation Mono",Menlo,Courier,monospace;
    font-weight: normal; color: rgba(0, 0, 0, 0.9);
}

/* Lists */
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }

ul, ol { margin-left: 1.5em; }
ul.no-bullet, ol.no-bullet { margin-left: 1.5em; }

/* Unordered Lists */
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; /* Override nested font-size change */ }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }

/* Ordered Lists */
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }

/* Definition Lists */
dl dt { margin-bottom: 0.3125em; font-weight: bold; }
dl dd { margin-bottom: 1.25em; }

/* Abbreviations */
abbr, acronym { text-transform: uppercase; font-size: 90%; color: rgba(0, 0, 0, 0.8); border-bottom: 1px dotted #dddddd; cursor: help; }

abbr { text-transform: none; }

/* Blockquotes */
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: 0.9375em; color: rgba(0, 0, 0, 0.6); }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: rgba(0, 0, 0, 0.6); }

blockquote, blockquote p { line-height: 1.6; color: rgba(0, 0, 0, 0.85); }

/* Microformats */
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }

.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }

@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.2; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
/* Tables */
table { background: white; margin-bottom: 1.25em; border: solid 1px #dedede; }
table thead, table tfoot { background: #f7f8f7; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: rgba(0, 0, 0, 0.8); text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: rgba(0, 0, 0, 0.8); }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f8f8f7; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.6; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.2; word-spacing: -0.05em; }
h1 strong, h2 strong, h3 strong, #toctitle strong, .sidebarblock > .content > .title strong, h4 strong, h5 strong, h6 strong { font-weight: 400; }

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }

*:not(pre) > code { font-size: 0.9375em; font-style: normal !important; letter-spacing: 0; padding: 0.1em 0.5ex; word-spacing: -0.15em; background-color: #f7f7f8; -webkit-border-radius: 4px; border-radius: 4px; line-height: 1.45; text-rendering: optimizeSpeed; }

pre, pre > code {
    line-height: 1.45;
    color: rgba(0, 0, 0, 0.9);
    font-family: "Droid Sans Mono", "DejaVu Sans Mono", "Monospace", monospace;
    font-family: "Liberation Mono",Menlo,Courier,monospace;
    font-weight: normal;
    text-rendering: optimizeSpeed; }

.keyseq { color: rgba(51, 51, 51, 0.8); }

kbd { display: inline-block; color: rgba(0, 0, 0, 0.8); font-size: 0.75em; line-height: 1.4; background-color: #f7f7f7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; margin: -0.15em 0.15em 0 0.15em; padding: 0.2em 0.6em 0.2em 0.5em; vertical-align: middle; white-space: nowrap; }

.keyseq kbd:first-child { margin-left: 0; }

.keyseq kbd:last-child { margin-right: 0; }

.menuseq, .menu { color: rgba(0, 0, 0, 0.8); }

b.button:before, b.button:after { position: relative; top: -1px; font-weight: normal; }

b.button:before { content: "["; padding: 0 3px 0 2px; }

b.button:after { content: "]"; padding: 0 2px 0 3px; }

p a > code:hover { color: rgba(0, 0, 0, 0.9); }

#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }

#content { margin-top: 1.25em; }

#content:before { content: none; }

#header > h1:first-child { color: rgba(0, 0, 0, 0.85); margin-top: 2.25rem; margin-bottom: 0; }
#header > h1:first-child + #toc { margin-top: 8px; border-top: 1px solid #ddddd8; }
#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) { border-bottom: 1px solid #ddddd8; padding-bottom: 8px; }
#header .details { border-bottom: 1px solid #ddddd8; line-height: 1.45; padding-top: 0.25em; padding-bottom: 0.25em; padding-left: 0.25em; color: rgba(0, 0, 0, 0.6); display: -ms-flexbox; display: -webkit-flex; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; }
#header .details span:first-child { margin-left: -0.125em; }
#header .details span.email a { color: rgba(0, 0, 0, 0.85); }
#header .details br { display: none; }
#header .details br + span:before { content: "\00a0\2013\00a0"; }
#header .details br + span.author:before { content: "\00a0\22c5\00a0"; color: rgba(0, 0, 0, 0.85); }
#header .details br + span#revremark:before { content: "\00a0|\00a0"; }
#header #revnumber { text-transform: capitalize; }
#header #revnumber:after { content: "\00a0"; }

#content > h1:first-child:not([class]) { color: rgba(0, 0, 0, 0.85); border-bottom: 1px solid #ddddd8; padding-bottom: 8px; margin-top: 0; padding-top: 1rem; margin-bottom: 1.25rem; }

#toc { border-bottom: 1px solid #efefed; padding-bottom: 0.5em; }
#toc > ul { margin-left: 0.125em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin: 0.5em 0; }
#toc ul { font-family: "Open Sans", "DejaVu Sans", sans-serif; list-style-type: none; }
#toc a { text-decoration: none;
         color: #3E4349;
       }
#toc a:active { text-decoration: underline; }

#toctitle { font-size: 1.2em; font-weight: 700; }

@media only screen and (min-width: 768px) { #toctitle { font-size: 1.375em; }
  body.toc2 { padding-left: 15em; padding-right: 0; }
  #toc.toc2 { margin-top: 0 !important; background-color: #f8f8f7; position: fixed; width: 15em; left: 0; top: 0; border-right: 1px solid #efefed; border-top-width: 0 !important; border-bottom-width: 0 !important; z-index: 1000; padding: 1.25em 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; font-size: 1.2em; }
  #toc.toc2 > ul { font-size: 0.9em; margin-bottom: 0; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 15em; }
  body.toc2.toc-right #toc.toc2 { border-right-width: 0; border-left: 1px solid #efefed; left: auto; right: 0; } }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 25em; padding-right: 0; }
  #toc.toc2 { width: 25em; font-size: 16px; }
  #toc.toc2 #toctitle { font-size: 1.375em; }
  #toc.toc2 > ul { font-size: 0.95em; }
  #toc.toc2 ul ul { padding-left: 1.25em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #e0e0dc; margin-bottom: 1.25em; padding: 1.25em; background: #f8f8f7; -webkit-border-radius: 4px; border-radius: 4px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }

#footer { max-width: 100%; background-color: rgba(0, 0, 0, 0.8); padding: 1.25em; }

#footer-text { color: rgba(255, 255, 255, 0.8); line-height: 1.44; }

.sect1 { padding-bottom: 0.625em; }

@media only screen and (min-width: 768px) { .sect1 { padding-bottom: 1.25em; } }
.sect1 + .sect1 { border-top: 1px solid #efefed; }

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; z-index: 1001; width: 1.5ex; margin-left: -1.5ex; display: block; text-decoration: none !important; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: "\00A7"; font-size: 0.85em; display: block; padding-top: 0.1em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }

#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link {
    text-decoration: none;
    color: #3E4349;
    font-weight: 700;
}

#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #3E4349; }

.audioblock, .imageblock, .literalblock, .listingblock, .stemblock, .videoblock { margin-bottom: 1.25em; }

.admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-rendering: optimizeLegibility; text-align: left; font-family: "Noto Serif", "DejaVu Serif", serif; font-size: 1rem; font-style: italic; }

table.tableblock > caption.title { white-space: nowrap; overflow: visible; max-width: 0; }

.paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { color: rgba(0, 0, 0, 0.85); }

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }

.admonitionblock > table { border-collapse: separate; border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; font-family: "Open Sans", "DejaVu Sans", sans-serif; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #ddddd8; color: rgba(0, 0, 0, 0.6); }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }

.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 4px; border-radius: 4px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }

.sidebarblock { border-style: solid; border-width: 1px; border-color: #e0e0dc; margin-bottom: 1.25em; padding: 1.25em; background: #f8f8f7; -webkit-border-radius: 4px; border-radius: 4px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock > .content > .title { color: #7a2518; margin-top: 0; text-align: center; }

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }

.literalblock pre, .listingblock pre:not(.highlight), .listingblock pre[class="highlight"], .listingblock pre[class^="highlight "], .listingblock pre.CodeRay, .listingblock pre.prettyprint { background: #f7f7f8; }
.sidebarblock .literalblock pre, .sidebarblock .listingblock pre:not(.highlight), .sidebarblock .listingblock pre[class="highlight"], .sidebarblock .listingblock pre[class^="highlight "], .sidebarblock .listingblock pre.CodeRay, .sidebarblock .listingblock pre.prettyprint { background: #f2f1f1; }

.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { -webkit-border-radius: 4px; border-radius: 4px; word-wrap: break-word; padding: 1em; font-size: 0.8125em; }
.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
@media only screen and (min-width: 768px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.90625em; } }
@media only screen and (min-width: 1280px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 1em; } }

.literalblock.output pre { color: #f7f7f8; background-color: rgba(0, 0, 0, 0.9); }

.listingblock pre.highlightjs { padding: 0; }
.listingblock pre.highlightjs > code { padding: 1em; -webkit-border-radius: 4px; border-radius: 4px; }

.listingblock pre.prettyprint { border-width: 0; }

.listingblock > .content { position: relative; }

.listingblock code[data-lang]:before { display: none; content: attr(data-lang); position: absolute; font-size: 0.75em; top: 0.425rem; right: 0.5rem; line-height: 1; text-transform: uppercase; color: #999; }

.listingblock:hover code[data-lang]:before { display: block; }

.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }

.listingblock.terminal pre .command:not([data-prompt]):before { content: "$"; }

table.pyhltable { border-collapse: separate; border: 0; margin-bottom: 0; background: none; }

table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; }

table.pyhltable td.code { padding-left: .75em; padding-right: 0; }

pre.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #ddddd8; }

pre.pygments .lineno { display: inline-block; margin-right: .25em; }

table.pyhltable .linenodiv { background: none !important; padding-right: 0 !important; }

.quoteblock { margin: 0 1em 1.25em 1.5em; display: table; }
.quoteblock > .title { margin-left: -1.5em; margin-bottom: 0.75em; }
.quoteblock blockquote, .quoteblock blockquote p { color: rgba(0, 0, 0, 0.85); font-size: 1.15rem; line-height: 1.75; word-spacing: 0.1em; letter-spacing: 0; font-style: italic; text-align: justify; }
.quoteblock blockquote { margin: 0; padding: 0; border: 0; }
.quoteblock blockquote:before { content: "\201c"; float: left; font-size: 2.75em; font-weight: bold; line-height: 0.6em; margin-left: -0.6em; color: #7a2518; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: 0.5em; margin-right: 0.5ex; text-align: right; }
.quoteblock .quoteblock { margin-left: 0; margin-right: 0; padding: 0.5em 0; border-left: 3px solid rgba(0, 0, 0, 0.6); }
.quoteblock .quoteblock blockquote { padding: 0 0 0 0.75em; }
.quoteblock .quoteblock blockquote:before { display: none; }

.verseblock { margin: 0 1em 1.25em 1em; }
.verseblock pre { font-family: "Open Sans", "DejaVu Sans", sans; font-size: 1.15rem; color: rgba(0, 0, 0, 0.85); font-weight: 300; text-rendering: optimizeLegibility; }
.verseblock pre strong { font-weight: 400; }
.verseblock .attribution { margin-top: 1.25rem; margin-left: 0.5ex; }

.quoteblock .attribution, .verseblock .attribution { font-size: 0.9375em; line-height: 1.45; font-style: italic; }
.quoteblock .attribution br, .verseblock .attribution br { display: none; }
.quoteblock .attribution cite, .verseblock .attribution cite { display: block; letter-spacing: -0.05em; color: rgba(0, 0, 0, 0.6); }

.quoteblock.abstract { margin: 0 0 1.25em 0; display: block; }
.quoteblock.abstract blockquote, .quoteblock.abstract blockquote p { text-align: left; word-spacing: 0; }
.quoteblock.abstract blockquote:before, .quoteblock.abstract blockquote p:first-of-type:before { display: none; }

table.tableblock { max-width: 100%; border-collapse: separate; }
table.tableblock td > .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child { margin-bottom: 0; }

table.spread { width: 100%; }

table.tableblock, th.tableblock, td.tableblock { border: 0 solid #dedede; }

table.grid-all th.tableblock, table.grid-all td.tableblock { border-width: 0 1px 1px 0; }

table.grid-all tfoot > tr > th.tableblock, table.grid-all tfoot > tr > td.tableblock { border-width: 1px 1px 0 0; }

table.grid-cols th.tableblock, table.grid-cols td.tableblock { border-width: 0 1px 0 0; }

table.grid-all * > tr > .tableblock:last-child, table.grid-cols * > tr > .tableblock:last-child { border-right-width: 0; }

table.grid-rows th.tableblock, table.grid-rows td.tableblock { border-width: 0 0 1px 0; }

table.grid-all tbody > tr:last-child > th.tableblock, table.grid-all tbody > tr:last-child > td.tableblock, table.grid-all thead:last-child > tr > th.tableblock, table.grid-rows tbody > tr:last-child > th.tableblock, table.grid-rows tbody > tr:last-child > td.tableblock, table.grid-rows thead:last-child > tr > th.tableblock { border-bottom-width: 0; }

table.grid-rows tfoot > tr > th.tableblock, table.grid-rows tfoot > tr > td.tableblock { border-width: 1px 0 0 0; }

table.frame-all { border-width: 1px; }

table.frame-sides { border-width: 0 1px; }

table.frame-topbot { border-width: 1px 0; }

th.halign-left, td.halign-left { text-align: left; }

th.halign-right, td.halign-right { text-align: right; }

th.halign-center, td.halign-center { text-align: center; }

th.valign-top, td.valign-top { vertical-align: top; }

th.valign-bottom, td.valign-bottom { vertical-align: bottom; }

th.valign-middle, td.valign-middle { vertical-align: middle; }

table thead th, table tfoot th { font-weight: bold; }

tbody tr th { display: table-cell; line-height: 1.6; background: #f7f8f7; }

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: rgba(0, 0, 0, 0.8); font-weight: bold; }

p.tableblock > code:only-child { background: none; padding: 0; }

p.tableblock { font-size: 1em; }

td > div.verse { white-space: pre; }

ol { margin-left: 1.75em; }

ul li ol { margin-left: 1.5em; }

dl dd { margin-left: 1.125em; }

dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }

ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }

ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }

ul.checklist li > p:first-child > .fa-square-o:first-child, ul.checklist li > p:first-child > .fa-check-square-o:first-child { width: 1em; font-size: 0.85em; }

ul.checklist li > p:first-child > input[type="checkbox"]:first-child { width: 1em; position: relative; top: 1px; }

ul.inline { margin: 0 auto 0.625em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }

.unstyled dl dt { font-weight: normal; font-style: normal; }

ol.arabic { list-style-type: decimal; }

ol.decimal { list-style-type: decimal-leading-zero; }

ol.loweralpha { list-style-type: lower-alpha; }

ol.upperalpha { list-style-type: upper-alpha; }

ol.lowerroman { list-style-type: lower-roman; }

ol.upperroman { list-style-type: upper-roman; }

ol.lowergreek { list-style-type: lower-greek; }

.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }

td.hdlist1 { padding-right: .75em; font-weight: bold; }

td.hdlist1, td.hdlist2 { vertical-align: top; }

.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }

.colist > table tr > td:first-of-type { padding: 0 0.75em; line-height: 1; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }

.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }

.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }

.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }

a.image { text-decoration: none; }

span.footnote, span.footnoteref { vertical-align: super; font-size: 0.875em; }
span.footnote a, span.footnoteref a { text-decoration: none; }
span.footnote a:active, span.footnoteref a:active { text-decoration: underline; }

#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -.25em 0 .75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em; line-height: 1.3; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.2em; margin-bottom: .2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }

#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }

.gist .file-data > table { border: 0; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }

div.unbreakable { page-break-inside: avoid; }

.big { font-size: larger; }

.small { font-size: smaller; }

.underline { text-decoration: underline; }

.overline { text-decoration: overline; }

.line-through { text-decoration: line-through; }

.aqua { color: #00bfbf; }

.aqua-background { background-color: #00fafa; }

.black { color: black; }

.black-background { background-color: black; }

.blue { color: #0000bf; }

.blue-background { background-color: #0000fa; }

.fuchsia { color: #bf00bf; }

.fuchsia-background { background-color: #fa00fa; }

.gray { color: #606060; }

.gray-background { background-color: #7d7d7d; }

.green { color: #006000; }

.green-background { background-color: #007d00; }

.lime { color: #00bf00; }

.lime-background { background-color: #00fa00; }

.maroon { color: #600000; }

.maroon-background { background-color: #7d0000; }

.navy { color: #000060; }

.navy-background { background-color: #00007d; }

.olive { color: #606000; }

.olive-background { background-color: #7d7d00; }

.purple { color: #600060; }

.purple-background { background-color: #7d007d; }

.red { color: #bf0000; }

.red-background { background-color: #fa0000; }

.silver { color: #909090; }

.silver-background { background-color: #bcbcbc; }

.teal { color: #006060; }

.teal-background { background-color: #007d7d; }

.white { color: #bfbfbf; }

.white-background { background-color: #fafafa; }

.yellow { color: #bfbf00; }

.yellow-background { background-color: #fafa00; }

span.icon > .fa { cursor: default; }

.admonitionblock td.icon [class^="fa icon-"] { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #19407c; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }

.conum[data-value] { display: inline-block; color: #fff !important; background-color: rgba(0, 0, 0, 0.8); -webkit-border-radius: 100px; border-radius: 100px; text-align: center; font-size: 0.75em; width: 1.67em; height: 1.67em; line-height: 1.67em; font-family: "Open Sans", "DejaVu Sans", sans-serif; font-style: normal; font-weight: bold; }
.conum[data-value] * { color: #fff !important; }
.conum[data-value] + b { display: none; }
.conum[data-value]:after { content: attr(data-value); }
pre .conum[data-value] { position: relative; top: -0.125em; }

b.conum * { color: inherit !important; }

.conum:not([data-value]):empty { display: none; }

h1, h2 { letter-spacing: -0.01em; }

dt, th.tableblock, td.content { text-rendering: optimizeLegibility; }

p, td.content { letter-spacing: -0.01em; }
p strong, td.content strong { letter-spacing: -0.005em; }

p, blockquote, dt, td.content { font-size: 1.0625rem; }

p { margin-bottom: 1.25rem; }

.sidebarblock p, .sidebarblock dt, .sidebarblock td.content, p.tableblock { font-size: 1em; }

.exampleblock > .content { background-color: #fffef7; border-color: #e0e0dc; -webkit-box-shadow: 0 1px 4px #e0e0dc; box-shadow: 0 1px 4px #e0e0dc; }

.print-only { display: none !important; }

@media print { @page { margin: 1.25cm 0.75cm; }
  * { -webkit-box-shadow: none !important; box-shadow: none !important; text-shadow: none !important; }
  a { color: inherit !important; text-decoration: underline !important; }
  a.bare, a[href^="#"], a[href^="mailto:"] { text-decoration: none !important; }
  a[href^="http:"]:not(.bare):after, a[href^="https:"]:not(.bare):after { content: "(" attr(href) ")"; display: inline-block; font-size: 0.875em; padding-left: 0.25em; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  pre, blockquote, tr, img { page-break-inside: avoid; }
  thead { display: table-header-group; }
  img { max-width: 100% !important; }
  p, blockquote, dt, td.content { font-size: 1em; orphans: 3; widows: 3; }
  h2, h3, #toctitle, .sidebarblock > .content > .title, #toctitle, .sidebarblock > .content > .title { page-break-after: avoid; }
  #toc, .sidebarblock, .exampleblock > .content { background: none !important; }
  #toc { border-bottom: 1px solid #ddddd8 !important; padding-bottom: 0 !important; }
  .sect1 { padding-bottom: 0 !important; }
  .sect1 + .sect1 { border: 0 !important; }
  #header > h1:first-child { margin-top: 1.25rem; }
  body.book #header { text-align: center; }
  body.book #header > h1:first-child { border: 0 !important; margin: 2.5em 0 1em 0; }
  body.book #header .details { border: 0 !important; display: block; padding: 0 !important; }
  body.book #header .details span:first-child { margin-left: 0 !important; }
  body.book #header .details br { display: block; }
  body.book #header .details br + span:before { content: none !important; }
  body.book #toc { border: 0 !important; text-align: left !important; padding: 0 !important; margin: 0 !important; }
  body.book #toc, body.book #preamble, body.book h1.sect0, body.book .sect1 > h2 { page-break-before: always; }
  .listingblock code[data-lang]:before { display: block; }
  #footer { background: none !important; padding: 0 0.9375em; }
  #footer-text { color: rgba(0, 0, 0, 0.6) !important; font-size: 0.9em; }
  .hide-on-print { display: none !important; }
  .print-only { display: block !important; }
  .hide-for-print { display: none !important; }
  .show-for-print { display: inherit !important; } }

</style>
<style>
.listingblock .pygments .hll { background-color: #ffffcc }
.listingblock .pygments  { background: #f0f0f0; }
.listingblock .pygments .tok-c { color: #60a0b0; font-style: italic } /* Comment */
.listingblock .pygments .tok-err { border: 1px solid #FF0000 } /* Error */
.listingblock .pygments .tok-k { color: #007020; font-weight: bold } /* Keyword */
.listingblock .pygments .tok-o { color: #666666 } /* Operator */
.listingblock .pygments .tok-cm { color: #60a0b0; font-style: italic } /* Comment.Multiline */
.listingblock .pygments .tok-cp { color: #007020 } /* Comment.Preproc */
.listingblock .pygments .tok-c1 { color: #60a0b0; font-style: italic } /* Comment.Single */
.listingblock .pygments .tok-cs { color: #60a0b0; background-color: #fff0f0 } /* Comment.Special */
.listingblock .pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
.listingblock .pygments .tok-ge { font-style: italic } /* Generic.Emph */
.listingblock .pygments .tok-gr { color: #FF0000 } /* Generic.Error */
.listingblock .pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
.listingblock .pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
.listingblock .pygments .tok-go { color: #888888 } /* Generic.Output */
.listingblock .pygments .tok-gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.listingblock .pygments .tok-gs { font-weight: bold } /* Generic.Strong */
.listingblock .pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.listingblock .pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
.listingblock .pygments .tok-kc { color: #007020; font-weight: bold } /* Keyword.Constant */
.listingblock .pygments .tok-kd { color: #007020; font-weight: bold } /* Keyword.Declaration */
.listingblock .pygments .tok-kn { color: #007020; font-weight: bold } /* Keyword.Namespace */
.listingblock .pygments .tok-kp { color: #007020 } /* Keyword.Pseudo */
.listingblock .pygments .tok-kr { color: #007020; font-weight: bold } /* Keyword.Reserved */
.listingblock .pygments .tok-kt { color: #902000 } /* Keyword.Type */
.listingblock .pygments .tok-m { color: #40a070 } /* Literal.Number */
.listingblock .pygments .tok-s { color: #4070a0 } /* Literal.String */
.listingblock .pygments .tok-na { color: #4070a0 } /* Name.Attribute */
.listingblock .pygments .tok-nb { color: #007020 } /* Name.Builtin */
.listingblock .pygments .tok-nc { color: #0e84b5; font-weight: bold } /* Name.Class */
.listingblock .pygments .tok-no { color: #60add5 } /* Name.Constant */
.listingblock .pygments .tok-nd { color: #555555; font-weight: bold } /* Name.Decorator */
.listingblock .pygments .tok-ni { color: #d55537; font-weight: bold } /* Name.Entity */
.listingblock .pygments .tok-ne { color: #007020 } /* Name.Exception */
.listingblock .pygments .tok-nf { color: #06287e } /* Name.Function */
.listingblock .pygments .tok-nl { color: #002070; font-weight: bold } /* Name.Label */
.listingblock .pygments .tok-nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.listingblock .pygments .tok-nt { color: #062873; font-weight: bold } /* Name.Tag */
.listingblock .pygments .tok-nv { color: #bb60d5 } /* Name.Variable */
.listingblock .pygments .tok-ow { color: #007020; font-weight: bold } /* Operator.Word */
.listingblock .pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
.listingblock .pygments .tok-mb { color: #40a070 } /* Literal.Number.Bin */
.listingblock .pygments .tok-mf { color: #40a070 } /* Literal.Number.Float */
.listingblock .pygments .tok-mh { color: #40a070 } /* Literal.Number.Hex */
.listingblock .pygments .tok-mi { color: #40a070 } /* Literal.Number.Integer */
.listingblock .pygments .tok-mo { color: #40a070 } /* Literal.Number.Oct */
.listingblock .pygments .tok-sb { color: #4070a0 } /* Literal.String.Backtick */
.listingblock .pygments .tok-sc { color: #4070a0 } /* Literal.String.Char */
.listingblock .pygments .tok-sd { color: #4070a0; font-style: italic } /* Literal.String.Doc */
.listingblock .pygments .tok-s2 { color: #4070a0 } /* Literal.String.Double */
.listingblock .pygments .tok-se { color: #4070a0; font-weight: bold } /* Literal.String.Escape */
.listingblock .pygments .tok-sh { color: #4070a0 } /* Literal.String.Heredoc */
.listingblock .pygments .tok-si { color: #70a0d0; font-style: italic } /* Literal.String.Interpol */
.listingblock .pygments .tok-sx { color: #c65d09 } /* Literal.String.Other */
.listingblock .pygments .tok-sr { color: #235388 } /* Literal.String.Regex */
.listingblock .pygments .tok-s1 { color: #4070a0 } /* Literal.String.Single */
.listingblock .pygments .tok-ss { color: #517918 } /* Literal.String.Symbol */
.listingblock .pygments .tok-bp { color: #007020 } /* Name.Builtin.Pseudo */
.listingblock .pygments .tok-vc { color: #bb60d5 } /* Name.Variable.Class */
.listingblock .pygments .tok-vg { color: #bb60d5 } /* Name.Variable.Global */
.listingblock .pygments .tok-vi { color: #bb60d5 } /* Name.Variable.Instance */
.listingblock .pygments .tok-il { color: #40a070 } /* Literal.Number.Integer.Long */
</style>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic|Liberation+Mono:400|Roboto+Slab:400,700"/>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>ClojureScript Unraveled</h1>
<div class="details">
<span id="author" class="author">Andrey Antukh</span><br/>
<span id="email" class="email"><a href="mailto:niwi@niwi.be">niwi@niwi.be</a></span><br/>
<span id="author2" class="author">Alejandro Gomez</span><br/>
<span id="email2" class="email"><a href="mailto:alejandro@dialelo.com">alejandro@dialelo.com</a></span><br/>
<span id="revnumber">version 1,</span>
<span id="revdate">2015-06-02</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#about-this-book">1. About this book</a></li>
<li><a href="#introduction">2. Introduction</a>
<ul class="sectlevel2">
<li><a href="#first-contact">2.1. First contact</a></li>
<li><a href="#the-pillars-of-the-language">2.2. The pillars of the language</a></li>
<li><a href="#why-host-on-javascript">2.3. Why host on JavaScript?</a></li>
</ul>
</li>
<li><a href="#the-language">3. The language.</a>
<ul class="sectlevel2">
<li><a href="#first-steps-with-lisp-syntax">3.1. First steps with Lisp syntax</a></li>
<li><a href="#the-base-data-types">3.2. The base data types</a>
<ul class="sectlevel3">
<li><a href="#numbers">3.2.1. Numbers</a></li>
<li><a href="#keywords">3.2.2. Keywords</a></li>
<li><a href="#symbols">3.2.3. Symbols</a></li>
<li><a href="#strings">3.2.4. Strings</a></li>
<li><a href="#characters">3.2.5. Characters</a></li>
<li><a href="#collections">3.2.6. Collections</a></li>
</ul>
</li>
<li><a href="#vars">3.3. Vars</a></li>
<li><a href="#function-section">3.4. Functions</a>
<ul class="sectlevel3">
<li><a href="#the-first-contact">3.4.1. The first contact</a></li>
<li><a href="#defining-your-own-functions">3.4.2. Defining your own functions</a></li>
<li><a href="#function-with-multiple-arities">3.4.3. Function with multiple arities</a></li>
<li><a href="#variadic-functions">3.4.4. Variadic functions</a></li>
<li><a href="#short-syntax-for-anonymous-functions">3.4.5. Short syntax for anonymous functions</a></li>
</ul>
</li>
<li><a href="#flow-control">3.5. Flow control</a>
<ul class="sectlevel3">
<li><a href="#branching-with-code-if-code">3.5.1. Branching with <code>if</code></a></li>
<li><a href="#branching-with-code-cond-code">3.5.2. Branching with <code>cond</code></a></li>
<li><a href="#branching-with-code-case-code">3.5.3. Branching with <code>case</code></a></li>
</ul>
</li>
<li><a href="#locals-blocks-and-loops">3.6. Locals, Blocks and Loops</a>
<ul class="sectlevel3">
<li><a href="#locals">3.6.1. Locals</a></li>
<li><a href="#loops">3.6.2. Loops</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="about-this-book"><a class="link" href="#about-this-book">1. About this book</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This book covers the ClojureScript programming language, a detailed guide of its tooling for
development and a series of articles about topics that are applicable in day-to-day programming
in ClojureScript.</p>
</div>
<div class="paragraph">
<p>It is not an introductory book to programming in that it assumes the reader has experience programming in at least
one language. However, it doesn&#8217;t assume experience with ClojureScript or functional programming. We&#8217;ll try to
include links to reference material when talking about the theoretical programming language aspects of ClojureScript
that may be not be familiar to everybody.</p>
</div>
<div class="paragraph">
<p>Also, since the ClojureScript documentation is good but disperse, we wanted to write a compendium of reference
information and extensive examples to serve as a ClojureScript primer as well as a series of practical how-to&#8217;s.
This document will evolve with the ClojureScript language, both as a reference of the language features and a
sort of cookbook with practical programming recipes.</p>
</div>
<div class="paragraph">
<p>You&#8217;ll get the most ouf this book if you:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>are curious about ClojureScript or functional programming and you have some programming experience;</p>
</li>
<li>
<p>write JavaScript or any other language that compiles to it and want to know what ClojureScript has to offer;</p>
</li>
<li>
<p>you already know some Clojure and want to learn how ClojureScript differs from it, plus practical topics like
how to target both languages with the same code base.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Don&#8217;t be turned off if you don&#8217;t see yourself in neither of the above groups, we encourage you to give this book
a try and give us feedback on how we can make it more accesible. Our goal is to make ClojureScript more friendly
to newcomers and spread the ideas about programming that Clojure has helped popularize, as we see a lot of
value in them.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction"><a class="link" href="#introduction">2. Introduction</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter is an introduction to the Clojure ecosystem, and intends to explain
the philosophy behind it.</p>
</div>
<div class="sect2">
<h3 id="first-contact"><a class="link" href="#first-contact">2.1. First contact</a></h3>
<div class="paragraph">
<p><em>ClojureScript</em> is an implementation of the Clojure programming language that
targets JavaScript. Because of this it can run in many different execution
environments including web browsers, Node.js, io.js, and Nashhorn.</p>
</div>
<div class="paragraph">
<p>Unlike other languages that intend to <em>compile</em> to JavaScript (like TypeScript,
FunScript or CoffeeScript), ClojureScript is designed to use JavaScript like bytecode. It embraces
functional programming, and has very safe and consistent defaults.</p>
</div>
<div class="paragraph">
<p>Another big difference (and in my opinion a big advantage) over other languages is that Clojure
is designed to be a guest. It is a language without its own virtual machine that
can be easy adapted to differences between its execution environments.</p>
</div>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="the-pillars-of-the-language"><a class="link" href="#the-pillars-of-the-language">2.2. The pillars of the language</a></h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="why-host-on-javascript"><a class="link" href="#why-host-on-javascript">2.3. Why host on JavaScript?</a></h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-language"><a class="link" href="#the-language">3. The language.</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter will be a little introduction to ClojureScript without assumptions about previous
knowledge of the Clojure language, providing a quick tour over all the things you will need to know
in order to understand the rest of this book.</p>
</div>
<div class="sect2">
<h3 id="first-steps-with-lisp-syntax"><a class="link" href="#first-steps-with-lisp-syntax">3.1. First steps with Lisp syntax</a></h3>
<div class="paragraph">
<p>Invented by John McCarthy in 1958, Lisp is one of the oldest programming languages that is still
around. It has evolved into many derivatives called dialects, and ClojureScript is
one of them. It&#8217;s a programming language written in its own data structures, originally lists enclosed in
parentheses, but Clojure(Script) has evolved the Lisp syntax with more data structures, making
it more pleasant to write and read.</p>
</div>
<div class="paragraph">
<p>A list with a function in the first position is used for calling a function in ClojureScript:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, we&#8217;re applying the addition function <code>+</code> to the arguments 1, 2 and 3. ClojureScript
allows many unusual characters like <code>?</code> or <code>-</code> in symbol names, which makes it easier to read:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">zero? </span><span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For distinguishing function calls and lists, we can quote lists to keep them from being evaluated. The quoted
lists will be treated as data instead of as a function call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (+ 1 2 3)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>ClojureScript uses more than lists for its syntax. The full details will be covered later, but here is an
example of the usage of a vector (enclosed in brackets) for defining local bindings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-mi">1</span>
      <span class="tok-nv">y</span> <span class="tok-mi">2</span>
      <span class="tok-nv">z</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span> <span class="tok-nv">z</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; 6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is practically all the syntax we need to know for using not only ClojureScript, but any Lisp. Being
written in its own data structures (often referred to as <em>homoiconicity</em>) is a great property since the
syntax is uniform and simple; also, code generation via macros is easier than in any other language, giving
us plenty of power to extend the language to suit our needs.</p>
</div>
</div>
<div class="sect2">
<h3 id="the-base-data-types"><a class="link" href="#the-base-data-types">3.2. The base data types</a></h3>
<div class="paragraph">
<p>The ClojureScript language has a rich set of data types like most programming languages. It provides
scalar datatypes that will be very familiar to you, such as numbers, strings, and floats. Beyond these, it also
provides a great number of others that might be less familiar, such as symbols, keywords, regex (regular expressions),
vars, atoms, volatiles&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p><em>ClojureScript</em> embraces the host language, and where possible it uses the host&#8217;s provided types. For example:
numbers and strings are used as is, and they behave in same way as in JavaScript.</p>
</div>
<div class="sect3">
<h4 id="numbers"><a class="link" href="#numbers">3.2.1. Numbers</a></h4>
<div class="paragraph">
<p>In <em>ClojureScript</em>,  numbers include both integers and floating points. Keeping in mind that
<em>ClojureScript</em> is a guest language that compiles to JavaScript, integers are actually JavaScript&#8217;s native
floating points under the hood.</p>
</div>
<div class="paragraph">
<p>As in any other language, numbers in <em>ClojureScript</em> are represented in following ways:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-mi">23</span>
<span class="tok-nv">+23</span>
<span class="tok-mi">-100</span>
<span class="tok-mf">1.7</span>
<span class="tok-mi">-2</span>
<span class="tok-mi">33</span><span class="tok-nv">e8</span>
<span class="tok-mi">12</span><span class="tok-nv">e-14</span>
<span class="tok-mf">3.2</span><span class="tok-nv">e-4</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="keywords"><a class="link" href="#keywords">3.2.2. Keywords</a></h4>
<div class="paragraph">
<p>Keywords in <em>ClojureScript</em> are objects that always evaluate to themselves. They are usually
used in <a href="#maps-section">map data structures</a> to efficiently represent the keys.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-ss">:foobar</span>
<span class="tok-ss">:2</span>
<span class="tok-ss">:?</span>
<span class="tok-ss">:foo/bar</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the keywords are all prefixed with <code>:</code>, but this character is only part
of the literal syntax and is not part of the name of the object.</p>
</div>
<div class="paragraph">
<p>You can also create a keyword by calling the <code>keyword</code> function. Don&#8217;t worry if you don&#8217;t understand
or are unclear about anything in the following example; <a href="#function-section">functions</a> are discussed in a later section.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">keyword </span><span class="tok-s">&quot;foo&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; :foo</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="symbols"><a class="link" href="#symbols">3.2.3. Symbols</a></h4>
<div class="paragraph">
<p>Symbols in <em>ClojureScript</em> are very, very similar to <strong>Keywords</strong> (which you now know about). But
instead of evaluating to themselves, symbols are evaluated to something that they refer to, which
can be functions, variables, etc.</p>
</div>
<div class="paragraph">
<p>Symbols are represented with something that does not start with a number:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-nv">sample-symbol</span>
<span class="tok-nv">othersymbol</span>
<span class="tok-nv">f1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Don&#8217;t worry if you don&#8217;t understand right away; symbols are used in almost
all of our examples, which will give you the opportunity to learn more as we go on.</p>
</div>
</div>
<div class="sect3">
<h4 id="strings"><a class="link" href="#strings">3.2.4. Strings</a></h4>
<div class="paragraph">
<p>There is almost nothing new we can explain about strings that you don&#8217;t already know. In <em>ClojureScript</em>, they
 work the same as in any other language. One point of interest, however, is that they are immutable.</p>
</div>
<div class="paragraph">
<p>In this case they are the same as in JavaScript:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-s">&quot;An example of a string&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>One peculiar aspect of strings in <em>ClojureScript</em> is due to the language&#8217;s Lisp syntax: single and multiline strings
have the same syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-s">&quot;This is a multiline</span>
<span class="tok-s">      string in ClojureScript.&quot;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="characters"><a class="link" href="#characters">3.2.5. Characters</a></h4>
<div class="paragraph">
<p><em>ClojureScript</em> also lets you write single characters using Clojure&#8217;s character literal syntax.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-sc">\a</span>        <span class="tok-c1">; The lowercase a character</span>
<span class="tok-sc">\n</span><span class="tok-nv">ewline</span>  <span class="tok-c1">; The new line character</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the host language doesn&#8217;t contain character literals, <em>ClojureScript</em> characters are transformed
behind the scenes into single character JavaScript strings.</p>
</div>
</div>
<div class="sect3">
<h4 id="collections"><a class="link" href="#collections">3.2.6. Collections</a></h4>
<div class="paragraph">
<p>Another big step in explaining a language is to explain its collections and collection
abstractions. <em>ClojureScript</em> is not an exception to this rule.</p>
</div>
<div class="paragraph">
<p><em>ClojureScript</em> comes with many types of different collections. The main difference between <em>ClojureScript</em>
collections and collections in other languages is that they are persistent and immutable.</p>
</div>
<div class="paragraph">
<p>Before moving on to all of these (possibly) unknown concepts, we&#8217;ll present a high level overview
of existing collection types in <em>ClojureScript</em>.</p>
</div>
<div class="sect4">
<h5 id="lists"><a class="link" href="#lists">Lists</a></h5>
<div class="paragraph">
<p>This is a classic collection type in languages based on Lisp. Lists are the
simplest type of collection in <em>ClojureScript</em>. Lists can contain items of any type, including
other collections.</p>
</div>
<div class="paragraph">
<p>Lists in <em>ClojureScript</em> are represented by items enclosed between parentheses:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">)</span>
<span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span> <span class="tok-mi">2</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, all list examples are prefixed with the <code>'</code> char. This is because lists in Lisp-like
languages are often used to express things like function or macro calls. In that case,
the first item should be a symbol that will evaluate to something callable, and the rest of the list
elements will be function arguments. However, in the preceding examples, we don&#8217;t want the first item as a symbol;
we just want a list of items.  The following example shows the difference between a list without and with the preceding
single quote mark:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>

<span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (inc 1)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you see, if you  evaluate <code>(inc 1)</code> without prefixing it with <code>'</code>, it will resolve
the <code>inc</code> symbol to the <strong>inc</strong> function and will execute it with <code>1</code> as first argument, returning the value <code>2</code>.</p>
</div>
<div class="paragraph">
<p>You can also explicitly create a list with the <code>list</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (1 2 3 4 5)</span>

<span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (:foo :bar 2)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Lists have the pecularity that they are very efficient if you access them sequentially or
access their first elements, but a list is not a very good option if you need random (index) access to its
elements.</p>
</div>
</div>
<div class="sect4">
<h5 id="vectors"><a class="link" href="#vectors">Vectors</a></h5>
<div class="paragraph">
<p>Like lists, <strong>vectors</strong>  store a series of values, but in this case with very efficient index access
to their elements, as opposed to lists, which are evaluated in order. Don&#8217;t worry; in
the following chapters we&#8217;ll go in depth with details, but at this moment, this simple explanation is
more than enough.</p>
</div>
<div class="paragraph">
<p>Vectors use square brackets for the literal syntax; let&#8217;s see some examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">[</span><span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span><span class="tok-p">]</span>
<span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span> <span class="tok-nv">nil</span><span class="tok-p">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Like lists, vectors can contain objects of any type, as you can observe in the preceding example.</p>
</div>
<div class="paragraph">
<p>You can also explicitly create a vector with the <code>vector</code> function, but this is not commonly used in ClojureScript programs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">vector </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [1 2 3]</span>

<span class="tok-p">(</span><span class="tok-nb">vector </span><span class="tok-s">&quot;blah&quot;</span> <span class="tok-mf">3.5</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [&quot;blah&quot; 3.5 nil]</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="maps-section"><a class="link" href="#maps-section">Maps</a></h5>
<div class="paragraph">
<p>Maps are a collection abstraction that allows you to store key/value pairs. In other
languages this type of structure is commonly known as a hash-map or dict (dictionary). Map literals
in <em>ClojureScript</em> are written with the pairs between curly braces.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">{</span><span class="tok-ss">:foo</span> <span class="tok-s">&quot;bar&quot;</span>, <span class="tok-ss">:baz</span> <span class="tok-mi">2</span><span class="tok-p">}</span>
<span class="tok-p">{</span><span class="tok-ss">:alphabet</span> <span class="tok-p">[</span><span class="tok-ss">:a</span> <span class="tok-ss">:b</span> <span class="tok-ss">:c</span><span class="tok-p">]}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Commas are frequently used to separate a key-value pair but are completely optional. In
<em>ClojureScript</em> syntax, commas are treated like spaces.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Like vectors, every item in a map literal is evaluated before the result is stored in a map, but
the order of evaluation is not guaranteed.</p>
</div>
</div>
<div class="sect4">
<h5 id="sets"><a class="link" href="#sets">Sets</a></h5>
<div class="paragraph">
<p>And finally, <strong>Sets</strong>.</p>
</div>
<div class="paragraph">
<p>Sets store zero or more unique items of any type and are unordered. They,
like maps, use curly braces for their literal syntax, with the difference being that they use a <code>#</code> as leading
character:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span><span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In subsequent chapters we&#8217;ll go in depth about sets and the other collection types you&#8217;ve seen in this
chapter.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="vars"><a class="link" href="#vars">3.3. Vars</a></h3>
<div class="paragraph">
<p><em>ClojureScript</em> is a mostly functional language and focused on immutability. Because of that, it does
not have the concept of variables as you know them in most other programming languages. The closest analogy to
variables are the variables you define in algebra; when you say <code>x = 6</code> in mathematics, you are saying that you
want the symbol <code>x</code> to stand for the number six.</p>
</div>
<div class="paragraph">
<p>In <em>ClojureScript</em>, vars are represented by symbols and store a single value together with metadata.</p>
</div>
<div class="paragraph">
<p>You can define a var using the <code>def</code> special form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">x</span> <span class="tok-mi">22</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">y</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Vars are always top level in the namespace (<a href="#namespace-section">which we will explain later</a>). If you use <code>def</code> in a function call,
the var will be defined at the namespace level, but we do not recommend this - instead, you should use <code>let</code>
to define variables within a function.</p>
</div>
</div>
<div class="sect2">
<h3 id="function-section"><a class="link" href="#function-section">3.4. Functions</a></h3>
<div class="sect3">
<h4 id="the-first-contact"><a class="link" href="#the-first-contact">3.4.1. The first contact</a></h4>
<div class="paragraph">
<p>It&#8217;s time to make things happen. <em>ClojureScript</em> has what are known as first class functions. They behave
like any other type; you can pass them as parameters and you can return them as values, always respecting
the lexical scope. <em>ClojureScript</em> also has some features of dynamic scoping, but this will be discussed
in another section.</p>
</div>
<div class="paragraph">
<p>If you want know more about scopes, this <a href="http://en.wikipedia.org/wiki/Scope_(computer_science)">wikipedia article</a>
is very extensive and explains different types of scoping.</p>
</div>
<div class="paragraph">
<p>As <em>ClojureScript</em> is a Lisp dialect, it uses the prefix notation for calling a function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, <code>inc</code> is a function and is part of the <em>ClojureScript</em> runtime, and <code>1</code> is the first
argument for the <code>inc</code> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>+</code> symbol represents an <code>add</code> function. It allows multiple parameters, whereas in ALGOL-type languages,
<code>+</code> is an operator and only allows two parameters.</p>
</div>
<div class="paragraph">
<p>The prefix notation has huge advantages, some of them not always obvious. <em>ClojureScript</em> does not
make a distinction between a function and operator; everything is a function. The immediate advantage
is that the prefix notation allows an arbitrary number of arguments per "operator". Also, it completely
eliminates the problem of operator precedence.</p>
</div>
</div>
<div class="sect3">
<h4 id="defining-your-own-functions"><a class="link" href="#defining-your-own-functions">3.4.2. Defining your own functions</a></h4>
<div class="paragraph">
<p>You can define an un-named (anonymous) function with the <code>fn</code> special form. This is one type of function definition;
in the following example, the function takes two parameters and returns their average.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">param1</span> <span class="tok-nv">param2</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">/ </span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">param1</span> <span class="tok-nv">param2</span><span class="tok-p">)</span> <span class="tok-mf">2.0</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can define a function and call it at same time (in a single expression):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">((</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">x</span> <span class="tok-nv">x</span><span class="tok-p">))</span> <span class="tok-mi">5</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 25</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s start creating named functions. But what does a <em>named function</em> really mean? It is very simple;
in <em>ClojureScript</em>, functions are first-class and behave like any other value, so naming a function
is done by simply binding the function to a symbol:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">square</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">x</span> <span class="tok-nv">x</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">square</span> <span class="tok-mi">12</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 144</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>ClojureScript</em> also offers the <code>defn</code> macro as a little syntactic sugar for making function definition
more idiomatic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">square</span>
  <span class="tok-s">&quot;Return the square of a given number.&quot;</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">x</span> <span class="tok-nv">x</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The string that comes between the function name and the parameter vector is called a
<em>docstring</em> (documentation string); programs that automatically create web documentation
from your source files will use these docstrings.</p>
</div>
</div>
<div class="sect3">
<h4 id="function-with-multiple-arities"><a class="link" href="#function-with-multiple-arities">3.4.3. Function with multiple arities</a></h4>
<div class="paragraph">
<p><em>ClojureScript</em> also comes with the ability to define functions with arbitrary number of
arguments. (The term <em>arity</em> means the number of arguments that a function takes.) The
syntax is almost the same as for defining an ordinary function, with the difference that
it has more than one body.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see an example, which will surely explain it much better:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">myinc</span>
  <span class="tok-s">&quot;Self defined version of parameterized `inc`.&quot;</span>
  <span class="tok-p">([</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">myinc</span> <span class="tok-nv">x</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
  <span class="tok-p">([</span><span class="tok-nv">x</span> <span class="tok-nv">increment</span><span class="tok-p">]</span>
   <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">increment</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This line: <code>([x] (myinc x 1)</code> says that if there is only one argument, call the function
<code>myinc</code> with that argument and the number <code>1</code> as the second argument. The other function body:
<code>([x increment] (+ x increment))</code> says that if there are two arguments, return the result of
adding them.</p>
</div>
<div class="paragraph">
<p>Here are some examples using the previously defined multi-arity function. Observe that
if you call a function with wrong number of arguments, the compiler will emit an error message.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">myinc</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nf">myinc</span> <span class="tok-mi">1</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 4</span>

<span class="tok-p">(</span><span class="tok-nf">myinc</span> <span class="tok-mi">1</span> <span class="tok-mi">3</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; Compiler error</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Explaining the concept of "arity" is out of the scope of this book, however you can read about that in this
<a href="http://en.wikipedia.org/wiki/Arity">wikipedia article</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="variadic-functions"><a class="link" href="#variadic-functions">3.4.4. Variadic functions</a></h4>
<div class="paragraph">
<p>Another way to accept multiple parameters is defining variadic functions. Variadic functions
are functions that will be able to accept an arbitrary number of arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-variadic-set</span>
  <span class="tok-p">[</span><span class="tok-o">&amp;</span> <span class="tok-nv">params</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">set </span><span class="tok-nv">params</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">my-variadic-set</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{1 2 3}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The way to denote a variadic function is using the <code>&amp;</code> symbol prefix on its arguments vector.</p>
</div>
</div>
<div class="sect3">
<h4 id="short-syntax-for-anonymous-functions"><a class="link" href="#short-syntax-for-anonymous-functions">3.4.5. Short syntax for anonymous functions</a></h4>
<div class="paragraph">
<p><em>ClojureScript</em> provides a shorter syntax for defining anonymous functions using
the <code>#()</code> reader macro (usually leads to one liners). Reader macros are "special" expressions that will be
transformed to the appropriate language form at compile time; in this case, to some expression
that uses <code>fn</code> special form.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">my-set</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">set </span><span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-nv">%1</span> <span class="tok-nv">%2</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">my-set</span> <span class="tok-s">&quot;x&quot;</span> <span class="tok-s">&quot;y&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{&quot;x&quot; &quot;y&quot;}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding definition is shorthand for:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">my-set-longer</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-nv">b</span><span class="tok-p">]</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">set </span><span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-nv">a</span> <span class="tok-nv">b</span><span class="tok-p">))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>%1</code>, <code>%2</code>, <code>%N</code> are simple markers for parameter positions that are implicitly declared when
the reader macro will be interpreted and converted to a <code>fn</code> expression.</p>
</div>
<div class="paragraph">
<p>Also, if a function only accepts one argument, you can omit the number after <code>%</code> symbol; the
function <code>#(set (list %1))</code> can be written <code>#(set (list %))</code>.</p>
</div>
<div class="paragraph">
<p>Additionally, this syntax also supports the variadic form with the`%&amp;` symbol:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">my-variadic-set</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">set </span><span class="tok-nv">%</span><span class="tok-o">&amp;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">my-variadic-set</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{1 2}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="flow-control"><a class="link" href="#flow-control">3.5. Flow control</a></h3>
<div class="paragraph">
<p><em>ClojureScript</em> has a very different approach for flow control than languages like JavaScript, C, etc.</p>
</div>
<div class="sect3">
<h4 id="branching-with-code-if-code"><a class="link" href="#branching-with-code-if-code">3.5.1. Branching with <code>if</code></a></h4>
<div class="paragraph">
<p>Let start with a basic one: <code>if</code>. In <em>ClojureScript</em> the <code>if</code> is an expression and not a
statement, and it has three parameter: the first one is the condition expression, the second one
is an expression that will be evaluated if the condition expression evaluates to logical true,
and the third expression will be evaluated otherwise.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">discount</span>
  <span class="tok-s">&quot;You get 5% discount for ordering 100 or more items&quot;</span>
  <span class="tok-p">[</span><span class="tok-nv">quantity</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">&gt;= </span><span class="tok-nv">quantity</span> <span class="tok-mi">100</span><span class="tok-p">)</span>
    <span class="tok-mf">0.05</span>
    <span class="tok-mi">0</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">discount</span> <span class="tok-mi">30</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0</span>

<span class="tok-p">(</span><span class="tok-nf">discount</span> <span class="tok-mi">130</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0.05</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The block expression <code>do</code> can be used to have multiple expressions in an <code>if</code> branch.
<a href="#block-section"><code>do</code> is explained in the next section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="branching-with-code-cond-code"><a class="link" href="#branching-with-code-cond-code">3.5.2. Branching with <code>cond</code></a></h4>
<div class="paragraph">
<p>Sometimes, the <code>if</code> expression can be slightly limited because it does not have the "else if" part
to add more than one condition. The <code>cond</code> comes to the rescue.</p>
</div>
<div class="paragraph">
<p>With the <code>cond</code> expression, you can define multiple conditions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">mypos?</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">cond</span>
    <span class="tok-p">(</span><span class="tok-nb">&gt; </span><span class="tok-nv">x</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-s">&quot;positive&quot;</span>
    <span class="tok-p">(</span><span class="tok-nb">&lt; </span><span class="tok-nv">x</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-s">&quot;negative&quot;</span>
    <span class="tok-ss">:else</span> <span class="tok-s">&quot;zero&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">mypos?</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;zero&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">mypos?</span> <span class="tok-mi">-2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;negative&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, <code>cond</code> has another form, called <code>condp</code>, that works very similarly to the simple <code>cond</code>
but looks cleaner when the condition (also called a predicate) is the same for all conditions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">translate-lang-code</span>
  <span class="tok-p">[</span><span class="tok-nv">code</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">condp</span> <span class="tok-nb">= </span><span class="tok-p">(</span><span class="tok-nb">keyword </span><span class="tok-nv">code</span><span class="tok-p">)</span>
    <span class="tok-ss">:es</span> <span class="tok-s">&quot;Spanish&quot;</span>
    <span class="tok-ss">:en</span> <span class="tok-s">&quot;English&quot;</span>
    <span class="tok-s">&quot;Unknown&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">translate-lang-code</span> <span class="tok-s">&quot;en&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;English&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">translate-lang-code</span> <span class="tok-s">&quot;fr&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Unknown&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The line <code>condp = (keyword code)</code> means that, in each of the following lines, <em>ClojureScript</em>
will apply the <code>=</code> function to the given keyword and the <code>code</code> argument.</p>
</div>
</div>
<div class="sect3">
<h4 id="branching-with-code-case-code"><a class="link" href="#branching-with-code-case-code">3.5.3. Branching with <code>case</code></a></h4>
<div class="paragraph">
<p>The <code>case</code> branching expression has very similar use case as our previous example with
<code>condp</code>. The main difference is that <code>case</code> always uses the <code>=</code> predicate/function, and its
branching values are evaluated at compile time. This results in a more performant form
than <code>cond</code> or <code>condp</code> but has the disadvantage that the condition value must be
a static value.</p>
</div>
<div class="paragraph">
<p>Here is the same example as previous one, but using <code>case</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">translate-lang-code</span>
  <span class="tok-p">[</span><span class="tok-nv">code</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">case</span> <span class="tok-nv">code</span>
    <span class="tok-s">&quot;es&quot;</span> <span class="tok-s">&quot;Spanish&quot;</span>
    <span class="tok-s">&quot;es&quot;</span> <span class="tok-s">&quot;English&quot;</span>
    <span class="tok-s">&quot;Unknown&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">translate-lang-code</span> <span class="tok-s">&quot;en&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;English&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">translate-lang-code</span> <span class="tok-s">&quot;fr&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Unknown&quot;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="locals-blocks-and-loops"><a class="link" href="#locals-blocks-and-loops">3.6. Locals, Blocks and Loops</a></h3>
<div class="sect3">
<h4 id="locals"><a class="link" href="#locals">3.6.1. Locals</a></h4>
<div class="paragraph">
<p><em>ClojureScript</em> does not has the concept of variables as in ALGOL-like languages, but it does
have locals. Locals, as per usual, are immutable, and if you try mutate them, the compiler
will throw an error.</p>
</div>
<div class="paragraph">
<p>The locals are defined with the <code>let</code> expression. The expression starts with a vector as first parameter
followed by an arbitrary number of expressions. The first parameter (the vector) should contain an arbitrary
number of pairs that give a <em>binding form</em> (usually a symbol) followed by an expression whose value will
be bound to this new local for the remainder of the let expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-mi">1</span><span class="tok-p">)</span>
      <span class="tok-nv">y</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-mi">1</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Simple message from the body of a let&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">))</span>
<span class="tok-c1">;; Simple message from the body of a let</span>
<span class="tok-c1">;; =&gt; 6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the symbol <code>x</code> is bound to the value <code>(inc 1)</code>, which comes out to 2,
and the symbol <code>y</code> is bound to the sum of <code>x</code> and 1, which comes out to 3. Given those bindings, the
expressions <code>(println "Simple message from the body of a let")</code> and <code>(* x y)</code> are evaluated.</p>
</div>
<div class="paragraph">
<p><a id="block-section"></a>
==== Blocks</p>
</div>
<div class="paragraph">
<p>In JavaScript, braces <code>{</code> and <code>}</code> delimit a block of code that belongs together. Blocks in
<em>ClojureScript</em> are created using the <code>do</code> expression and are usually used for side effects, like
printing something to the console or writing a log in a logger.</p>
</div>
<div class="paragraph">
<p>A side effect is something that is not necessary for the return value.</p>
</div>
<div class="paragraph">
<p>The <code>do</code> expression accepts as its parameter an arbitrary number of other expressions, but it returns
the return value only from the last one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">do</span>
   <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;hello world&quot;</span><span class="tok-p">)</span>
   <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;hola mundo&quot;</span><span class="tok-p">)</span>
   <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-mi">3</span> <span class="tok-mi">5</span><span class="tok-p">)</span> <span class="tok-c1">;; this value will not be returned; it is thrown away</span>
   <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>

<span class="tok-c1">;; hello world</span>
<span class="tok-c1">;; hola mundo</span>
<span class="tok-c1">;; =&gt; 3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The body of the <code>let</code> expression, explained in previous section, is very similar to the
<code>do</code> expression, in that it allows multiple expressions. In fact, the <code>let</code> has an implicit <code>do</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="loops"><a class="link" href="#loops">3.6.2. Loops</a></h4>
<div class="paragraph">
<p>The functional approach of <em>ClojureScript</em> means that it does not have standard,
well known statement-based loops such as <code>for</code> in JavaScript. The loops in <em>ClojureScript</em> are handled using recursion.
Recursion sometimes requires additional thinking about how to model your problem in
a slightly different way than imperative languages.</p>
</div>
<div class="paragraph">
<p>Also, many of the common patterns for which <code>for</code> is used in other languages are achieved
through higher-order functions - functions that accept other functions as parameters.</p>
</div>
<div class="sect4">
<h5 id="looping-with-loop-recur"><a class="link" href="#looping-with-loop-recur">Looping with loop/recur</a></h5>
<div class="paragraph">
<p>Let&#8217;s take a look at how to express loops using recursion with the <code>loop</code> and <code>recur</code> forms.
<code>loop</code> defines a possibly empty list of bindings (notice the symmetry with <code>let</code>) and <code>recur</code>
jumps execution back to the looping point with new values for those bindings.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">loop </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-mi">0</span><span class="tok-p">]</span>
   <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Looping with &quot;</span> <span class="tok-nv">x</span><span class="tok-p">)</span>
   <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">x</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Done looping!&quot;</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">x</span><span class="tok-p">))))</span>
<span class="tok-c1">;; Looping with 0</span>
<span class="tok-c1">;; Looping with 1</span>
<span class="tok-c1">;; Looping with 2</span>
<span class="tok-c1">;; Done looping!</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above snippet, we bind the name <code>x</code> to the value <code>0</code> and execute the body. Since the
condition is not met the first time it&#8217;s run we <code>recur</code>, incrementing the binding value with
the <code>inc</code> function. We do this once more until the condition is met and, since there aren&#8217;t
more <code>recur</code> calls, exit the loop.</p>
</div>
<div class="paragraph">
<p>Note that <code>loop</code> isn&#8217;t the only point we can <code>recur</code> to; using <code>recur</code> inside a function
executes the body of the function recursively with the new bindings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">recursive-function</span> <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span>
   <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Looping with&quot;</span> <span class="tok-nv">x</span><span class="tok-p">)</span>
   <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">x</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Done looping!&quot;</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">x</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">recursive-function</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; Looping with 0</span>
<span class="tok-c1">;; Looping with 1</span>
<span class="tok-c1">;; Looping with 2</span>
<span class="tok-c1">;; Done looping!</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="replacing-for-loops-with-higher-order-functions"><a class="link" href="#replacing-for-loops-with-higher-order-functions">Replacing for loops with higher-order functions</a></h5>
<div class="paragraph">
<p>In imperative programming languages it is common to use <code>for</code> loops to iterate over data and
transform it, usually the intent being one of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Transform every value in the iterable yielding another iterable</p>
</li>
<li>
<p>Filter the elements of the iterable by certain criteria</p>
</li>
<li>
<p>Convert the iterable to a value where each iteration depends on the result from the previous one</p>
</li>
<li>
<p>Run a computation for every value in the iterable</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The above actions are encoded in higher-order functions and syntactic constructs in ClojureScript;
let&#8217;s see an example of the first three.</p>
</div>
<div class="paragraph">
<p>For transforming every value in an iterable data structure we use the <code>map</code> function, which takes a
function and a sequence and applies the function to every element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (1 2 3)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The first paramater for <code>map</code> can be <em>any</em> function that takes one argument and returns a value.
For example, if you had a graphing application and you wanted to graph the equation
<code>y&#160;=&#160;3x&#160;+&#x160;5</code> for a set of <em>x</em> values, you could get the <em>y</em> values like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">y-value</span> <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-mi">3</span> <span class="tok-nv">x</span><span class="tok-p">)</span> <span class="tok-mi">5</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">y-value</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (8 11 14 17 20)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If your function is short, you can use an anonymous function instead, either the normal or short syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-mi">3</span> <span class="tok-nv">x</span><span class="tok-p">)</span> <span class="tok-mi">5</span><span class="tok-p">))</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (8 11 14 17 20)</span>
<span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-mi">3</span> <span class="tok-nv">%1</span><span class="tok-p">)</span> <span class="tok-mi">5</span><span class="tok-p">)</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (8 11 14 17 20)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For filtering the values of a data structure we use the <code>filter</code> function, which takes a predicate
and a sequence and gives a new sequence with only the elements that returned <code>true</code> for the given
predicate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-nv">odd?</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (1 3)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, you can use any function that returns <code>true</code> or <code>false</code> as the first argument to <code>filter</code>.
Here is an example that keeps only words less than five characters long. (The <code>count</code> function
returns the length of its argument.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">word</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">&lt; </span><span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-nv">word</span><span class="tok-p">)</span> <span class="tok-mi">5</span><span class="tok-p">))</span> <span class="tok-p">[</span><span class="tok-s">&quot;ant&quot;</span> <span class="tok-s">&quot;baboon&quot;</span> <span class="tok-s">&quot;crab&quot;</span> <span class="tok-s">&quot;duck&quot;</span> <span class="tok-s">&quot;echidna&quot;</span> <span class="tok-s">&quot;fox&quot;</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (&quot;ant&quot; &quot;crab&quot; &quot;duck&quot; &quot;fox&quot;)</span>

<span class="tok-nv">Converting</span> <span class="tok-nv">an</span> <span class="tok-nv">iterable</span> <span class="tok-nv">to</span> <span class="tok-nv">a</span> <span class="tok-nv">single</span> <span class="tok-nv">value</span>, <span class="tok-nv">accumulating</span> <span class="tok-nv">the</span> <span class="tok-nv">intermediate</span> <span class="tok-nv">result</span> <span class="tok-nv">at</span> <span class="tok-nv">every</span> <span class="tok-nv">step</span> <span class="tok-nv">of</span> <span class="tok-nv">the</span> <span class="tok-nv">iteration</span>
<span class="tok-nv">can</span> <span class="tok-nv">be</span> <span class="tok-nv">achieved</span> <span class="tok-nv">with</span> <span class="tok-o">`</span><span class="tok-nv">reduce</span><span class="tok-o">`</span>, <span class="tok-nv">which</span> <span class="tok-nv">takes</span> <span class="tok-nv">a</span> <span class="tok-nv">function</span> <span class="tok-nb">for </span><span class="tok-nv">accumulating</span> <span class="tok-nv">values</span>, <span class="tok-nv">an</span> <span class="tok-nv">optional</span> <span class="tok-nv">initial</span> <span class="tok-nv">value</span>
<span class="tok-nb">and </span><span class="tok-nv">a</span> <span class="tok-nv">collection</span><span class="tok-err">:</span>

<span class="tok-p">[</span><span class="tok-nv">source</span>, <span class="tok-nv">clojure</span><span class="tok-p">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>(reduce + 0 [1 2 3 4])
;; &#8658; 10</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Yet again, you can provide your own function as the first argument to `reduce`, but your function must have
_two_ parameters. The first one is the "accumulated value" and the second parameter is the collection item
being processed. The function returns a value that becomes the accumulator for the next item in the list.
For example, here is how you would find the sum of squares of a set of numbers (this is
an important calculation in statistics). Using a separate function:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(defn sum-squares [accumulator item]
  (+ accumulator (* item item)))</p>
</div>
<div class="paragraph">
<p>(reduce sum-squares 0 [3 4 5])
;; &#8658; 50</p>
</div>
<div class="listingblock">
<div class="content">
<pre>...and with an anonymous function:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(reduce (fn [acc item] (+ acc (* item item))) 0 [3 4 5])
;; &#8658; 50</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Here is a `reduce` that finds the total number of characters in a set of words:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(reduce (fn [acc word] (+ acc (count word))) 0 ["ant" "bee" "crab" "duck"])
;; &#8658; 14</p>
</div>
<div class="listingblock">
<div class="content">
<pre>We have not used the short syntax here, because although it requires less typing,
it can be less readable, and when you are starting with a new language,
it's important to be able to read what you wrote! If you are comfortable with the
short syntax, feel free to use it.

Remember to choose your starting value for the accumulator carefully. If you
wanted to use `reduce` to find the product of a series of numbers, you would have to start
with one rather than zero, otherwise all the numbers would be multiplied by zero!

[source, clojure]</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<p>wrong starting value
(reduce * 0 [3 4 5])</p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<p>&#8658; 0</p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<p>correct starting accumulator
(reduce * 1 [3 4 5])</p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<p>&#8658; 60</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre>===== `for` sequence comprehensions

In ClojureScript the `for` construct isn't used for iteration but for generating sequences, an operation
also known as "sequence comprehension". It offers a small domain specific language for declaratively
building sequences.
////
That previous sentence will totally lose a beginning programmer.
////

`for` takes a vector of bindings and a expression and generates a sequence of the result of evaluating the
expression. Let's take a look at an example:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(for [x [1 2 3]]
  [x (* x x)])
;; &#8658; ([1 1] [2 4] [3 9])</p>
</div>
<div class="listingblock">
<div class="content">
<pre>In this example, `x` is bound to each of the items in the vector `[1 2 3]` in turn, and returns a new
sequence of two-item vectors with the original item squared.

`for` supports multiple bindings, which will cause the collections to be iterated in a nested fashion, much
like nesting `for` loops in imperative languages. The innermost binding iterates fastest.

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(for [x [1 2 3]
      y [4 5]]
  [x y])</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<p>&#8658; ([1 4] [1 5] [2 4] [2 5] [3 4] [3 5])</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre>We can also follow the bindings with three modifiers: `:let` for creating local bindings, `:while` for
breaking out of the sequence generation, and `:when` for filtering out values.

Here's an example of local bindings using the `:let` modifier; note that the bindings defined with it
will be available in the expression:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(for [x [1 2 3]
      y [4 5]
      :let [z (+ x y)]]
  z)
;; &#8658; (5 6 6 7 7 8)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>We can use the `:while` modifier for expressing a condition that, when it is no longer met, will stop
the sequence generation. Here's an example:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(for [x [1 2 3]
      y [4 5]
      :while (= y 4)]
  [x y])</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<p>&#8658; ([1 4] [2 4] [3 4])</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre>For filtering out generated values, use the `:when` modifier as in the following example:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(for [x [1 2 3]
      y [4 5]
      :when (= (+ x y) 6)]
  [x y])</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<p>&#8658; ([1 5] [2 4])</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre>We can combine the modifiers shown above for expressing complex sequence generations or
more clearly expressing the intent of our comprehension:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(for [x [1 2 3]
      y [4 5]
      :let [z (+ x y)]
      :when (= z 6)]
  [x y])</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<p>&#8658; ([1 5] [2 4])</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre>When we outlined the most common usages of the `for` construct in imperative programming languages,
we mentioned that sometimes we want to run a computation for every value in a sequence, not caring
about the result. Presumably we do this for achieving some sort of side-effect with the values of
the sequence.

ClojureScript provides the `doseq` construct, which is analogous to `for` but executes the expression,
discards the resulting values, and returns `nil`.

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(doseq [x [1 2 3]
        y [4 5]
       :let [z (+ x y)]]
  (println x "+" y "=" z))</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<p>1 + 4 = 5</p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<p>1 + 5 = 6</p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<p>2 + 4 = 6</p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<p>2 + 5 = 7</p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<p>3 + 4 = 7</p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<p>3 + 5 = 8</p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<p>&#8658; nil</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre>=== Collection types


==== Immutable and persistent

We mentioned before that ClojureScript collections are persistent and immutable, but we didn't explain what
that meant.

An immutable data structure, as its name suggest, is a data structure that can not be changed. In-place
updates are not allowed in immutable data structures.

A persistent data structure is a data structure that returns a new version of itself when transforming
it, leaving the original unmodified. ClojureScript makes this memory and time efficient using an
implementation technique called _structural sharing_, where most of the data shared between two versions
of a value is not duplicated, and transformations of a value are implemented by copying the minimal amount of data
required.

////
I'm not sure you need to go into the following example. Remember, these are beginners.
It's nice for them to know that there is sharing, but they don't need a proof. The example
doesn't really advance their general knowledge of the language, either. Instead, I'd conclude
the preceding paragraph with:

We could write an example program to show this in action, but for now, just trust ClojureScript
to use sharing to keep memory use low and speed high, and lets move on.

////

Let's see an example of appending values to a vector using the `conj` (for "conjoin") operation:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(let [xs [1 2 3]
      ys (conj xs 4)]
  (println "xs:" xs)
  (println "ys:" ys))</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<p>xs: [1 2 3]</p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<p>ys: [1 2 3 4]</p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<p>&#8658; nil</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre>As you can see, we derived a new version of the `xs` vector appending an element to it and got a new
vector `ys` with the element added. However, the `xs` vector remained unchanged, because it is immutable.

For illustrating the structural sharing of ClojureScript data structures, let's compare whether some parts
of the old and new versions of a data structure are actually the same object with the `identical?` predicate.
We'll use the list data type for this purpose:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(let [xs (list 1 2 3)
      ys (cons 0 xs)]
  (println "xs:" xs)
  (println "ys:" ys)
  (println "(rest ys):" (rest ys))
  (identical? xs (rest ys)))</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<p>xs: (1 2 3)</p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<p>ys: (0 1 2 3)</p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<p>(rest ys): (1 2 3)</p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<p>&#8658; true</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre>As you can see in the example, we used `cons` (construct) to prepend a value to the `xs` list and we got
a new list `ys` with the element added. The `rest` of the `ys` list (all the values but the first)
are the same object in memory as the `xs` list, thus `xs` and `ys` share structure.



==== The sequence abstraction

One of the central ClojureScript abstractions is the _sequence_, which can be thought of as a list and can be derived
from any of the collection types. It is persistent and immutable like all collection types, and many of the
core ClojureScript functions return sequences.

The types that can be used to generate a sequence are called "seqables"; we can call `seq` on them and get
a sequence back. Sequences support two basic operations: `first` and `rest`. They both call `seq` on the
argument we provide them:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(first [1 2 3])
;; &#8658; 1</p>
</div>
<div class="paragraph">
<p>(rest [1 2 3])
;; &#8658; (2 3)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Calling `seq` on a seqable can yield different results if the seqable is empty or not. It will return `nil`
when empty and a sequence otherwise:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(seq [])
;; &#8658; nil</p>
</div>
<div class="paragraph">
<p>(seq [1 2 3])
;; &#8658; (1 2 3)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>`next` is a similar sequence operation to `rest`, but it differs from the latter in that it yields a `nil` value
when called with a sequence with one or zero elements. Note that, when given one of the aforementioned sequences,
the empty sequence returned by `rest` will evaluate as a boolean true whereas the `nil` value returned by `next`
will evaluate as false (xref:truthiness-section[see the section on _truthiness_ later in this chapter]).

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(rest [])
;; &#8658; ()</p>
</div>
<div class="paragraph">
<p>(next [])
;; &#8658; nil</p>
</div>
<div class="paragraph">
<p>(rest [1 2 3])
;; &#8658; (2 3)</p>
</div>
<div class="paragraph">
<p>(next [1 2 3])
;; &#8658; (2 3)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>////
This seems like a very advanced concept for the first chapter.
TODO: think about this.
////

===== nil-punning

The above behaviour of `seq` when coupled with the falsey nature of `nil` in boolean contexts make it an idiom for checking
the emptyness of a sequence in ClojureScript, which is often referred to as nil-punning.

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(defn print-coll
  [coll]
  (when (seq coll)
    (println "Saw " (first coll))
    (recur (rest coll))))</p>
</div>
<div class="paragraph">
<p>(print-coll [1 2 3])
;; Saw 1
;; Saw 2
;; Saw 3
;; &#8658; nil</p>
</div>
<div class="paragraph">
<p>(print-coll #{1 2 3})
;; Saw 1
;; Saw 3
;; Saw 2
;; &#8658; nil</p>
</div>
<div class="listingblock">
<div class="content">
<pre>`nil` is also both a seqable and a sequence, and thus it supports all the functions we saw so far:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(seq nil)
;; &#8658; nil</p>
</div>
<div class="paragraph">
<p>(first nil)
;; &#8658; nil</p>
</div>
<div class="paragraph">
<p>(rest nil)
;; &#8658; ()</p>
</div>
<div class="listingblock">
<div class="content">
<pre>===== Functions that work on sequences

The ClojureScript core functions for transforming collections make sequences out of their arguments and are
implemented in terms of the generic sequence operations we learned about in the preceding section. This makes
them highly generic, since we can use them on any data type that is seqable. Let's see how we can use `map` with
a variety of seqables:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(map inc [1 2 3])
;; &#8658; (2 3 4)</p>
</div>
<div class="paragraph">
<p>(map inc #{1 2 3})
;; &#8658; (2 4 3)</p>
</div>
<div class="paragraph">
<p>(map count {:a 41 :b 40})
;; &#8658; (2 2)</p>
</div>
<div class="paragraph">
<p>(map inc '(1 2 3))
;; &#8658; (2 3 4)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>As you may have noticed, functions that operate on sequences are safe to use with empty collections or even
`nil` values since they don't need to do anything but return an empty sequence when encountering such values.

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(map inc [])
;; &#8658; ()</p>
</div>
<div class="paragraph">
<p>(map inc #{})
;; &#8658; ()</p>
</div>
<div class="paragraph">
<p>(map inc nil)
;; &#8658; ()</p>
</div>
<div class="listingblock">
<div class="content">
<pre>We already saw examples with the usual suspects like `map`, `filter` and `reduce`, but ClojureScript offers a
plethora of generic sequence operations in its core namespace. Note that many of the operations we'll learn about
either work with seqables or are extensible to user defined types.

We can query a value to know whether it's a collection type with the `coll?` predicate:
[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(coll? nil)
;; &#8658; false</p>
</div>
<div class="paragraph">
<p>(coll? [1 2 3])
;; &#8658; true</p>
</div>
<div class="paragraph">
<p>(coll? {:language "ClojureScript" :file-extension "cljs"})
;; &#8658; true</p>
</div>
<div class="paragraph">
<p>(coll? "ClojureScript")
;; &#8658; false</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Similar predicates exist for checking if a value is sequence (`seq?`) or a seqable (`seqable?`):
[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(seq? nil)
;; &#8658; false
(seqable? nil)
;; &#8658; false</p>
</div>
<div class="paragraph">
<p>(seq? [])
;; &#8658; false
(seqable? [])
;; &#8658; true</p>
</div>
<div class="paragraph">
<p>(seq? #{1 2 3})
;; &#8658; false
(seqable? #{1 2 3})
;; &#8658; true</p>
</div>
<div class="paragraph">
<p>(seq? "ClojureScript")
;; &#8658; false
(seqable? "ClojureScript")
;; &#8658; false</p>
</div>
<div class="listingblock">
<div class="content">
<pre>For collections that can be counted in constant time, we can use the `count` operation:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(count nil)
;; &#8658; 0</p>
</div>
<div class="paragraph">
<p>(count [1 2 3])
;; &#8658; 3</p>
</div>
<div class="paragraph">
<p>(count {:language "ClojureScript" :file-extension "cljs"})
;; &#8658; 2</p>
</div>
<div class="paragraph">
<p>(count "ClojureScript")
;; &#8658; 13</p>
</div>
<div class="listingblock">
<div class="content">
<pre>We can also get an empty variant of a given collection with the `empty` function:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(empty nil)
;; &#8658; nil</p>
</div>
<div class="paragraph">
<p>(empty [1 2 3])
;; &#8658; []</p>
</div>
<div class="paragraph">
<p>(empty #{1 2 3})
;; &#8658; #{}</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The `empty?` predicate returns true if the given collection is empty:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(empty? nil)
;; &#8658; true</p>
</div>
<div class="paragraph">
<p>(empty? [])
;; &#8658; true</p>
</div>
<div class="paragraph">
<p>(empty? #{1 2 3})
;; &#8658; false</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The `conj` operation adds elements to collections and may add them in different "places" depending
on the type of collection. It adds them where it is most performant for the collection type,
but note that not every collection has a defined order.

We can pass as many elements we want to add to `conj`; let's see it in action:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(conj nil 42)
;; &#8658; (42)</p>
</div>
<div class="paragraph">
<p>(conj [1 2] 3)
;; &#8658; [1 2 3]</p>
</div>
<div class="paragraph">
<p>(conj [1 2] 3 4 5)
;; &#8658; [1 2 3 4 5]</p>
</div>
<div class="paragraph">
<p>(conj '(1 2) 0)
;; &#8658; (0 1 2)</p>
</div>
<div class="paragraph">
<p>(conj #{1 2 3} 4)
;; &#8658; #{1 3 2 4}</p>
</div>
<div class="paragraph">
<p>(conj {:language "ClojureScript"} [:file-extension "cljs"])
;; &#8658; {:language "ClojureScript", :file-extension "cljs"}</p>
</div>
<div class="listingblock">
<div class="content">
<pre>===== Laziness

Most of ClojureScript's sequence-returning functions generate lazy sequences instead of eagerly creating
a whole new sequence. Lazy sequences generate their contents as they are requested, usually when iterating
over them. Laziness ensures that we don't do more work than we need to and gives us the possibility of
treating potentially infinite sequences as regular ones.

////
TODO: This needs a lot more elaboration, and examples showing how lazy sequences behave &amp; how to create them.
////

==== Collections in depth

Now that we're acquainted with ClojureScript's sequence abstraction and some of the generic sequence manipulating
functions, it's time to dive into the concrete collection types and the operations they support.


===== Lists

In ClojureScript lists are mostly used as a data structure for grouping symbols together into programs. Unlike in other
Lisps, many of the syntactic constructs of ClojureScript use data structures different from the list (vectors and maps).
This makes code less uniform, but the gains in readability are well worth the price.

You can think of ClojureScript lists as singly linked lists, where each node contains a value and a pointer to the rest of the list.
This makes it natural (and fast!) to add items to the front of the list, since adding to the end would require traversal of the entire
list. The prepend operation is performed using the `cons` (construct) function.

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(cons 0 (cons 1 (cons 2 ())))
;; &#8658; (0 1 2)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>We used the literal `()` to represent the empty list. Since it doesn't contain any symbols, it is not treated
as a function call. However, when using list literals that contain elements, we need to quote them to
prevent ClojureScript from evaluating them as a function call:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(cons 0 '(1 2))
;; &#8658; (0 1 2)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Since the head is the position that has constant time addition in the list collection, the `conj` operation
on lists naturally adds item in the front:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(conj '(1 2) 0)
;; &#8658; (0 1 2)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Lists and other ClojureScript data structures can be used as stacks using the `peek`, `pop`, and `conj` functions.
Note that the top of the stack will be the "place" where `conj` adds elements, making `conj` equivalent to the
stack's push operation. In the case of lists, `conj` adds elements to the front of the list, `peek` returns the first
element of the list, and `pop` returns a list with all the elements but the first one.

Note that the two operations that return a stack (`conj` and `pop`) don't change the type of the collection used for
the stack.

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def list-stack '(0 1 2))</p>
</div>
<div class="paragraph">
<p>(peek list-stack)
;; &#8658; 0</p>
</div>
<div class="paragraph">
<p>(pop list-stack)
;; &#8658; (1 2)</p>
</div>
<div class="paragraph">
<p>(type (pop list-stack))
;; &#8658; cljs.core/List</p>
</div>
<div class="paragraph">
<p>(conj list-stack -1)
;; &#8658; (-1 0 1 2)</p>
</div>
<div class="paragraph">
<p>(type (conj list-stack -1))
;; &#8658; cljs.core/List</p>
</div>
<div class="listingblock">
<div class="content">
<pre>One thing that lists are not particularly good at is random indexed access. Since they are stored in a single linked list-like
structure in memory, random access to a given index requires a linear traversal in order to either retrieve the requested
item or throw an index out of bounds error. Non-indexed ordered collections like lazy sequences also suffer from this limitation.


===== Vectors

Vectors are one of the most common data structures in ClojureScript. They are used as a syntactic construct in many
places where more traditional Lisps use lists, for example in function argument declarations and `let` bindings.

ClojureScript vectors have enclosing brackets `[]` in their syntax literals. They can be created with `vector` and from
another collection with `vec`:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(vector? [0 1 2])
;; &#8658; true</p>
</div>
<div class="paragraph">
<p>(vector 0 1 2)
;; &#8658; [0 1 2]</p>
</div>
<div class="paragraph">
<p>(vec '(0 1 2))
;; &#8658; [0 1 2]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Vectors are, like lists, ordered collections of heterogeneous values. Unlike lists, vectors grow naturally from the tail,
so the `conj` operation appends items to the end of a vector. Insertion on the end of a vector is effectively constant
time:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(conj [0 1] 2)
;; &#8658; [0 1 2]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Another thing that differentiates lists and vectors is that vectors are indexed collections and as such support efficient
random index access and non-destructive updates. We can use the familiar `nth` function to retrieve values given an index:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(nth [0 1 2] 0)
;; &#8658; 0</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Since vectors associate sequential numeric keys (indexes) to values, we can treat them as an associative data structure. ClojureScript
provides the `assoc` function that, given an associative data structure and a set of key-value pairs, yields a new data structure with
the values corresponding to the keys modified. Indexes begin at zero for the first element in a vector.

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(assoc ["cero" "uno" "two"] 2 "dos")
;; &#8658; ["cero" "uno" "dos"]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Note that we can only `assoc` to a key that is either contained in the vector already or if it's the last position in a vector:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(assoc ["cero" "uno" "dos"] 3 "tres")
;; &#8658; ["cero" "uno" "dos" "tres"]</p>
</div>
<div class="paragraph">
<p>(assoc ["cero" "uno" "dos"] 4 "cuatro")
;; Error: Index 4 out of bounds [0,3]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Perhaps surprisingly, associative data structures can also be used as functions. They are functions of their keys to the values they
are associated with. In the case of vectors, if the given key is not present an exception is thrown:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(["cero" "uno" "dos"] 0)
;; &#8658; "cero"</p>
</div>
<div class="paragraph">
<p>(["cero" "uno" "dos"] 2)
;; &#8658; "dos"</p>
</div>
<div class="paragraph">
<p>(["cero" "uno" "dos"] 3)
;; Error: Not item 3 in vector of length 3</p>
</div>
<div class="listingblock">
<div class="content">
<pre>As with lists, vectors can be also used as stack with the `peek`, `pop` and `conj` functions. Note, however, that vectors grow
from the opposite end of the collection as lists:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def vector-stack [0 1 2])</p>
</div>
<div class="paragraph">
<p>(peek vector-stack)
;; &#8658; 2</p>
</div>
<div class="paragraph">
<p>(pop vector-stack)
;; &#8658; [0 1]</p>
</div>
<div class="paragraph">
<p>(type (pop vector-stack))
;; &#8658; cljs.core/PersistentVector</p>
</div>
<div class="paragraph">
<p>(conj vector-stack 3)
;; &#8658; [0 1 2 3]</p>
</div>
<div class="paragraph">
<p>(type (conj vector-stack 3))
;; &#8658; cljs.core/PersistentVector</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The `map` and `filter` operations return lazy sequences, but as it is common to need a fully realized sequence after performing those operations,
vector-returning counterparts of such functions are available as `mapv` and `filterv`. They have the advantages of being faster
than building a vector from a lazy sequence and making your intent more explicit:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(map inc [0 1 2])
;; &#8658; (1 2 3)</p>
</div>
<div class="paragraph">
<p>(type (map inc [0 1 2]))
;; &#8658; cljs.core/LazySeq</p>
</div>
<div class="paragraph">
<p>(mapv inc [0 1 2])
;; &#8658; [1 2 3]</p>
</div>
<div class="paragraph">
<p>(type (mapv inc [0 1 2]))
;; &#8658; cljs.core/PersistentVector</p>
</div>
<div class="listingblock">
<div class="content">
<pre>===== Maps

Maps are ubiquitous in ClojureScript. Like vectors, they are also used as a syntactic construct for attaching metadata to
vars. Any ClojureScript data structure can be used as a key in a map, although it's common to use keywords since can also
be called as functions.

////
Joe the Beginning Programmer asks: "What do you mean by 'attaching metadata to vars'? I'm conufsed."
////

ClojureScript maps are written literally as key-value pairs enclosed in braces `{}`. Alternatively, they can be created
with the `hash-map` function:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(map? {:name "Cirilla"})
;; &#8658; true</p>
</div>
<div class="paragraph">
<p>(hash-map :name "Cirilla")
;; &#8658; {:name "Cirilla"}</p>
</div>
<div class="paragraph">
<p>(hash-map :name "Cirilla" :surname "Fiona")
;; &#8658; {:name "Cirilla" :surname "Fiona"}</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Since regular maps don't have a specific order, the `conj` operation just adds one or more key-value pairs to a map. `conj`
for maps expects one or more sequences of key-value pairs as its last arguments:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def ciri {:name "Cirilla"})</p>
</div>
<div class="paragraph">
<p>(conj ciri [:surname "Fiona"])
;; &#8658; {:name "Cirilla", :surname "Fiona"}</p>
</div>
<div class="paragraph">
<p>(conj ciri [:surname "Fiona"] [:occupation "Wizard"])
;; &#8658; {:name "Cirilla", :surname "Fiona", :occupation "Wizard"}</p>
</div>
<div class="listingblock">
<div class="content">
<pre>In the preceding example, it just so happens that the order was preserved, but if you have many keys, you will see that
the order is not preserved.

Maps associate keys to values and, as such, are an associative data structure. They support adding associations with `assoc` and,
unlike vectors, removing them with `dissoc`. Let's explore these functions:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(assoc {:name "Cirilla"} :surname "Fiona")
;; &#8658; {:name "Cirilla", :surname "Fiona"}</p>
</div>
<div class="paragraph">
<p>(dissoc {:name "Cirilla"} :name)
;; &#8658; {}</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Maps are also functions of their keys, returning the values related to the given key. Unlike vectors, they return `nil` if we supply
a key that is not present in the map:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>({:name "Cirilla"} :name)
;; &#8658; "Cirilla"</p>
</div>
<div class="paragraph">
<p>({:name "Cirilla"} :surname)
;; &#8658; nil</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ClojureScript also offers sorted hash maps which behave like their unsorted versions but preserve order when iterating over them. We
can create a sorted map with default ordering with `sorted-map`:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def sm (sorted-map :c 2 :b 1 :a 0))
;; &#8658; {:a 0, :b 1, :c 2}</p>
</div>
<div class="paragraph">
<p>(keys sm)
;; &#8658; (:a :b :c)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>If we need a custom ordering we can provide a comparator function to `sorted-map-by`, let's see an example inverting the value
returned by the built-in `compare` function. Comparator functions take two elements to compare and returns -1 (less than), 0 (equal)
or 1 (greater than):

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def reverse-compare (comp - compare))</p>
</div>
<div class="paragraph">
<p>(def sm (sorted-map-by reverse-compare :a 0 :b 1 :c 2))
;; &#8658; {:c 2, :b 1, :a 0}</p>
</div>
<div class="paragraph">
<p>(keys sm)
;; &#8658; (:c :b :a)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>===== Sets

Sets in ClojureScript have literal syntax as values enclosed in `#{}` and they can be created with the `set` constructor. They are
unordered collections of values without duplicates.

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(set? #{\a \e \i \o \u})
;; &#8658; true</p>
</div>
<div class="paragraph">
<p>(set [1 1 2 3])
;; &#8658; #{1 2 3}</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Set literals can not contain duplicate values. If you accidentaly write a set literal with duplicates an error will be thrown:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>#{1 1 2 3}
;; clojure.lang.ExceptionInfo: Duplicate key: 1</p>
</div>
<div class="listingblock">
<div class="content">
<pre>There are many operations that can be performed with sets, although they are located in the `clojure.set` namespace and thus need to be imported.
You'll learn xref:namespace-section[the details of namespacing] later; for now you only need to know that we are loading a namespace called `clojure.set` and binding
it to the `s` symbol.

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(require '[clojure.set :as s])</p>
</div>
<div class="paragraph">
<p>(def danish-vowels #{\a \e \i \o \u \ \ \})
;; &#8658; #{"a" "e" "" "" "i" "o" "u" ""}</p>
</div>
<div class="paragraph">
<p>(def spanish-vowels #{\a \e \i \o \u})
;; &#8658; #{"a" "e" "i" "o" "u"}</p>
</div>
<div class="paragraph">
<p>(s/difference danish-vowels spanish-vowels)
;; &#8658; #{"" "" ""}</p>
</div>
<div class="paragraph">
<p>(s/union danish-vowels spanish-vowels)
;; &#8658; #{"a" "e" "" "" "i" "o" "u" ""}</p>
</div>
<div class="paragraph">
<p>(s/intersection danish-vowels spanish-vowels)
;; &#8658; #{"a" "e" "i" "o" "u"}</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A nice property of immutable sets is that they can be nested. Languages that have mutable sets can end up containing duplicate values, but
that can't happen in ClojureScript. In fact, all ClojureScript data structures can be nested arbitrarily due to immutability.

Sets also support the generic `conj` operation, as every other collection does.

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def spanish-vowels #{\a \e \i \o \u})
;; &#8658; #{"a" "e" "i" "o" "u"}</p>
</div>
<div class="paragraph">
<p>(def danish-vowels (conj spanish-vowels \ \ \))
;; &#8658; #{"a" "e" "i" "o" "u" "" "" ""}</p>
</div>
<div class="paragraph">
<p>(conj #{1 2 3} 1)
;; &#8658; #{1 3 2}</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Sets act as read-only associative data that associates the values it contains to themselves. Since every value except `nil` and `false` is
truthy in ClojureScript, we can use sets as predicate functions:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def vowels #{\a \e \i \o \u})
;; &#8658; #{"a" "e" "i" "o" "u"}</p>
</div>
<div class="paragraph">
<p>(get vowels \b)
;; &#8658; nil</p>
</div>
<div class="paragraph">
<p>(contains? vowels \b)
;; &#8658; false</p>
</div>
<div class="paragraph">
<p>(vowels \a)
;; &#8658; "a"</p>
</div>
<div class="paragraph">
<p>(filter vowels "Hound dog")
;; &#8658; ("o" "u" "o")</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Sets have a sorted counterpart like maps do, created using the functions `sorted-set` and `sorted-set-by` which are analogous to map's `sorted-map` and `sorted-map-by`.

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def unordered-set #{[0] [1] [2]})
;; &#8658; #{[0] [2] [1]}</p>
</div>
<div class="paragraph">
<p>(seq unordered-set)
;; &#8658; ([0] [2] [1])</p>
</div>
<div class="paragraph">
<p>(def ordered-set (sorted-set [0] [1] [2]))
;; &#8658;# {[0] [1] [2]}</p>
</div>
<div class="paragraph">
<p>(seq unordered-set)
;; &#8658; ([0] [1] [2])</p>
</div>
<div class="listingblock">
<div class="content">
<pre>===== Queues

////
I'm not sure that this section is necessary for beginners, but I am OK with it.
////

ClojureScript also provides a persistent and immutable queue. Queues don't have literal syntax since they are not used as pervasively as other collection types.

There are no convenient constructor functions for creating persistent queues. Instead of that, we can get an empty instance using `PersistentQueue`s
`EMPTY` attribute.

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def pq (.-EMPTY PersistentQueue))
;; &#8658; #queue []</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Using `conj` to add values to a queue adds items onto the rear:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def pq (.-EMPTY PersistentQueue))
;; &#8658; #queue []</p>
</div>
<div class="paragraph">
<p>(conj (.-EMPTY PersistentQueue) 1 2 3)
;; &#8658; #queue [1 2 3]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A thing to bear in mind about queues is that the stack operations don't follow the usual stack semantics (pushing and popping from the same end). `pop`
takes values from the front position, and `conj` pushes (appends) elements to the back.

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def pq (conj (.-EMPTY PersistentQueue) 1 2 3))
;; &#8658; #queue [1 2 3]</p>
</div>
<div class="paragraph">
<p>(peek pq)
;; &#8658; 1</p>
</div>
<div class="paragraph">
<p>(pop pq)
;; &#8658; #queue [2 3]</p>
</div>
<div class="paragraph">
<p>(conj pq 4)
;; &#8658; #queue [1 2 3 4]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Queues are not as frequently used as lists or vectors, but it is good to know that they are available in ClojureScript, as they may occasionally come in handy.


=== Destructuring

Destructuring, as its name suggests, is a way of taking apart structured data such as collections and focusing on individual parts of them. ClojureScript
offers a concise syntax for destructuring both indexed sequences and associative data structures that can be used any place where bindings are declared.

Let's see an example of what destructuring is useful for, since it'll help us understand the previous statements better. Imagine that you have a sequence
but are only interested in the first and third item. You could get a reference to them easily with the `nth` function:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(let [v [0 1 2]
      fst (nth v 0)
      thrd (nth v 2)]
  [thrd fst])
;; &#8658; [2 0]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>However, the previous code is overly verbose. Destructuring lets us extract values of indexed sequences more succintly using a vector in the left-hand side of a binding:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(let [[fst _ thrd] [0 1 2]]
  [thrd fst])
;; &#8658; [2 0]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>In the above example, `[fst _ thrd]` is a destructuring form. It is represented as a vector and used for binding indexed values to the symbols `fst` and
`thrd`, corresponding to the index `0` and `2` respectively. The `_` symbol is used as a placeholder for indexes we are not interested in, in this case `1`.

Note that destructuring is not limited to the `let` binding form; it works in almost every place where we bind values to symbols such as in the `for` and `doseq`
special forms or function arguments. We can write a function that takes a pair and swaps its positions very concisely using destructuring syntax in functionn
arguments:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(defn swap-pair [[fst snd]]
  [snd fst])</p>
</div>
<div class="paragraph">
<p>(swap-pair [1 2])
;; &#8658; [2 1]</p>
</div>
<div class="paragraph">
<p>(swap-pair '(3 4))
;; &#8658; [4 3]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Positional destructuring with vectors is quite handy for taking indexed values out of sequences, but sometimes we don't want to discard the rest of
the elements in the sequence when destructuring. Similarly to how `&amp;` is used for accepting variadic function arguments, the ampersand can be used inside a vector
destructuring form for grouping together the rest of a sequence:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(let [[fst snd &amp; more] (range 10)]
  {:first fst
   :snd snd
   :rest more})
;; &#8658; {:first 0, :snd 1, :rest (2 3 4 5 6 7 8 9)}</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Notice how the value in the `0` index got bound to `fst`, the value in the `1` index got bound to `snd` and the sequence of elements from `2` onwards got
bound to the `more` symbol.

We may still be interested in a data structure as a whole even when we are destructuring it. This can be achieved with the `:as` keyword. If used inside
a destructuring form, the original data structure is bound to the symbol following that keyword:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(let [[fst snd &amp; more :as original] (range 10)]
  {:first fst
   :snd snd
   :rest more
   :original original})
;; &#8658; {:first 0, :snd 1, :rest (2 3 4 5 6 7 8 9), :original (0 1 2 3 4 5 6 7 8 9)}</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Not only indexed sequences can be destructured, associative data can also be destructured. Its destructuring binding form is represented as a map instead of
a vector, where the keys are the symbols we want to bind values to and the values are the keys that we want to look up in the associative data structure. Let's
see an example:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(let [{language :language} {:language "ClojureScript"}]
  language)
;; &#8658; "ClojureScript"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>In the above example, we are extracting the value associated with the `:language` key and binding it to the `language` symbol. When looking up keys that are
not present, the symbol will get bound to `nil`:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(let [{name :name} {:language "ClojureScript"}]
  name)
;; &#8658; nil</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Associative destructuring lets us give default values to bindings, which will be used if the key isn't found in the data structure we are taking apart. A map
following the `:or` keyword is used for default values, as the following examples show:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(let [{name :name :or {name "Anonymous"}} {:language "ClojureScript"}]
  name)
;; &#8658; "Anonymous"</p>
</div>
<div class="paragraph">
<p>(let [{name :name :or {name "Anonymous"}} {:name "Cirilla"}]
  name)
;; &#8658; "Cirilla"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Associative destructuring also supports binding the original data structure to a symbol placed after the `:as` keyword:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(let [{name :name :as person} {:name "Cirilla" :age 49}]
  [name person])
;; &#8658; ["Cirilla" {:name "Cirilla" :age 49}]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Not only keywords can be the keys of associative data structures. Numbers, strings, symbols and many other data structures can
be used as keys, so we can destructure using those too. Note that we need to quote the symbols to prevent them from being
resolved as a var lookup:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(let [{tenth 10} (range 100)]
  tenth)
;; &#8658; 11</p>
</div>
<div class="paragraph">
<p>(let [{name "name"} {"name" "Cirilla"}]
  name)
;; &#8658; "Cirilla"</p>
</div>
<div class="paragraph">
<p>(let [{lang 'language} {'language "ClojureScript"}]
  lang)
;; &#8658; "ClojureScript"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Since usually the values corresponding to keys are bound to their equivalent symbol representation (for example, when binding the value of `:language` to the `language`)
and keys are usually keywords, strings or symbols ClojureScript offers shorthand syntax for these cases.

We'll show examples of all, starting with destructuring keywords using `:keys`:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(let [{:keys [name surname]} {:name "Cirilla" :surname "Fiona"}]
  [name surname])
;; &#8658; ["Cirilla" "Fiona"]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>As you can see in the example, if we use the `:keys` keyword and associate it with a vector of symbols in a binding form, the values
corresponding to the keywordized version of the symbols will be bound to them. The `{:keys [name surname]}` destructuring is equivalent
to `{name :name surname :surname}`, only shorter.

The string and symbol shorthand syntax works exactly like `:keys`, but using the `:strs` and `:syms` keywords respectively:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(let [{:strs [name surname]} {"name" "Cirilla" "surname" "Fiona"}]
  [name surname])
;; &#8658; ["Cirilla" "Fiona"]</p>
</div>
<div class="paragraph">
<p>(let [{:syms [name surname]} {'name "Cirilla" 'surname "Fiona"}]
  [name surname])
;; &#8658; ["Cirilla" "Fiona"]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>An interesting property of destructuring is that we can nest destructuring forms arbitrarily, which makes code that accesses nested data
on a collection very easy to understand as it mimics the collection's structure:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(let [{[fst snd] :languages} {:languages ["ClojureScript" "Clojure"]}]
  [snd fst])
;; &#8658; ["Clojure" "ClojureScript"]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[[namespace-section]]
=== Namespaces

==== Defining a namespace

The _namespace_ is ClojureScript's fundamental unit of code modularity. Namespaces are analogous to Java packages or
Ruby and Python modules, and can be defined with the `ns` macro. Maybe if you have looked at a little bit of
ClojureScript source you have seen something like this at begining of the file:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(ns myapp.core
  "Some docstring for the namespace.")</p>
</div>
<div class="paragraph">
<p>(def x "hello")</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Namespaces are dynamic, meaning you can create one at any time. The convention however, is to have one namespace
per file. Naturally, a namespace definition is usually at the beginning of the file, followed by an optional
docstring.

Previously we have explained vars and symbols. Every var that you define will be associated
with its namespace. If you do not define a concrete namespace, then the default one called "user" will be
used:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def x "hello")
;; &#8658; #'user/x</p>
</div>
<div class="listingblock">
<div class="content">
<pre>==== Loading other namespaces

Defining a namespace and the vars in it is really easy, but it's not very useful if we can't
use symbols from other namespaces. For this purpose, the `ns` macro offers a simple way to load other
namespaces.

Observe the following:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(ns myapp.main
  (:require myapp.core
            clojure.string))</p>
</div>
<div class="paragraph">
<p>(clojure.string/upper-case myapp.core/x)
;; &#8658; "HELLO"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>As you can observe, we are using fully qualified names (namespace + var name) for access to vars and
functions from different namespaces.

While this will let you access other namespaces, it's also repetitive and overly verbose. It will be especially
uncomfortable if the name of a namespace is very long. To solve that, you can use the `:as` directive to
create an additional (usually shorter) alias to the namespace.
This is how it can be done:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(ns myapp.main
  (:require [myapp.core :as core]
            [clojure.string :as str]))</p>
</div>
<div class="paragraph">
<p>(str/upper-case core/x)
;; &#8658; "HELLO"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Additionaly, _ClojureScript_ offers a simple way to refer to specific vars or functions from a concrete namespace using the `:refer` directive.

The `:refer` directive has two possible arguments: the `:all` keyword or a vector of symbols that will
refer to vars in the namespace. With `:all`, we are indicating that we want to refer all public vars from the
namespace, and with vector we can specify the specific subset of vars that we want. Effectively, it is as if those vars and
functions are now part of your namespace, and you do not need to qualify them at all.

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(ns myapp.main
  (:require [myapp.core :refer :all]
            [clojure.string :refer [upper-case]]))
(upper-case x)
;; &#8658; "HELLO"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>And finally, you should know that everything located in the `cljs.core` namespace is automatically
loaded and you should not require it explicitly. Sometimes you may want declare vars that will clash
with some others defined in the `cljs.core` namespace. To do this, the `ns` macro offers another directive that
allows you to exclude specific symbols and prevent them from being automatically loaded.

Observe the following:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(ns myapp.main
  (:refer-clojure :exclude [min]))</p>
</div>
<div class="paragraph">
<p>(defn min
  [x y]
  (if (&gt; x y)
    y
    x))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The `ns` macro also has other directives for loading host classes (`:import`) and macros
(`:refer-macros`), but these are explained in other sections.


=== Abstractions and Polymorphism

I'm sure that at more than one time you have found yourself in this situation: you have defined a great
abstraction (using interfaces or something similar) for your "business logic" and you have found
the need to deal with another module over which you have absolutely no control, and you probably
were thinking of creating adapters, proxies, and other approaches that imply a great amount
of additional complexity.

Some dynamic languages allow "monkey-patching"; languages where the classes are open and any
method can be defined and redefined at any time. Also, it is well known that this technique is a very
bad practice.

We can not trust languages that allow you to silently overwrite methods that you are using when you import third party libraries; you can not expect
consistent behavior when this happens.

These symptoms are commonly called the "expression problem";
see http://en.wikipedia.org/wiki/Expression_problem for more details

==== Protocols

The _ClojureScript_ primitive for defining "interfaces" is called a Protocol. A protocol consists of
a name and set of functions. All the functions have at least one argument corresponding to the
`this` in JavaScript or `self` in Python.

Protocols provide a type-based polymorphism, and the dispatch is always done by the
first argument (equivalent to JavaScripts `this`, as previously mentioned).

A protocol looks like this:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(ns myapp.testproto)</p>
</div>
<div class="paragraph">
<p>(defprotocol IProtocolName
  "A docstring describing the protocol."
  (sample-method [this] "A doc string of the function associated with the protocol."))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>NOTE: the "I" prefix is commonly used to designate the separation of protocols and types. In the clojure
community there many different opinions about how the "I" prefix should be used. In our opinion, it is an
acceptable solution to avoid name clashing and possible confusion.

From the user perspective, protocol functions are simply plain functions defined in the namespace
where the protocol is defined. As you can intuit, this namespacing of protocols allows us to avoid
any conflict between different protocols implemented for the same type.

Here is an example. Let's create a protocol called `IInvertible` for data that can be "inverted."
It will have a single method named `invert`

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(ns proto.testproto)</p>
</div>
<div class="paragraph">
<p>(defprotocol IInvertible
  "This is a protocol for data types that are 'invertible'"
    (invert [this] "Invert the given item."))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>===== Extending existing types

One of the big strengths of protocols is the ability to extend existing and maybe third party types,
and this operation can be done in different ways. The majority of time you will tend to use
the *extend-protocol* or the *extend-type* macros.

This is an example of how the *extend-type* macro can be used:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(extend-type TypeA
  ProtocolA
  (function-from-protocol-a [this]
    ;; implementation here
    )</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ProtocolB
(function-from-protocol-b-1 [this parameter1]
  ;; implementation here
  )
(function-from-protocol-b-2 [this parameter1 parameter2]
  ;; implementation here
  ))</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>You can observe that with *extend-type* you are extending a single type with different protocols
in a single expression.  Here is code that will extend the `number`, `string`, `List`, and
`PersistentVector` types to be "invertible."  For numbers, we define the inverse to be the
reciprocal of the number (or zero, if the number is zero). For strings, lists, and vectors,
the inverse is defined as the reverse of the input.</pre>
</div>
</div>
<div class="paragraph">
<p>(extend-type number
  IInvertible
  (invert [this] (if (zero? this) 0 (/ 1 this))))</p>
</div>
<div class="paragraph">
<p>(extend-type string
  IInvertible
  (invert [this] (apply str (reverse this))))</p>
</div>
<div class="paragraph">
<p>(extend-type List
  IInvertible
  (invert [this] (reverse this)))</p>
</div>
<div class="paragraph">
<p>(extend-type PersistentVector
  IInvertible
  (invert [this] (into [] (reverse this))))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>If you load in this code, you can see that it works:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(proto.testproto/invert "abc")
;; &#8658; "cba"
(proto.testproto/invert 25)
;; &#8658; 0.04
(proto.testproto/invert "abc")
;; &#8658; "cba"
(proto.testproto/invert '(1 2 3))
;; &#8658; (3 2 1)
(proto.testproto/invert [1 2 3])
;; &#8658; [3 2 1]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Admittedly, this is a somewhat contrived example. In xref:extend-type-section[the next section]
you will see how to extend an existing type.

In comparison, *extend-protocol* does the inverse;
given a protocol, it adds implementations for multiple types:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(extend-protocol ProtocolA
  TypeA
  (function-from-protocol-a [this]
    ;; implementation here
    )</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TypeB
(function-from-protocol-a [this]
  ;; implementation here
  ))</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>Thus, the previous example could have equally well have been written this way:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(extend-protocol IInvertible
  number
  (invert [this] (if (zero? this) 0 (/ 1 this)))</p>
</div>
<div class="literalblock">
<div class="content">
<pre>string
(invert [this] (apply str (reverse this)))</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>List
(invert [this] (reverse this))</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>PersistentVector
(invert [this] (into [] (reverse this))))</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>There are other ways to extend a type with a protocol implementation, but they will be covered
in another section of this book.

anchor:extend-type-section[]
===== Participate in ClojureScript abstractions

ClojureScript itself is built up on abstractions defined as protocols. Almost all behavior
in the _ClojureScript_ language itself can be adapted to third party libraries. Let's go to see a
real life example.

In previous sections we have explained the different kinds of built-in collections. For this example we
will use the *Set*. See this snipped of code:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def mynums #{1 2})</p>
</div>
<div class="paragraph">
<p>(filter mynums [1 2 4 5 1 3 4 5])
;; &#8658; (1 2 1)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>What happened? In this case, the _set_ type implements the _ClojureScript_ internal
`IFn` protocol that represents an abstraction for functions or anything callable. This way it can be
used like a callable predicate in filter.

Ok, but what happens if we want use a regular expression as predicate function for filtering
a collection of strings:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(filter #"^foo" ["haha" "foobar" "baz" "foobaz"])
;; TypeError: Cannot call undefined</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The exception is raised because the RegExp type does not implements the `IFn` protocol
so it cannot behave like a callable, but that can be easily fixed:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(extend-type js/RegExp
  IFn
  (-invoke
   ([this a]
     (re-find this a))))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Lets analyze this:  we are extending the `js/RegExp` type so that it implements the `invoke` function in the
`IFn` protocol. To invoke a regular expression `a` as if it were a function, call the `re-find` function with
the object of the function and the pattern.

Now, you will be able use the regex instances as predicates in filter operation:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(filter #"^foo" ["haha" "foobar" "baz" "foobaz"])
;; &#8658; ("foobar" "foobaz")</p>
</div>
<div class="listingblock">
<div class="content">
<pre>===== Introspection using Protocols

_ClojureScript_ comes with a useful function that allows runtime introspection: `satisfies?`. The
purpose of this function is to determinate at runtime if some object (instance of some type) satisfies the
concrete protocol.

So, with previous examples, if we check if a `set` instance satisfies a *IFn* protocol, it should
return `true`:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(satisfies? IFn #{1})
;; &#8658; true</p>
</div>
<div class="listingblock">
<div class="content">
<pre>==== Multimethods

We have previously talked about protocols, which solve a very common use case of polymorphism:
dispatch by type. But in some circumstances, the protocol approach can be limiting. And
here, *multimethods* come to the rescue.

These *multimethods* are not limited to type dispatch only; instead, they also offer dispatch
by types of multiple arguments and by value. They also allow ad-hoc hierarchies to be defined. Also,
like protocols, multimethods are an "Open System," so you or any third parties can extend a multimethod for
new types.

The basic constructions of *multimethods* are the `defmulti` and `defmethod` forms. The
`defmulti` form is used to create the multimethod with an initial dispatch function. This is
a model of what it looks like:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(defmulti say-hello
  "A polymorphic function that return a greetings message
  depending on the language key with default lang as `:en`"
  (fn [param] (:locale param))
  :default :en)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The anonymous function defined within the `defmulti` form is a dispatch function. It will
be called in every call to `say-hello` function and should return some kind of marker object
that will be used for dispatch. In our example it returns the contents of the `:locale` key
of the first argument.

And finally, you should add implementations. That is done with `defmethod` form:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(defmethod say-hello :en
  [person]
  (str "Hello " (:name person "Anonymous")))</p>
</div>
<div class="paragraph">
<p>(defmethod say-hello :es
  [person]
  (str "Hola " (:name person "Annimo")))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>So, if you execute that function over a hash map containing the `:locale` and optionally
the `:name` key, the multimethod will first call the dispatch function to determine the
dispatch value, then it will search for an implementation for that value. If an implementation
is found, the dispatcher will execute it. Otherwise, the dispatch will search for a default implementation
(if one is specified) and execute it.

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(say-hello {:locale :es})
;; &#8658; "Hola Annimo"</p>
</div>
<div class="paragraph">
<p>(say-hello {:locale :en :name "Ciri"})
;; &#8658; "Hello Ciri"</p>
</div>
<div class="paragraph">
<p>(say-hello {:locale :fr})
;; &#8658; "Hello Anonymous"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>If the default implementation is not specified, an exception will be raised notifying you
that some value does not have a implementation for that multimethod.


==== Hierarchies

Hierarchies are _ClojureScript_s way to let you build whatever relations that your
domain may require. The hierarchies are defined in term of relations between named objects,
such as symbols, keywords or types.

The hierarchies can be defined globally or locally, depending on your needs. Like multimethods,
hierarchies are not limited to a single namespace. You can extend a hierarchy from any namespace,
not necessarily the one in which they are defined.

The global namespace is more limited, for good reasons. Keywords or symbols that are not namespaced can
not be used in the global hierarchy. That behavior helps prevent unexpected situations when
two or more third party libraries use the same symbol for different semantics.


===== Defining a hierarchy

The hierarchy relations should be established using the `derive` function:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(derive ::circle ::shape)
(derive ::box ::shape)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>We have just defined a set of relationships between namespaced keywords. In this case the
`::circle` is a child of `::shape`, and `::box` is also a child of `::shape`.

TIP: The `::circle` keyword syntax is a shorthand for `:current.ns/circle`. So if you are executing
it in a REPL, `::circle` will be evaluated as `:cljs.user/circle`.


===== Hierarchies and introspection

_ClojureScript_ comes with a little toolset of functions that allow runtime introspection
of globally or locally defined hierarchies. This toolset consists of three functions:
`isa?`, `ancestors`, and `descendants`.

Let's see an example of how it can be used with the hierarchy defined in previous example:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(ancestors ::box)
;; &#8658; #{:cljs.user/shape}</p>
</div>
<div class="paragraph">
<p>(descendants ::shape)
;; &#8658; #{:cljs.user/circle :cljs.user/box}</p>
</div>
<div class="paragraph">
<p>(isa? ::box ::shape)
;; &#8658; true</p>
</div>
<div class="paragraph">
<p>(isa? ::rect ::shape)
;; &#8658; false</p>
</div>
<div class="listingblock">
<div class="content">
<pre>===== Locally defined hierarchies

As we mentioned previously, in _ClojureScript_ you also can define local hierarchies. This can be
done with the `make-hierarchy` function. Here is an example of how you can replicate the previous
example using a local hierarchy:

////
Have you explained the -&gt; operator?
TODO: add chapter for explain the threading macros
////

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def h (&#8594; (make-hierarchy)
           (derive :box :shape)
           (derive :circle :shape)))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Now you can use the same introspection functions with that locally defined hierarchy:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(isa? h :box :shape)
;; &#8658; true</p>
</div>
<div class="paragraph">
<p>(isa? :box :shape)
;; &#8658; false</p>
</div>
<div class="listingblock">
<div class="content">
<pre>As you can observe, in local hierarchies we can use normal (not namespace qualified) keywords,
and if we execute the `isa?` without passing the local hierarchy parameter, it returns `false`
as expected.


===== Hierarchies in multimethods

One of the big advantages of hierarchies is that they works very well together with multimethods.
This is because multimethods by default use the `isa?` function for the last step of dispatching.

Let's see an example to clearly understand what that means. Firstly, define the multimethod with
`defmulti` form:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(defmulti stringify-shape
  "A function that prints a human readable representation
  of a shape keyword."
  identity
  :hierarchy h)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>With `:hierarchy` keyword parameter we indicate to the multimethod that hierarchy we want to use;
if it is not specified, the global hierarchy will be used.

Secondly, we define an implementation for our multimethod using the `defmethod` form:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(defmethod stringify-shape :box
  [_]
  "A box shape")</p>
</div>
<div class="paragraph">
<p>(defmethod stringify-shape :shape
  [_]
  "A generic shape")</p>
</div>
<div class="paragraph">
<p>(defmethod stringify-shape :default
  [_]
  "Unexpected object")</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Now, let's see what happens if we execute that function with a box:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(stringify-shape :box)
;; &#8658; "A box shape"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Now everything works as expected; the multimethod executes the direct matching implementation
for the given parameter. Next, let's see what happens if we execute the same function but with the `:circle`
keyword as the parameter, which does not have the direct matching dispatch value:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(stringify-shape :circle)
;; &#8658; "A generic shape"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The multimethod automatically resolves it using the provided hierarchy, and since `:circle` is
a descendant of `:shape`, the `:shape` implementation is executed.


=== Data types

Until, now, we have used maps, sets, lists and vectors to represent our data. And in most cases, this is a
really great approach. But sometimes we need to define our own types, and in this book we will
call them *datatypes*.

A datatype provides the following:

* A unique host-backed type, either named or anonymous.
* The ability to implement protocols (inline).
* Explicitly declared structure using fields or closures.
* Map like behavior (via records, see below).


==== Deftype

The most low level construction in _ClojureScript_ for creating your own types is the `deftype` macro. As a
demonstration, we will define a type called `User`:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(deftype User [firstname lastname])</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Once the type has been defined, we can create an instance of our `User`. In the
following example, the `.` after `User` indicates that we are calling a constructor.

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def person (User. "Triss" "Merigold"))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>And its fields can be accessed using the prefix-dot notation:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(.-firstname person)
;; &#8658; "Triss"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Types defined with `deftype` (and `defrecord`, which we will see later) creates a host-backed class-like object
associated with the current namespace. But it has some peculiarities when we intend to use or import
it from another namespace. The types in _ClojureScript_ should be imported with the `:import` directive
of the `ns` macro:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(ns myns.core
  (:import otherns.User))</p>
</div>
<div class="paragraph">
<p>(User. "Cirilla" "Fiona")</p>
</div>
<div class="listingblock">
<div class="content">
<pre>For convenience, _ClojureScript_ also defines a constructor function caled `-&gt;User` that can be imported
in the common way using the `:require` directive.

We personally do not like this type of function, and we prefer to define our own constructors, with more
idiomatic names:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(defn make-user
  [firstname lastname]
  (User. firstname lastname))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>And use it in our code instead of `-&gt;User`.


==== Defrecord

The record is a slightly higher level abstraction for defining types in _ClojureScript_ and should be
preferred way to do it.

As we know, _ClojureScript_ tends to use plain data types such as maps, but in most cases we need
a named type to represent the entities of our application. Here come the records.

A record is a datatype that implements the map protocol and therefore can be used like any other map.
And since records are also proper types, they support type-based polymorphism through protocols.

In summary: with records, we have the best of both worlds, maps that can play in different
abstractions.

Let start defining the `User` type but using records:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(defrecord User [firstname lastname])</p>
</div>
<div class="listingblock">
<div class="content">
<pre>It looks really similar to the `deftype` syntax; in fact, it uses `deftype` behind the scenes as a low level
primitive for defining types.

Now, look at the difference with raw types for access to its fields:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def person (User. "Yennefer" "of Vengerberg"))</p>
</div>
<div class="paragraph">
<p>(:firstname user)
;; &#8658; "Yennefer"</p>
</div>
<div class="paragraph">
<p>(get person :firstname)
;; &#8658; "Yennefer"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>As we mentioned previously, records are maps and act like tham:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(map? person)
;; &#8658; true</p>
</div>
<div class="listingblock">
<div class="content">
<pre>And like maps, tham support extra fields that are not initially defined:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def person2 (assoc person :age 92))</p>
</div>
<div class="paragraph">
<p>(:age person2)
;; &#8658; 92</p>
</div>
<div class="listingblock">
<div class="content">
<pre>As we can see, the `assoc` function works as expected and returns a new instance of the same
type but with new key value pair. But take care with `dissoc`! Its behavior with records is slightly
different than with maps; it will return a new record if the field being dissociated is an optional
field, but it will return a plain map if you dissociate a mandatory field.

An other difference with maps is that records do not act like functions:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def plain-person {:firstname "Yennefer", :lastname "of Vengerberg"})</p>
</div>
<div class="paragraph">
<p>(plain-person :firstname)
;; &#8658; "Yennefer"</p>
</div>
<div class="paragraph">
<p>(person :firstname)
;; &#8658; person.User does not implement IFn protocol.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>For convenience, the `defrecord` macro, like `deftype`, exposes a `-&gt;User` function, as well as an additional
`map-&gt;User` constructor function. We have the same opinion about that constructor as with
`deftype` defined ones: we recommend defining your own instead of using the other ones. But as they exist, lets see
how they can be used:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def cirilla (&#8594;User "Cirilla" "Fiona"))
(def yen (map&#8594;User {:firstname "Yennefer"
                     :lastname "of Vengerberg"}))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>==== Implementing protocols

Both type definition primitives that we have seen so far allow inline implementations for protocols
(explained in a previous section). Let's define one for example purposes:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(defprotocol IUser
  "A common abstraction for working with user types."
  (full-name [_] "Get the full name of the user."))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Now, you can define a type with inline implementation for an abstraction, in our case the `IUser`:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(defrecord User [firstname lastname]
  IUser
  (full-name [_]
    (str firstname " " lastname)))</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<p>Create an instance.
(def user (User. "Yennefer" "of Vengerberg"))</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>(full-name user)
;; &#8658; "Yennefer of Vengerberg"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>==== Reify

The `reify` macro lets you create an anonymous type that implements protocols. In contrast to
`deftype` and `defrecord`, it does not have accessible fields.

This is  how we can emulate an instance of the user type that plays well with the `IUser` abstraction:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(defn user
  [firstname lastname]
  (reify
    IUser
    (full-name [_]
      (str firstname " " lastname))))</p>
</div>
<div class="paragraph">
<p>(def yen (user "Yennefer" "of Vengerberg"))
(full-name user)
;; &#8658; "Yennefer of Vengerberg"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The real purpose of `reify` is to create an anonymous type that may implement protocols,
but you don't want the type itself.


=== Host interoperability

_ClojureScript_, in the same way as it brother Clojure, is designed to be a "Guest" language. This means
that the design of the language works well on top of an existing ecosystem such as JavaScript
for _ClojureScript_ and the JVM for _Clojure_.


==== The types.

_ClojureScript_ unlike what you might expect, tries to take advantage of every type that the platform provides. This
is a (perhaps incomplete) list of things that _ClojureScript_ inherits and reuses from the underlying
platform:

* _ClojureScript_ strings are javascript *Strings*.
* _ClojureScript_ numbers are javascript *Numbers*.
* _ClojureScript_ `nil` is a javascript *null*.
* _ClojureScript_ regular expressions are javascript `RegExp` instances.
* _ClojureScript_ is not interpreted; it is always compiled down to JavaScript.
* _ClojureScript_ allows easy call to platform APIs with the same semantics.
* _ClojureScript_ data types internally compile to objects in JavaScript.

On top of it, _ClojureScript_ builds its own abstractions and types that do not exist in the
platform, such as Vectors, Maps, Sets, and others that are explained in previous sections of this chapter.


==== Interacting with platform types

_ClojureScript_ comes with a little set of special forms that allows it interact with platform
types such as calling object methods, creating new instances, and accessing object
properties.


===== Access to the platform

_ClojureScript_ has a special syntax for access to the entire platform environment through the
`js/` special namespace. This is an example of an expression to execute JavaScript's
built-in `parseInt` function:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(js/parseInt "222")
;; &#8658; 222</p>
</div>
<div class="listingblock">
<div class="content">
<pre>===== Creating new instances

_ClojureScript_ has two ways to create instances:

.Using the `new` special form
[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(new js/RegExp "^foo$")</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Using the `.` special form
[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(js/RegExp. "^foo$")</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The last one is the recommended way to create instances. We are not aware of real differences
between the two forms, but in the ClojureScript community the last one is used most often.


===== Invoke instance methods

To invoke methods of some object instance, as opposed to how it is done in JavaScript (e.g.,
`obj.method()`, the method name comes first like any other standard function in Lisp languages
but with a little variation: the function name starts with special form `.`.

Let's see how we can call the `.test()` method of a regexp instance:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def re (js/RegExp "^Clojure"))</p>
</div>
<div class="paragraph">
<p>(.test re "ClojureScript")
;; &#8658; true</p>
</div>
<div class="listingblock">
<div class="content">
<pre>===== Access to object properties

Access to the object properties is really very similar to calling a method. The difference is that
instead of using the `.` you use `.-`. Let's see an example:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(.-multiline re)
;; &#8658; false
(.-PI js/Math)
;; &#8658; 3.141592653589793</p>
</div>
<div class="listingblock">
<div class="content">
<pre>===== JavaScript objects

_ClojureScript_ has different ways to create plain JavaScript objects, each one has its own
purpose. The basic one is the `js-obj` function. It accepts a variable number of pairs of keys and
values and returns a JavaScript object:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(js-obj "country" "FR")
;; &#8658; #js {:country "FR"}</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The return value can be passed to some kind of third party library that accepts a plain
JavaScript object, but you can observe the real representation of the return value of this
function. It is really another other form for doing the same thing.

Using the reader macro `#js` consists of prepending it to a ClojureScript map or vector, and the
result will be transformed to plain JavaScript:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def myobj #js {:country "FR"})</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The translation of that to plain javascript is similar to this:

[source, javascript]</pre>
</div>
</div>
<div class="paragraph">
<p>var myobj = {country: "FR"};</p>
</div>
<div class="listingblock">
<div class="content">
<pre>As explained in previous section, you also can access to the plain object properties using
the `.-` syntax:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(.-country myobj)
;; &#8658; "FR"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>And as JavaScript objects are mutable, you can set a new value for some property using
the `set!` function:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(set! (.-country myobj) "KR")</p>
</div>
<div class="listingblock">
<div class="content">
<pre>===== Conversions

The inconvenience of the previously explained forms is that they does not make recursive
transformations, so if you have nested objects, the nested objects will not be converted.
To solve that use cases _ClojureScript_ comes with the `clj-&gt;js` and `js-&gt;clj` functions
that transform clojure collection types into JavaScript and back:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(clj&#8594;js {:foo {:bar "baz"}})
;; &#8658; #js {:foo #js {:bar "baz"}}</p>
</div>
<div class="listingblock">
<div class="content">
<pre>In case of arrays, there is a specialized function `into-array` that behaves as expected:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(into-array ["France" "Korea" "Peru"])
;; &#8658; #js ["France" "Korea" "Peru"]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>===== Arrays

In previous example we have seen how we can create an array from an existing _ClojureScript_
collection. But there is another function for creating arrays: `make-array`.

.Creating a preallocated array with length 10
[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def a (make-array 10))
;; &#8658; #js [nil nil nil nil nil nil nil nil nil nil]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>In _ClojureScript_ arrays also play well with sequence abstractions so you can iterate
over them or simply get the number of elements with the `count` function:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(count a)
;; &#8658; 10</p>
</div>
<div class="listingblock">
<div class="content">
<pre>As arrays on the JavaScript platform are a mutable collection type, you can access a concrete index
and set the value at that position:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(aset a 0 2)
;; &#8658; 2
a
;; &#8658; #js [2 nil nil nil nil nil nil nil nil nil]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Or access in a indexed way to get its values:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(aget a 0)
;; &#8658; 2</p>
</div>
<div class="listingblock">
<div class="content">
<pre>In JavaScript, objects are also arrays, so you can use the same functions for interacting
with plain objects:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def b #js {:hour 16})
;; &#8658; #js {:hour 16}</p>
</div>
<div class="paragraph">
<p>(aget b "hour")
;; &#8658; 16</p>
</div>
<div class="paragraph">
<p>(aset b "minute" 22)
;; &#8658; 22</p>
</div>
<div class="paragraph">
<p>b
;; &#8658; #js {:hour 16, :minute 22}</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== State management

TBD

anchor:truthiness-section[]
=== Truthiness

This is the aspect where each language has its own semantics. The majority of languages
consider empty collections, the integer 0, and other things like this to be false.
In _ClojureScript_, unlike in other languages, only two values are considered as false: `nil`
and `false`, Everything else is treated as `true`.

So, thanks to this, sets can be also be considered as predicates. If a set returns a value, it exists,
and if it returns `nil` the value does not exist:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def s #{1 2})</p>
</div>
<div class="paragraph">
<p>(s 1)
;; &#8658; 1</p>
</div>
<div class="paragraph">
<p>(s 3)
;; &#8658; nil</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== Transducers

TBD


=== Transients

TBD


=== Metadata

TBD


=== A little overview of macros

TBD


== Tooling &amp; Compiler

This chapter will cover a little introduction to existing tooling for making things easy when
developing using ClojureScript. It will cover:

* Using the repl
* Leiningen and cljsbuild
* Google Closure Library
* Modules
* Unit testing
* Library development
* Browser based development
* Server based development

Unlike the previous chapter, this chapter intends to tell different stories each independent of each other.

=== Getting Started with the ClojureScript compiler

At this point, you are surely very bored with the constant theoretical explanations about the language
itself and will want to write and execute some code. The goal of this section is to provide a little practical
introduction to the _ClojureScript_ compiler.

The _ClojureScript_ compiler takes the source code that has been split over numerous directories and namespaces and
compiles it down to JavaScript. Today, JavaScript has great number of different environments
where it can be executed - each with its own pecularities.

This chapter intends to explain how to use _ClojureScript_ without any additional tooling. This
will help you understand how the compiler works and how you can use it when other tooling is not
available (such as link:http://leiningen.org/[leiningen] + link:https://github.com/emezeske/lein-cljsbuild[cljsbuild]
or link:http://boot-clj.com/[boot]).


==== Execution environments

What is an execution environment? An execution environment is an engine where JavaScript can be
executed. For example, the most popular execution environment is a browser (Chrome, Firefox, ...)
followed by the second most popular - link:https://nodejs.org/[nodejs]/link:https://iojs.org/en/index.html[iojs].

There are others, such as Rhino (JDK 6+), Nashorn (JDK 8), QtQuick (QT),... but none of them have
significant differences from the first two. So, _ClojureScript_ at the moment may compile
code to run in the browser or in nodejs/iojs like environments out of the box.


==== Download the compiler

The _ClojureScript_ compiler is implemented in Java, and to use it, you should have jdk8 installed.
_ClojureScript_ itself only requires JDK 7, but the standalone compiler that we going to use in this
chapter requires JDK 8, which can be found at http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html

You can download it using `wget`:

[source, bash]</pre>
</div>
</div>
<div class="paragraph">
<p>wget <a href="https://github.com/clojure/clojurescript/releases/download/r3269/cljs.jar" class="bare">https://github.com/clojure/clojurescript/releases/download/r3269/cljs.jar</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>The _ClojureScript_ compiler is packaged in a standalone executable jar file, so this is the only
file (along with JDK 8) that you need to compile your _ClojureScript_ source code to JavaScript.


==== Compile for nodejs/iojs

Lets start with a practical example compiling code that will target *nodejs*/*iojs*. For
this example you should have nodejs or iojs (recommended) installed.

There are different ways to install iojs, but the recommended way is using nvm (node version
manager). You can read the instructions to install and use nvm at: https://github.com/creationix/nvm[home page].

You can test if *iojs* is installed in your system with this command:

[source, shell]</pre>
</div>
</div>
<div class="paragraph">
<p>$ iojs --version
v2.1.0</p>
</div>
<div class="listingblock">
<div class="content">
<pre>===== Create the example application

For the first step of our practical example, we will create our application directory structure
and populate it with example code.

Start by creating the directory tree structure for our hello world application:

[source, bash]</pre>
</div>
</div>
<div class="paragraph">
<p>mkdir -p src/myapp
touch src/myapp/core.cljs</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Second, write the example code into the previously created `src/myapp/core.cljs` file:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(ns myapp.core
  (:require [cljs.nodejs :as nodejs]))</p>
</div>
<div class="paragraph">
<p>(nodejs/enable-util-print!)</p>
</div>
<div class="paragraph">
<p>(defn -main
  [&amp; args]
  (println "Hello world!"))</p>
</div>
<div class="paragraph">
<p>(set! <strong>main-cli-fn</strong> -main)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>NOTE: It is very important that the declared namespace in the file exactly matches the directory
structure. This is the way _ClojureScript_ structures its source code.


===== Compile the example application

In order to compile that source code, we need a simple build script that tells the
_ClojureScript_ compiler the source directory and the output file. _ClojureScript_ has a
lot of other options, but at this moment we can ignore that.

Lets create the _build.clj_ file with the following content:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(require 'cljs.closure)</p>
</div>
<div class="paragraph">
<p>(cljs.closure/build "src"
 {:output-to "main.js"
  :main 'myapp.core
  :target :nodejs})</p>
</div>
<div class="listingblock">
<div class="content">
<pre>This is a brief explanation of the compiler options used in this example:

* The `:output-to` parameter indicates to the compiler the destination of the compiled code, in this
  case to the "main.js" file.
* The `:main` property indicates to the compiler the namespace that will act as the entry point of
  your application when it's executed.
* The `:target` property indicates the platform where you want execute the compiled code. In this case
  we are going to use *iojs* (formerly nodejs). If you omit this parameter, the source will be
  compiled to run in the browser environment.

To run the compilation, just execute the following command:

[source, bash]</pre>
</div>
</div>
<div class="paragraph">
<p>java -cp cljs.jar:src clojure.main build.clj</p>
</div>
<div class="listingblock">
<div class="content">
<pre>And when it finishes, execute the compiled file using *iojs*:

[source, shell]</pre>
</div>
</div>
<div class="paragraph">
<p>$ iojs main.js
Hello world!</p>
</div>
<div class="listingblock">
<div class="content">
<pre>==== Compile for the Browser

In this section we are going to create an application similar to the "hello world" example from the
previous section to run in the browser environment. The minimal requirement for this application
is just a browser that can execute JavaScript.

The process is almost the same, and the directory structure is the same. The only things that
changes is the entry point of the application and the build script. So, start re-creating
the directory tree from previous example in a different directory.

Then, write new content to the `src/myapp/core.cljs` file:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(ns myapp.core)</p>
</div>
<div class="paragraph">
<p>(enable-console-print!)</p>
</div>
<div class="paragraph">
<p>(println "Hello world!")</p>
</div>
<div class="listingblock">
<div class="content">
<pre>In the browser environment we do not need a specific entry point for the application,
so the entry point is the entire namespace.


===== Compile the example application

In order to compile the source code to run properly in a browser, overwrite
the _build.clj_ file with the following content:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(require 'cljs.closure)</p>
</div>
<div class="paragraph">
<p>(cljs.closure/build "src"
 {:output-to "main.js"
  :output-dir "out/"
  :source-map "main.js.map"
  :main 'myapp.core
  :optimizations :none})</p>
</div>
<div class="listingblock">
<div class="content">
<pre>This is a brief explanation of the compiler options we're using:

* The `:output-to` parameter indicates to the compiler the destination of the compiled code, in this
  case the "main.js" file.
* The `:main` property indicates to the compiler the namespace that will act as the entry point of
  your application when it's executed.
* `:source-map` indicates the destination of the source map. (The source map connects the ClojureScript source
  to the generated JavaScript so that error messages can point you back to the original source.)
* `:output-dir` indicates the destination directory for all files sources used in a compilation. It is
  just for making source maps work properly with the rest of code, not only your source.
* `:optimizations` indicates the compilation optimization. There are different values for this option,
  but that will be covered in following sections in more detail.

To run the compilation, just execute the following command:

[source, bash]</pre>
</div>
</div>
<div class="paragraph">
<p>java -cp cljs.jar:src clojure.main build.clj</p>
</div>
<div class="listingblock">
<div class="content">
<pre>This process can take some time, so do not worry; wait a little bit. The JVM bootstrap with Clojure
compiler is slightly slow. In the following sections we will explain how to start a watch process to avoid
constantly starting and stopping this slow process.

While waiting for the compilation, let's create a dummy HTML file to make it easy to execute our example
app in the browser. Create the _index.html_ file with the following content; it goes in the main _myapp_
directory.

[source, html]</pre>
</div>
</div>
<div class="paragraph">
<p>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;header&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;Hello World from ClojureScript&lt;/title&gt;
  &lt;/header&gt;
  &lt;body&gt;
    &lt;script src="main.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Now, when the compilation finishes and you have the basic HTML file you can just open it with your favorite
browser and take a look in the development tools console. The "Hello world!" message should appear there.


==== Watch process

Surely, you have already experienced the slow startup of the _ClojureScript_ compiler. To solve this,
the _ClojureScript_ standalone compiler also comes with tools to start a process that watches the changes
in some directory and performs an incremental compilation.

Start creating another build script, but in this case name it _watch.clj_:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(require 'cljs.closure)</p>
</div>
<div class="paragraph">
<p>(cljs.closure/watch "src"
 {:output-to "main.js"
  :output-dir "out/"
  :source-map "main.js.map"
  :main 'myapp.core
  :optimizations :none})</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Now, execute that script like any other that you have executed in previous sections:

[source, bash]</pre>
</div>
</div>
<div class="paragraph">
<p>$ java -cp cljs.jar:src clojure.main watch.clj
Building &#8230;&#8203;
Reading analysis cache for jar:file:/home/niwi/cljsbook/playground/cljs.jar!/cljs/core.cljs
Compiling out/cljs/core.cljs
Using cached cljs.core out/cljs/core.cljs
&#8230;&#8203; done. Elapsed 0.8354759 seconds
Watching paths: /home/niwi/cljsbook/playground/src</p>
</div>
<div class="paragraph">
<p>Change detected, recompiling &#8230;&#8203;
Compiling src/myapp/core.cljs
Compiling out/cljs/core.cljs
Using cached cljs.core out/cljs/core.cljs
&#8230;&#8203; done. Elapsed 0.191963443 seconds</p>
</div>
<div class="listingblock">
<div class="content">
<pre>You can observe that in the second compilation, the time is drastically reduced. Another advantage
of this method is that it is a gives a little bit more output.


==== Optimization levels

The _ClojureScript_ compiler has different level of optimizations. Behind the scenes, those compilation
levels are coming from Google Closure Compiler.

A very simplified overview of the compilation process is:

1. The reader reads the code and makes some analysis. This process can raise some warnings
   during this phase.
2. Then, the _ClojureScript_ compiler emits JavaScript code. The result is one JavaScript
   file for each cljs file.
3. The generated files passes through the Closure Compiler that, depending on the optimization level
   and other options (sourcemaps, output dir output to, ...) generates the final output.

The final output depends strictly on the optimization level.


===== none

Implies that closure compiler just writes the files as is, without any additional
optimization applied to the source code. This optimization level is mandatory if you are targeting
*nodejs* or *iojs* and is appropiate in development mode when your code targets the browser.


===== whitespace

This optimization level consists of concatenating the compiled files in an appropriate order, removing
line breaks and other whitespace and generating the output as one large file.

It also has some compilation speed penalty, resulting in slower compilations. In any case, it is not
terribly slow and is completely usable in small/medium applications.


===== simple

The simple compilation level implies (includes) all transformations from whitespace optimization and
additionally performs optimizations within expressions and functions, including renaming local variables
and function parameters to shorter names.

Compilation with the `:simple` optimization always preserves the functionality of syntactically valid
JavaScript, so it does not interfere with the interaction between the compiled _ClojureScript_ and
other JavaScript.


===== advanced

TBD


=== Working with the REPL

////
TODO: maybe would be interesting take some ideas from http://www.alexeberts.com/exploring-the-clojurescript-repl/
////

==== Introduction

Although you can create a source file and compile it every time you want to try something out in
ClojureScript, it's easier to use the REPL. REPL stands for:

* Read - get input from the keyboard
* Evaluate the input
* Print the result
* Loop back for more input

In other words, the REPL lets you try out ClojureScript concepts and get immediate feedback.

_ClojureScript_ comes with support for executing the REPL in different execution environments,
each one has its own advantages or disadvantages. For example, you can run a REPL in a nodejs
but in that environment you don't have access to the dom.

In summary: everthing really depends on your needs or requirements.


==== Nashorn REPL

The Nashorn REPL is the easiest and maybe most painless REPL environment because it does not require any
special stuff, just the JVM (JDK 8) that you have used in previous examples for running the
_ClojureScript_ compiler.

Lets start creating the _repl.clj_ file with following content:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(require '[cljs.repl]
         '[cljs.repl.nashorn])</p>
</div>
<div class="paragraph">
<p>(cljs.repl/repl
 (cljs.repl.nashorn/repl-env)
 :output-dir "out"
 :cache-analysis true)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Them, execute the following command to get the REPL up and running:

[source, bash]</pre>
</div>
</div>
<div class="paragraph">
<p>$ java -cp cljs.jar:src clojure.main repl.clj
To quit, type: :cljs/quit
cljs.user&#8658; (+ 1 2)
3</p>
</div>
<div class="listingblock">
<div class="content">
<pre>You may have noticed that the REPL does not have support for history and other shell-like facilities. This
is because the default REPL does not comes with "readline" support. But this problem can be solved using
the simple tool called `rlwrap` that you can certainly find with the package manager of your operating system.

The `rlwrap` makes the REPL "readline" capable and will allow you to have command history, code navigation,
and other shell-like utilities that will make your REPL experience much more pleasant. To use it, just
prepend it to the previous command that we have used to execute the REPL:

[source, bash]</pre>
</div>
</div>
<div class="paragraph">
<p>$ rlwrap java -cp cljs.jar:src clojure.main repl.clj
To quit, type: :cljs/quit
cljs.user&#8658; (+ 1 2)
3</p>
</div>
<div class="listingblock">
<div class="content">
<pre>==== Node REPL

This REPL uses a nodejs/iojs as execution environment, and obviously requires that nodejs or iojs will
be installed in your system.

Surelly you are asking yourself, why I need a repl with nodejs when we have nashorn that does not requires
any additional dependencies. The answer is very simple, node/iojs is the most used javascript execution
environment on backend and it has a great amount of community packages around it.

Well, the good notice is that start nodejs/iojs repl is very very easy once you have it installed in
your system. Start writing this content to a new `repl.clj` file:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(require '[cljs.repl]
         '[cljs.repl.node])</p>
</div>
<div class="paragraph">
<p>(cljs.repl/repl
 (cljs.repl.node/repl-env)
 :output-dir "out"
 :cache-analysis true)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>And start the REPL like you have done it previously with nashorn REPL:

[source,bash]</pre>
</div>
</div>
<div class="paragraph">
<p>$ rlwrap java -cp cljs.jar:src clojure.main repl.clj
To quit, type: :cljs/quit
cljs.user&#8658; (+ 1 2)
3</p>
</div>
<div class="listingblock">
<div class="content">
<pre>==== Browser REPL

This REPL is the most laborious to get it up and running. This is because it uses a browser for
its execution environment and it has additional requirements.

Lets start by creating a file named `brepl.clj` with the following content:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(require 'cljs.repl)
(require 'cljs.closure)
(require 'cljs.repl.browser)</p>
</div>
<div class="paragraph">
<p>(cljs.closure/build
 "src"
 {:output-to "main.js"
  :output-dir "out/"
  :source-map "main.js.map"
  :main 'myapp.core
  :optimizations :none})</p>
</div>
<div class="paragraph">
<p>(cljs.repl/repl
 (cljs.repl.browser/repl-env)
 :watch "src"
 :output-dir "out/")</p>
</div>
<div class="listingblock">
<div class="content">
<pre>This script builds the source, just as we did earlier, and then starts the REPL.

But the browser REPL also requires that some code be executed in the browser before getting the
REPL working. To do that, just re-create the application structure very similar to the one
that we have used in previous sections:

[source, bash]</pre>
</div>
</div>
<div class="paragraph">
<p>mkdir -p src/myapp
touch src/myapp/core.cljs</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Then, write new content to the `src/myapp/core.cljs` file:

[source, clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(ns myapp.core
 (:require [clojure.browser.repl :as repl]))</p>
</div>
<div class="paragraph">
<p>(defonce conn
  (repl/connect "http://localhost:9000/repl"))</p>
</div>
<div class="paragraph">
<p>(enable-console-print!)</p>
</div>
<div class="paragraph">
<p>(println "Hello, world!")</p>
</div>
<div class="listingblock">
<div class="content">
<pre>And finally, create the missing _index.html_ file that is going to be used as the entry point
for running the browser side code of the REPL:

[source, html]</pre>
</div>
</div>
<div class="paragraph">
<p>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;header&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;Hello World from ClojureScript&lt;/title&gt;
  &lt;/header&gt;
  &lt;body&gt;
    &lt;script src="main.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Well, that was a lot of setup! But trust us, its all worth it when you see it in action. To do that,
just execute the `brepl.clj` in same way that we have done it in previous examples:

[source, bash]</pre>
</div>
</div>
<div class="paragraph">
<p>$ rlwrap java -cp cljs.jar:src clojure.main brepl.clj
Compiling client js &#8230;&#8203;
Waiting for browser to connect &#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>And finally, open your favourite browser and go to http://localhost:9000/. Once the page
is loaded (the page will be blank), switch back to the console where you have run the REPL
and you will see that it is up and running:

[source, bash]</pre>
</div>
</div>
<div class="paragraph">
<p>Watch compilation log available at: out/watch.log
To quit, type: :cljs/quit
cljs.user&#8658; (+ 14 28)
42</p>
</div>
<div class="listingblock">
<div class="content">
<pre>One of the big advantages of this REPL is that you have access to all the browser environment. To
demonstrate it, just enter `(js/alert "hello world")` in the repl. The result of that will be
the typical browser alert dialog.


=== Build and Dependency management tools

Until now, we have used the builtin _ClojureScript_ toolchain for compile our sources to javascript,
and it is ok for start using it and understand how it works. But it is not very comfortable for use
for big projects with dependencies to third party libraries.

This chapter intends to explain how you can use *Leiningen*, the defacto clojure build and dependency
management tool for build _ClojureScript_ projects. It there an other growing in popularity build tool
called *boot* but at this momenent it will not to be covered in this book.


==== Installing leiningen

The installation process of leiningen is quite simple, just follow this steps:

[source, bash]</pre>
</div>
</div>
<div class="paragraph">
<p>mkdir ~/bin
cd ~/bin
wget <a href="https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein" class="bare">https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein</a>
chmod a+x ./lein
export PATH=$PATH:~/bin</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Make sure that the `~/bin` directory is always set on your path, so for make it permanent, add the
line of export to your `~/.bashrc` file (we are supposing that you are using bash shell).

And now, open another clean terminal and execute `lein version`:

[source, bash]</pre>
</div>
</div>
<div class="paragraph">
<p>$ lein version
Leiningen 2.5.1 on Java 1.8.0_45 OpenJDK 64-Bit Server VM</p>
</div>
<div class="listingblock">
<div class="content">
<pre>NOTE: We are supposing that you are using Unix like system such as Linux or BSD, if you are
windows user, please check the instructions on the link:http://leiningen.org/[Leiningen homepage].


==== First project

TBD


=== The Closure Library

TBD


=== Browser based development

TBD

//^ A little guide and notes about implications of developing for web
//^ environments (optimizations, third party libraries, modularization, ...)

==== Using third party JavaScript libraries

TBD


====  Modularizing your code

//^ Mainly related to google closure modules and slightly related to web based development
//^ Maybe this is not the chapter for this section.

TBD



=== Developing a library

//^ A little guide and implications of developing a library for clojurescript.

TBD


=== Unit testing

TBD


== Mixed Bag

This chapter will cover miscellaneous topics that are not classified in the previous ones. This is a
"catchall" section and will touch a bunch of heterogeneus topics like:

* Async primitives using the _core.async_ library.
* Working with promises.
* Error handling using the _cats_ library.
* Pattern matching with the _core.match_ library.
* Web development using the Om library.
* Share code between clojure and clojurescript.

=== Async primitives using core.async.

TBD

=== Working with promises.

TBD


=== Error handling using monads and Cats.

TBD


=== Pattern matching using core.match.

TBD


=== Web development with Om and React.

TBD


=== Writing libraries that shares code between Clojure and ClojureScript.

TBD

//^ This chapter can grow as we like with different dispare themes ;)</pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1<br/>
Last updated 2015-06-02 17:00:43 CEST
</div>
</div>
</body>
</html>